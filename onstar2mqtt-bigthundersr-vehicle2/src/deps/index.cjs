'use strict';

var require$$1 = require('util');
var stream = require('stream');
var require$$1$1 = require('path');
var require$$0$2 = require('http');
var require$$2 = require('https');
var require$$5 = require('url');
var fs = require('fs');
var require$$0$5 = require('assert');
var require$$0$4 = require('tty');
var require$$0$3 = require('os');
var zlib$1 = require('zlib');
var require$$2$1 = require('events');
var require$$1$2 = require('node:url');
var require$$0$6 = require('node:http');
var require$$0$7 = require('node:https');
var require$$0$8 = require('net');
var require$$0$9 = require('crypto');
var require$$1$3 = require('querystring');
var require$$0$a = require('buffer');

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol, Iterator */


function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

function bind(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}

// utils is a library of generic helper functions non-specific to axios

const {toString} = Object.prototype;
const {getPrototypeOf} = Object;

const kindOf = (cache => thing => {
    const str = toString.call(thing);
    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(Object.create(null));

const kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type
};

const typeOfTest = type => thing => typeof thing === type;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 *
 * @returns {boolean} True if value is an Array, otherwise false
 */
const {isArray} = Array;

/**
 * Determine if a value is undefined
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if the value is undefined, otherwise false
 */
const isUndefined = typeOfTest('undefined');

/**
 * Determine if a value is a Buffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Buffer, otherwise false
 */
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
    && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
const isArrayBuffer = kindOfTest('ArrayBuffer');


/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  let result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (isArrayBuffer(val.buffer));
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a String, otherwise false
 */
const isString = typeOfTest('string');

/**
 * Determine if a value is a Function
 *
 * @param {*} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
const isFunction = typeOfTest('function');

/**
 * Determine if a value is a Number
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Number, otherwise false
 */
const isNumber = typeOfTest('number');

/**
 * Determine if a value is an Object
 *
 * @param {*} thing The value to test
 *
 * @returns {boolean} True if value is an Object, otherwise false
 */
const isObject = (thing) => thing !== null && typeof thing === 'object';

/**
 * Determine if a value is a Boolean
 *
 * @param {*} thing The value to test
 * @returns {boolean} True if value is a Boolean, otherwise false
 */
const isBoolean = thing => thing === true || thing === false;

/**
 * Determine if a value is a plain Object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a plain Object, otherwise false
 */
const isPlainObject = (val) => {
  if (kindOf(val) !== 'object') {
    return false;
  }

  const prototype = getPrototypeOf(val);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};

/**
 * Determine if a value is a Date
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Date, otherwise false
 */
const isDate = kindOfTest('Date');

/**
 * Determine if a value is a File
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a File, otherwise false
 */
const isFile = kindOfTest('File');

/**
 * Determine if a value is a Blob
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Blob, otherwise false
 */
const isBlob = kindOfTest('Blob');

/**
 * Determine if a value is a FileList
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a File, otherwise false
 */
const isFileList = kindOfTest('FileList');

/**
 * Determine if a value is a Stream
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Stream, otherwise false
 */
const isStream = (val) => isObject(val) && isFunction(val.pipe);

/**
 * Determine if a value is a FormData
 *
 * @param {*} thing The value to test
 *
 * @returns {boolean} True if value is an FormData, otherwise false
 */
const isFormData = (thing) => {
  let kind;
  return thing && (
    (typeof FormData === 'function' && thing instanceof FormData) || (
      isFunction(thing.append) && (
        (kind = kindOf(thing)) === 'formdata' ||
        // detect form-data instance
        (kind === 'object' && isFunction(thing.toString) && thing.toString() === '[object FormData]')
      )
    )
  )
};

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
const isURLSearchParams = kindOfTest('URLSearchParams');

const [isReadableStream, isRequest, isResponse, isHeaders] = ['ReadableStream', 'Request', 'Response', 'Headers'].map(kindOfTest);

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 *
 * @returns {String} The String freed of excess whitespace
 */
const trim = (str) => str.trim ?
  str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 *
 * @param {Boolean} [allOwnKeys = false]
 * @returns {any}
 */
function forEach(obj, fn, {allOwnKeys = false} = {}) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  let i;
  let l;

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;

    for (i = 0; i < len; i++) {
      key = keys[i];
      fn.call(null, obj[key], key, obj);
    }
  }
}

function findKey(obj, key) {
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i = keys.length;
  let _key;
  while (i-- > 0) {
    _key = keys[i];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}

const _global = (() => {
  /*eslint no-undef:0*/
  if (typeof globalThis !== "undefined") return globalThis;
  return typeof self !== "undefined" ? self : (typeof window !== 'undefined' ? window : global)
})();

const isContextDefined = (context) => !isUndefined(context) && context !== _global;

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 *
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  const {caseless} = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };

  for (let i = 0, l = arguments.length; i < l; i++) {
    arguments[i] && forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 *
 * @param {Boolean} [allOwnKeys]
 * @returns {Object} The resulting value of object a
 */
const extend = (a, b, thisArg, {allOwnKeys}= {}) => {
  forEach(b, (val, key) => {
    if (thisArg && isFunction(val)) {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  }, {allOwnKeys});
  return a;
};

/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 *
 * @returns {string} content value without BOM
 */
const stripBOM = (content) => {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }
  return content;
};

/**
 * Inherit the prototype methods from one constructor into another
 * @param {function} constructor
 * @param {function} superConstructor
 * @param {object} [props]
 * @param {object} [descriptors]
 *
 * @returns {void}
 */
const inherits = (constructor, superConstructor, props, descriptors) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, 'super', {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};

/**
 * Resolve object with deep prototype chain to a flat object
 * @param {Object} sourceObj source object
 * @param {Object} [destObj]
 * @param {Function|Boolean} [filter]
 * @param {Function} [propFilter]
 *
 * @returns {Object}
 */
const toFlatObject = (sourceObj, destObj, filter, propFilter) => {
  let props;
  let i;
  let prop;
  const merged = {};

  destObj = destObj || {};
  // eslint-disable-next-line no-eq-null,eqeqeq
  if (sourceObj == null) return destObj;

  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);

  return destObj;
};

/**
 * Determines whether a string ends with the characters of a specified string
 *
 * @param {String} str
 * @param {String} searchString
 * @param {Number} [position= 0]
 *
 * @returns {boolean}
 */
const endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === undefined || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};


/**
 * Returns new array from array like object or null if failed
 *
 * @param {*} [thing]
 *
 * @returns {?Array}
 */
const toArray = (thing) => {
  if (!thing) return null;
  if (isArray(thing)) return thing;
  let i = thing.length;
  if (!isNumber(i)) return null;
  const arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
};

/**
 * Checking if the Uint8Array exists and if it does, it returns a function that checks if the
 * thing passed in is an instance of Uint8Array
 *
 * @param {TypedArray}
 *
 * @returns {Array}
 */
// eslint-disable-next-line func-names
const isTypedArray = (TypedArray => {
  // eslint-disable-next-line func-names
  return thing => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== 'undefined' && getPrototypeOf(Uint8Array));

/**
 * For each entry in the object, call the function with the key and value.
 *
 * @param {Object<any, any>} obj - The object to iterate over.
 * @param {Function} fn - The function to call for each entry.
 *
 * @returns {void}
 */
const forEachEntry = (obj, fn) => {
  const generator = obj && obj[Symbol.iterator];

  const iterator = generator.call(obj);

  let result;

  while ((result = iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};

/**
 * It takes a regular expression and a string, and returns an array of all the matches
 *
 * @param {string} regExp - The regular expression to match against.
 * @param {string} str - The string to search.
 *
 * @returns {Array<boolean>}
 */
const matchAll = (regExp, str) => {
  let matches;
  const arr = [];

  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }

  return arr;
};

/* Checking if the kindOfTest function returns true when passed an HTMLFormElement. */
const isHTMLForm = kindOfTest('HTMLFormElement');

const toCamelCase = str => {
  return str.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g,
    function replacer(m, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};

/* Creating a function that will check if an object has a property. */
const hasOwnProperty = (({hasOwnProperty}) => (obj, prop) => hasOwnProperty.call(obj, prop))(Object.prototype);

/**
 * Determine if a value is a RegExp object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a RegExp object, otherwise false
 */
const isRegExp = kindOfTest('RegExp');

const reduceDescriptors = (obj, reducer) => {
  const descriptors = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};

  forEach(descriptors, (descriptor, name) => {
    let ret;
    if ((ret = reducer(descriptor, name, obj)) !== false) {
      reducedDescriptors[name] = ret || descriptor;
    }
  });

  Object.defineProperties(obj, reducedDescriptors);
};

/**
 * Makes all methods read-only
 * @param {Object} obj
 */

const freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    // skip restricted props in strict mode
    if (isFunction(obj) && ['arguments', 'caller', 'callee'].indexOf(name) !== -1) {
      return false;
    }

    const value = obj[name];

    if (!isFunction(value)) return;

    descriptor.enumerable = false;

    if ('writable' in descriptor) {
      descriptor.writable = false;
      return;
    }

    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error('Can not rewrite read-only method \'' + name + '\'');
      };
    }
  });
};

const toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};

  const define = (arr) => {
    arr.forEach(value => {
      obj[value] = true;
    });
  };

  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));

  return obj;
};

const noop = () => {};

const toFiniteNumber = (value, defaultValue) => {
  return value != null && Number.isFinite(value = +value) ? value : defaultValue;
};

const ALPHA = 'abcdefghijklmnopqrstuvwxyz';

const DIGIT = '0123456789';

const ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};

const generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
  let str = '';
  const {length} = alphabet;
  while (size--) {
    str += alphabet[Math.random() * length|0];
  }

  return str;
};

/**
 * If the thing is a FormData object, return true, otherwise return false.
 *
 * @param {unknown} thing - The thing to check.
 *
 * @returns {boolean}
 */
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === 'FormData' && thing[Symbol.iterator]);
}

const toJSONObject = (obj) => {
  const stack = new Array(10);

  const visit = (source, i) => {

    if (isObject(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }

      if(!('toJSON' in source)) {
        stack[i] = source;
        const target = isArray(source) ? [] : {};

        forEach(source, (value, key) => {
          const reducedValue = visit(value, i + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });

        stack[i] = undefined;

        return target;
      }
    }

    return source;
  };

  return visit(obj, 0);
};

const isAsyncFn = kindOfTest('AsyncFunction');

const isThenable = (thing) =>
  thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);

// original code
// https://github.com/DigitalBrainJS/AxiosPromise/blob/16deab13710ec09779922131f3fa5954320f83ab/lib/utils.js#L11-L34

const _setImmediate = ((setImmediateSupported, postMessageSupported) => {
  if (setImmediateSupported) {
    return setImmediate;
  }

  return postMessageSupported ? ((token, callbacks) => {
    _global.addEventListener("message", ({source, data}) => {
      if (source === _global && data === token) {
        callbacks.length && callbacks.shift()();
      }
    }, false);

    return (cb) => {
      callbacks.push(cb);
      _global.postMessage(token, "*");
    }
  })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
})(
  typeof setImmediate === 'function',
  isFunction(_global.postMessage)
);

const asap = typeof queueMicrotask !== 'undefined' ?
  queueMicrotask.bind(_global) : ( typeof process !== 'undefined' && process.nextTick || _setImmediate);

// *********************

var utils$2 = {
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject,
  isPlainObject,
  isReadableStream,
  isRequest,
  isResponse,
  isHeaders,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty, // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  ALPHABET,
  generateString,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable,
  setImmediate: _setImmediate,
  asap
};

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [config] The config.
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 *
 * @returns {Error} The created error.
 */
function AxiosError(message, code, config, request, response) {
  Error.call(this);

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = (new Error()).stack;
  }

  this.message = message;
  this.name = 'AxiosError';
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  if (response) {
    this.response = response;
    this.status = response.status ? response.status : null;
  }
}

utils$2.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils$2.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});

const prototype$1 = AxiosError.prototype;
const descriptors = {};

[
  'ERR_BAD_OPTION_VALUE',
  'ERR_BAD_OPTION',
  'ECONNABORTED',
  'ETIMEDOUT',
  'ERR_NETWORK',
  'ERR_FR_TOO_MANY_REDIRECTS',
  'ERR_DEPRECATED',
  'ERR_BAD_RESPONSE',
  'ERR_BAD_REQUEST',
  'ERR_CANCELED',
  'ERR_NOT_SUPPORT',
  'ERR_INVALID_URL'
// eslint-disable-next-line func-names
].forEach(code => {
  descriptors[code] = {value: code};
});

Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype$1, 'isAxiosError', {value: true});

// eslint-disable-next-line func-names
AxiosError.from = (error, code, config, request, response, customProps) => {
  const axiosError = Object.create(prototype$1);

  utils$2.toFlatObject(error, axiosError, function filter(obj) {
    return obj !== Error.prototype;
  }, prop => {
    return prop !== 'isAxiosError';
  });

  AxiosError.call(axiosError, error.message, code, config, request, response);

  axiosError.cause = error;

  axiosError.name = error.name;

  customProps && Object.assign(axiosError, customProps);

  return axiosError;
};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function getAugmentedNamespace(n) {
  if (n.__esModule) return n;
  var f = n.default;
	if (typeof f == "function") {
		var a = function a () {
			if (this instanceof a) {
        return Reflect.construct(f, arguments, this.constructor);
			}
			return f.apply(this, arguments);
		};
		a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, '__esModule', {value: true});
	Object.keys(n).forEach(function (k) {
		var d = Object.getOwnPropertyDescriptor(n, k);
		Object.defineProperty(a, k, d.get ? d : {
			enumerable: true,
			get: function () {
				return n[k];
			}
		});
	});
	return a;
}

var delayed_stream;
var hasRequiredDelayed_stream;

function requireDelayed_stream () {
	if (hasRequiredDelayed_stream) return delayed_stream;
	hasRequiredDelayed_stream = 1;
	var Stream = stream.Stream;
	var util = require$$1;

	delayed_stream = DelayedStream;
	function DelayedStream() {
	  this.source = null;
	  this.dataSize = 0;
	  this.maxDataSize = 1024 * 1024;
	  this.pauseStream = true;

	  this._maxDataSizeExceeded = false;
	  this._released = false;
	  this._bufferedEvents = [];
	}
	util.inherits(DelayedStream, Stream);

	DelayedStream.create = function(source, options) {
	  var delayedStream = new this();

	  options = options || {};
	  for (var option in options) {
	    delayedStream[option] = options[option];
	  }

	  delayedStream.source = source;

	  var realEmit = source.emit;
	  source.emit = function() {
	    delayedStream._handleEmit(arguments);
	    return realEmit.apply(source, arguments);
	  };

	  source.on('error', function() {});
	  if (delayedStream.pauseStream) {
	    source.pause();
	  }

	  return delayedStream;
	};

	Object.defineProperty(DelayedStream.prototype, 'readable', {
	  configurable: true,
	  enumerable: true,
	  get: function() {
	    return this.source.readable;
	  }
	});

	DelayedStream.prototype.setEncoding = function() {
	  return this.source.setEncoding.apply(this.source, arguments);
	};

	DelayedStream.prototype.resume = function() {
	  if (!this._released) {
	    this.release();
	  }

	  this.source.resume();
	};

	DelayedStream.prototype.pause = function() {
	  this.source.pause();
	};

	DelayedStream.prototype.release = function() {
	  this._released = true;

	  this._bufferedEvents.forEach(function(args) {
	    this.emit.apply(this, args);
	  }.bind(this));
	  this._bufferedEvents = [];
	};

	DelayedStream.prototype.pipe = function() {
	  var r = Stream.prototype.pipe.apply(this, arguments);
	  this.resume();
	  return r;
	};

	DelayedStream.prototype._handleEmit = function(args) {
	  if (this._released) {
	    this.emit.apply(this, args);
	    return;
	  }

	  if (args[0] === 'data') {
	    this.dataSize += args[1].length;
	    this._checkIfMaxDataSizeExceeded();
	  }

	  this._bufferedEvents.push(args);
	};

	DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
	  if (this._maxDataSizeExceeded) {
	    return;
	  }

	  if (this.dataSize <= this.maxDataSize) {
	    return;
	  }

	  this._maxDataSizeExceeded = true;
	  var message =
	    'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.';
	  this.emit('error', new Error(message));
	};
	return delayed_stream;
}

var combined_stream;
var hasRequiredCombined_stream;

function requireCombined_stream () {
	if (hasRequiredCombined_stream) return combined_stream;
	hasRequiredCombined_stream = 1;
	var util = require$$1;
	var Stream = stream.Stream;
	var DelayedStream = requireDelayed_stream();

	combined_stream = CombinedStream;
	function CombinedStream() {
	  this.writable = false;
	  this.readable = true;
	  this.dataSize = 0;
	  this.maxDataSize = 2 * 1024 * 1024;
	  this.pauseStreams = true;

	  this._released = false;
	  this._streams = [];
	  this._currentStream = null;
	  this._insideLoop = false;
	  this._pendingNext = false;
	}
	util.inherits(CombinedStream, Stream);

	CombinedStream.create = function(options) {
	  var combinedStream = new this();

	  options = options || {};
	  for (var option in options) {
	    combinedStream[option] = options[option];
	  }

	  return combinedStream;
	};

	CombinedStream.isStreamLike = function(stream) {
	  return (typeof stream !== 'function')
	    && (typeof stream !== 'string')
	    && (typeof stream !== 'boolean')
	    && (typeof stream !== 'number')
	    && (!Buffer.isBuffer(stream));
	};

	CombinedStream.prototype.append = function(stream) {
	  var isStreamLike = CombinedStream.isStreamLike(stream);

	  if (isStreamLike) {
	    if (!(stream instanceof DelayedStream)) {
	      var newStream = DelayedStream.create(stream, {
	        maxDataSize: Infinity,
	        pauseStream: this.pauseStreams,
	      });
	      stream.on('data', this._checkDataSize.bind(this));
	      stream = newStream;
	    }

	    this._handleErrors(stream);

	    if (this.pauseStreams) {
	      stream.pause();
	    }
	  }

	  this._streams.push(stream);
	  return this;
	};

	CombinedStream.prototype.pipe = function(dest, options) {
	  Stream.prototype.pipe.call(this, dest, options);
	  this.resume();
	  return dest;
	};

	CombinedStream.prototype._getNext = function() {
	  this._currentStream = null;

	  if (this._insideLoop) {
	    this._pendingNext = true;
	    return; // defer call
	  }

	  this._insideLoop = true;
	  try {
	    do {
	      this._pendingNext = false;
	      this._realGetNext();
	    } while (this._pendingNext);
	  } finally {
	    this._insideLoop = false;
	  }
	};

	CombinedStream.prototype._realGetNext = function() {
	  var stream = this._streams.shift();


	  if (typeof stream == 'undefined') {
	    this.end();
	    return;
	  }

	  if (typeof stream !== 'function') {
	    this._pipeNext(stream);
	    return;
	  }

	  var getStream = stream;
	  getStream(function(stream) {
	    var isStreamLike = CombinedStream.isStreamLike(stream);
	    if (isStreamLike) {
	      stream.on('data', this._checkDataSize.bind(this));
	      this._handleErrors(stream);
	    }

	    this._pipeNext(stream);
	  }.bind(this));
	};

	CombinedStream.prototype._pipeNext = function(stream) {
	  this._currentStream = stream;

	  var isStreamLike = CombinedStream.isStreamLike(stream);
	  if (isStreamLike) {
	    stream.on('end', this._getNext.bind(this));
	    stream.pipe(this, {end: false});
	    return;
	  }

	  var value = stream;
	  this.write(value);
	  this._getNext();
	};

	CombinedStream.prototype._handleErrors = function(stream) {
	  var self = this;
	  stream.on('error', function(err) {
	    self._emitError(err);
	  });
	};

	CombinedStream.prototype.write = function(data) {
	  this.emit('data', data);
	};

	CombinedStream.prototype.pause = function() {
	  if (!this.pauseStreams) {
	    return;
	  }

	  if(this.pauseStreams && this._currentStream && typeof(this._currentStream.pause) == 'function') this._currentStream.pause();
	  this.emit('pause');
	};

	CombinedStream.prototype.resume = function() {
	  if (!this._released) {
	    this._released = true;
	    this.writable = true;
	    this._getNext();
	  }

	  if(this.pauseStreams && this._currentStream && typeof(this._currentStream.resume) == 'function') this._currentStream.resume();
	  this.emit('resume');
	};

	CombinedStream.prototype.end = function() {
	  this._reset();
	  this.emit('end');
	};

	CombinedStream.prototype.destroy = function() {
	  this._reset();
	  this.emit('close');
	};

	CombinedStream.prototype._reset = function() {
	  this.writable = false;
	  this._streams = [];
	  this._currentStream = null;
	};

	CombinedStream.prototype._checkDataSize = function() {
	  this._updateDataSize();
	  if (this.dataSize <= this.maxDataSize) {
	    return;
	  }

	  var message =
	    'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.';
	  this._emitError(new Error(message));
	};

	CombinedStream.prototype._updateDataSize = function() {
	  this.dataSize = 0;

	  var self = this;
	  this._streams.forEach(function(stream) {
	    if (!stream.dataSize) {
	      return;
	    }

	    self.dataSize += stream.dataSize;
	  });

	  if (this._currentStream && this._currentStream.dataSize) {
	    this.dataSize += this._currentStream.dataSize;
	  }
	};

	CombinedStream.prototype._emitError = function(err) {
	  this._reset();
	  this.emit('error', err);
	};
	return combined_stream;
}

var mimeTypes = {};

var require$$0$1 = {
	"application/1d-interleaved-parityfec": {
	source: "iana"
},
	"application/3gpdash-qoe-report+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/3gpp-ims+xml": {
	source: "iana",
	compressible: true
},
	"application/3gpphal+json": {
	source: "iana",
	compressible: true
},
	"application/3gpphalforms+json": {
	source: "iana",
	compressible: true
},
	"application/a2l": {
	source: "iana"
},
	"application/ace+cbor": {
	source: "iana"
},
	"application/activemessage": {
	source: "iana"
},
	"application/activity+json": {
	source: "iana",
	compressible: true
},
	"application/alto-costmap+json": {
	source: "iana",
	compressible: true
},
	"application/alto-costmapfilter+json": {
	source: "iana",
	compressible: true
},
	"application/alto-directory+json": {
	source: "iana",
	compressible: true
},
	"application/alto-endpointcost+json": {
	source: "iana",
	compressible: true
},
	"application/alto-endpointcostparams+json": {
	source: "iana",
	compressible: true
},
	"application/alto-endpointprop+json": {
	source: "iana",
	compressible: true
},
	"application/alto-endpointpropparams+json": {
	source: "iana",
	compressible: true
},
	"application/alto-error+json": {
	source: "iana",
	compressible: true
},
	"application/alto-networkmap+json": {
	source: "iana",
	compressible: true
},
	"application/alto-networkmapfilter+json": {
	source: "iana",
	compressible: true
},
	"application/alto-updatestreamcontrol+json": {
	source: "iana",
	compressible: true
},
	"application/alto-updatestreamparams+json": {
	source: "iana",
	compressible: true
},
	"application/aml": {
	source: "iana"
},
	"application/andrew-inset": {
	source: "iana",
	extensions: [
		"ez"
	]
},
	"application/applefile": {
	source: "iana"
},
	"application/applixware": {
	source: "apache",
	extensions: [
		"aw"
	]
},
	"application/at+jwt": {
	source: "iana"
},
	"application/atf": {
	source: "iana"
},
	"application/atfx": {
	source: "iana"
},
	"application/atom+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"atom"
	]
},
	"application/atomcat+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"atomcat"
	]
},
	"application/atomdeleted+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"atomdeleted"
	]
},
	"application/atomicmail": {
	source: "iana"
},
	"application/atomsvc+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"atomsvc"
	]
},
	"application/atsc-dwd+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"dwd"
	]
},
	"application/atsc-dynamic-event-message": {
	source: "iana"
},
	"application/atsc-held+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"held"
	]
},
	"application/atsc-rdt+json": {
	source: "iana",
	compressible: true
},
	"application/atsc-rsat+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rsat"
	]
},
	"application/atxml": {
	source: "iana"
},
	"application/auth-policy+xml": {
	source: "iana",
	compressible: true
},
	"application/bacnet-xdd+zip": {
	source: "iana",
	compressible: false
},
	"application/batch-smtp": {
	source: "iana"
},
	"application/bdoc": {
	compressible: false,
	extensions: [
		"bdoc"
	]
},
	"application/beep+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/calendar+json": {
	source: "iana",
	compressible: true
},
	"application/calendar+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xcs"
	]
},
	"application/call-completion": {
	source: "iana"
},
	"application/cals-1840": {
	source: "iana"
},
	"application/captive+json": {
	source: "iana",
	compressible: true
},
	"application/cbor": {
	source: "iana"
},
	"application/cbor-seq": {
	source: "iana"
},
	"application/cccex": {
	source: "iana"
},
	"application/ccmp+xml": {
	source: "iana",
	compressible: true
},
	"application/ccxml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"ccxml"
	]
},
	"application/cdfx+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"cdfx"
	]
},
	"application/cdmi-capability": {
	source: "iana",
	extensions: [
		"cdmia"
	]
},
	"application/cdmi-container": {
	source: "iana",
	extensions: [
		"cdmic"
	]
},
	"application/cdmi-domain": {
	source: "iana",
	extensions: [
		"cdmid"
	]
},
	"application/cdmi-object": {
	source: "iana",
	extensions: [
		"cdmio"
	]
},
	"application/cdmi-queue": {
	source: "iana",
	extensions: [
		"cdmiq"
	]
},
	"application/cdni": {
	source: "iana"
},
	"application/cea": {
	source: "iana"
},
	"application/cea-2018+xml": {
	source: "iana",
	compressible: true
},
	"application/cellml+xml": {
	source: "iana",
	compressible: true
},
	"application/cfw": {
	source: "iana"
},
	"application/city+json": {
	source: "iana",
	compressible: true
},
	"application/clr": {
	source: "iana"
},
	"application/clue+xml": {
	source: "iana",
	compressible: true
},
	"application/clue_info+xml": {
	source: "iana",
	compressible: true
},
	"application/cms": {
	source: "iana"
},
	"application/cnrp+xml": {
	source: "iana",
	compressible: true
},
	"application/coap-group+json": {
	source: "iana",
	compressible: true
},
	"application/coap-payload": {
	source: "iana"
},
	"application/commonground": {
	source: "iana"
},
	"application/conference-info+xml": {
	source: "iana",
	compressible: true
},
	"application/cose": {
	source: "iana"
},
	"application/cose-key": {
	source: "iana"
},
	"application/cose-key-set": {
	source: "iana"
},
	"application/cpl+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"cpl"
	]
},
	"application/csrattrs": {
	source: "iana"
},
	"application/csta+xml": {
	source: "iana",
	compressible: true
},
	"application/cstadata+xml": {
	source: "iana",
	compressible: true
},
	"application/csvm+json": {
	source: "iana",
	compressible: true
},
	"application/cu-seeme": {
	source: "apache",
	extensions: [
		"cu"
	]
},
	"application/cwt": {
	source: "iana"
},
	"application/cybercash": {
	source: "iana"
},
	"application/dart": {
	compressible: true
},
	"application/dash+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mpd"
	]
},
	"application/dash-patch+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mpp"
	]
},
	"application/dashdelta": {
	source: "iana"
},
	"application/davmount+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"davmount"
	]
},
	"application/dca-rft": {
	source: "iana"
},
	"application/dcd": {
	source: "iana"
},
	"application/dec-dx": {
	source: "iana"
},
	"application/dialog-info+xml": {
	source: "iana",
	compressible: true
},
	"application/dicom": {
	source: "iana"
},
	"application/dicom+json": {
	source: "iana",
	compressible: true
},
	"application/dicom+xml": {
	source: "iana",
	compressible: true
},
	"application/dii": {
	source: "iana"
},
	"application/dit": {
	source: "iana"
},
	"application/dns": {
	source: "iana"
},
	"application/dns+json": {
	source: "iana",
	compressible: true
},
	"application/dns-message": {
	source: "iana"
},
	"application/docbook+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"dbk"
	]
},
	"application/dots+cbor": {
	source: "iana"
},
	"application/dskpp+xml": {
	source: "iana",
	compressible: true
},
	"application/dssc+der": {
	source: "iana",
	extensions: [
		"dssc"
	]
},
	"application/dssc+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xdssc"
	]
},
	"application/dvcs": {
	source: "iana"
},
	"application/ecmascript": {
	source: "iana",
	compressible: true,
	extensions: [
		"es",
		"ecma"
	]
},
	"application/edi-consent": {
	source: "iana"
},
	"application/edi-x12": {
	source: "iana",
	compressible: false
},
	"application/edifact": {
	source: "iana",
	compressible: false
},
	"application/efi": {
	source: "iana"
},
	"application/elm+json": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/elm+xml": {
	source: "iana",
	compressible: true
},
	"application/emergencycalldata.cap+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/emergencycalldata.comment+xml": {
	source: "iana",
	compressible: true
},
	"application/emergencycalldata.control+xml": {
	source: "iana",
	compressible: true
},
	"application/emergencycalldata.deviceinfo+xml": {
	source: "iana",
	compressible: true
},
	"application/emergencycalldata.ecall.msd": {
	source: "iana"
},
	"application/emergencycalldata.providerinfo+xml": {
	source: "iana",
	compressible: true
},
	"application/emergencycalldata.serviceinfo+xml": {
	source: "iana",
	compressible: true
},
	"application/emergencycalldata.subscriberinfo+xml": {
	source: "iana",
	compressible: true
},
	"application/emergencycalldata.veds+xml": {
	source: "iana",
	compressible: true
},
	"application/emma+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"emma"
	]
},
	"application/emotionml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"emotionml"
	]
},
	"application/encaprtp": {
	source: "iana"
},
	"application/epp+xml": {
	source: "iana",
	compressible: true
},
	"application/epub+zip": {
	source: "iana",
	compressible: false,
	extensions: [
		"epub"
	]
},
	"application/eshop": {
	source: "iana"
},
	"application/exi": {
	source: "iana",
	extensions: [
		"exi"
	]
},
	"application/expect-ct-report+json": {
	source: "iana",
	compressible: true
},
	"application/express": {
	source: "iana",
	extensions: [
		"exp"
	]
},
	"application/fastinfoset": {
	source: "iana"
},
	"application/fastsoap": {
	source: "iana"
},
	"application/fdt+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"fdt"
	]
},
	"application/fhir+json": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/fhir+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/fido.trusted-apps+json": {
	compressible: true
},
	"application/fits": {
	source: "iana"
},
	"application/flexfec": {
	source: "iana"
},
	"application/font-sfnt": {
	source: "iana"
},
	"application/font-tdpfr": {
	source: "iana",
	extensions: [
		"pfr"
	]
},
	"application/font-woff": {
	source: "iana",
	compressible: false
},
	"application/framework-attributes+xml": {
	source: "iana",
	compressible: true
},
	"application/geo+json": {
	source: "iana",
	compressible: true,
	extensions: [
		"geojson"
	]
},
	"application/geo+json-seq": {
	source: "iana"
},
	"application/geopackage+sqlite3": {
	source: "iana"
},
	"application/geoxacml+xml": {
	source: "iana",
	compressible: true
},
	"application/gltf-buffer": {
	source: "iana"
},
	"application/gml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"gml"
	]
},
	"application/gpx+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"gpx"
	]
},
	"application/gxf": {
	source: "apache",
	extensions: [
		"gxf"
	]
},
	"application/gzip": {
	source: "iana",
	compressible: false,
	extensions: [
		"gz"
	]
},
	"application/h224": {
	source: "iana"
},
	"application/held+xml": {
	source: "iana",
	compressible: true
},
	"application/hjson": {
	extensions: [
		"hjson"
	]
},
	"application/http": {
	source: "iana"
},
	"application/hyperstudio": {
	source: "iana",
	extensions: [
		"stk"
	]
},
	"application/ibe-key-request+xml": {
	source: "iana",
	compressible: true
},
	"application/ibe-pkg-reply+xml": {
	source: "iana",
	compressible: true
},
	"application/ibe-pp-data": {
	source: "iana"
},
	"application/iges": {
	source: "iana"
},
	"application/im-iscomposing+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/index": {
	source: "iana"
},
	"application/index.cmd": {
	source: "iana"
},
	"application/index.obj": {
	source: "iana"
},
	"application/index.response": {
	source: "iana"
},
	"application/index.vnd": {
	source: "iana"
},
	"application/inkml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"ink",
		"inkml"
	]
},
	"application/iotp": {
	source: "iana"
},
	"application/ipfix": {
	source: "iana",
	extensions: [
		"ipfix"
	]
},
	"application/ipp": {
	source: "iana"
},
	"application/isup": {
	source: "iana"
},
	"application/its+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"its"
	]
},
	"application/java-archive": {
	source: "apache",
	compressible: false,
	extensions: [
		"jar",
		"war",
		"ear"
	]
},
	"application/java-serialized-object": {
	source: "apache",
	compressible: false,
	extensions: [
		"ser"
	]
},
	"application/java-vm": {
	source: "apache",
	compressible: false,
	extensions: [
		"class"
	]
},
	"application/javascript": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"js",
		"mjs"
	]
},
	"application/jf2feed+json": {
	source: "iana",
	compressible: true
},
	"application/jose": {
	source: "iana"
},
	"application/jose+json": {
	source: "iana",
	compressible: true
},
	"application/jrd+json": {
	source: "iana",
	compressible: true
},
	"application/jscalendar+json": {
	source: "iana",
	compressible: true
},
	"application/json": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"json",
		"map"
	]
},
	"application/json-patch+json": {
	source: "iana",
	compressible: true
},
	"application/json-seq": {
	source: "iana"
},
	"application/json5": {
	extensions: [
		"json5"
	]
},
	"application/jsonml+json": {
	source: "apache",
	compressible: true,
	extensions: [
		"jsonml"
	]
},
	"application/jwk+json": {
	source: "iana",
	compressible: true
},
	"application/jwk-set+json": {
	source: "iana",
	compressible: true
},
	"application/jwt": {
	source: "iana"
},
	"application/kpml-request+xml": {
	source: "iana",
	compressible: true
},
	"application/kpml-response+xml": {
	source: "iana",
	compressible: true
},
	"application/ld+json": {
	source: "iana",
	compressible: true,
	extensions: [
		"jsonld"
	]
},
	"application/lgr+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"lgr"
	]
},
	"application/link-format": {
	source: "iana"
},
	"application/load-control+xml": {
	source: "iana",
	compressible: true
},
	"application/lost+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"lostxml"
	]
},
	"application/lostsync+xml": {
	source: "iana",
	compressible: true
},
	"application/lpf+zip": {
	source: "iana",
	compressible: false
},
	"application/lxf": {
	source: "iana"
},
	"application/mac-binhex40": {
	source: "iana",
	extensions: [
		"hqx"
	]
},
	"application/mac-compactpro": {
	source: "apache",
	extensions: [
		"cpt"
	]
},
	"application/macwriteii": {
	source: "iana"
},
	"application/mads+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mads"
	]
},
	"application/manifest+json": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"webmanifest"
	]
},
	"application/marc": {
	source: "iana",
	extensions: [
		"mrc"
	]
},
	"application/marcxml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mrcx"
	]
},
	"application/mathematica": {
	source: "iana",
	extensions: [
		"ma",
		"nb",
		"mb"
	]
},
	"application/mathml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mathml"
	]
},
	"application/mathml-content+xml": {
	source: "iana",
	compressible: true
},
	"application/mathml-presentation+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-associated-procedure-description+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-deregister+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-envelope+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-msk+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-msk-response+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-protection-description+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-reception-report+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-register+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-register-response+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-schedule+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-user-service-description+xml": {
	source: "iana",
	compressible: true
},
	"application/mbox": {
	source: "iana",
	extensions: [
		"mbox"
	]
},
	"application/media-policy-dataset+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mpf"
	]
},
	"application/media_control+xml": {
	source: "iana",
	compressible: true
},
	"application/mediaservercontrol+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mscml"
	]
},
	"application/merge-patch+json": {
	source: "iana",
	compressible: true
},
	"application/metalink+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"metalink"
	]
},
	"application/metalink4+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"meta4"
	]
},
	"application/mets+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mets"
	]
},
	"application/mf4": {
	source: "iana"
},
	"application/mikey": {
	source: "iana"
},
	"application/mipc": {
	source: "iana"
},
	"application/missing-blocks+cbor-seq": {
	source: "iana"
},
	"application/mmt-aei+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"maei"
	]
},
	"application/mmt-usd+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"musd"
	]
},
	"application/mods+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mods"
	]
},
	"application/moss-keys": {
	source: "iana"
},
	"application/moss-signature": {
	source: "iana"
},
	"application/mosskey-data": {
	source: "iana"
},
	"application/mosskey-request": {
	source: "iana"
},
	"application/mp21": {
	source: "iana",
	extensions: [
		"m21",
		"mp21"
	]
},
	"application/mp4": {
	source: "iana",
	extensions: [
		"mp4s",
		"m4p"
	]
},
	"application/mpeg4-generic": {
	source: "iana"
},
	"application/mpeg4-iod": {
	source: "iana"
},
	"application/mpeg4-iod-xmt": {
	source: "iana"
},
	"application/mrb-consumer+xml": {
	source: "iana",
	compressible: true
},
	"application/mrb-publish+xml": {
	source: "iana",
	compressible: true
},
	"application/msc-ivr+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/msc-mixer+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/msword": {
	source: "iana",
	compressible: false,
	extensions: [
		"doc",
		"dot"
	]
},
	"application/mud+json": {
	source: "iana",
	compressible: true
},
	"application/multipart-core": {
	source: "iana"
},
	"application/mxf": {
	source: "iana",
	extensions: [
		"mxf"
	]
},
	"application/n-quads": {
	source: "iana",
	extensions: [
		"nq"
	]
},
	"application/n-triples": {
	source: "iana",
	extensions: [
		"nt"
	]
},
	"application/nasdata": {
	source: "iana"
},
	"application/news-checkgroups": {
	source: "iana",
	charset: "US-ASCII"
},
	"application/news-groupinfo": {
	source: "iana",
	charset: "US-ASCII"
},
	"application/news-transmission": {
	source: "iana"
},
	"application/nlsml+xml": {
	source: "iana",
	compressible: true
},
	"application/node": {
	source: "iana",
	extensions: [
		"cjs"
	]
},
	"application/nss": {
	source: "iana"
},
	"application/oauth-authz-req+jwt": {
	source: "iana"
},
	"application/oblivious-dns-message": {
	source: "iana"
},
	"application/ocsp-request": {
	source: "iana"
},
	"application/ocsp-response": {
	source: "iana"
},
	"application/octet-stream": {
	source: "iana",
	compressible: false,
	extensions: [
		"bin",
		"dms",
		"lrf",
		"mar",
		"so",
		"dist",
		"distz",
		"pkg",
		"bpk",
		"dump",
		"elc",
		"deploy",
		"exe",
		"dll",
		"deb",
		"dmg",
		"iso",
		"img",
		"msi",
		"msp",
		"msm",
		"buffer"
	]
},
	"application/oda": {
	source: "iana",
	extensions: [
		"oda"
	]
},
	"application/odm+xml": {
	source: "iana",
	compressible: true
},
	"application/odx": {
	source: "iana"
},
	"application/oebps-package+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"opf"
	]
},
	"application/ogg": {
	source: "iana",
	compressible: false,
	extensions: [
		"ogx"
	]
},
	"application/omdoc+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"omdoc"
	]
},
	"application/onenote": {
	source: "apache",
	extensions: [
		"onetoc",
		"onetoc2",
		"onetmp",
		"onepkg"
	]
},
	"application/opc-nodeset+xml": {
	source: "iana",
	compressible: true
},
	"application/oscore": {
	source: "iana"
},
	"application/oxps": {
	source: "iana",
	extensions: [
		"oxps"
	]
},
	"application/p21": {
	source: "iana"
},
	"application/p21+zip": {
	source: "iana",
	compressible: false
},
	"application/p2p-overlay+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"relo"
	]
},
	"application/parityfec": {
	source: "iana"
},
	"application/passport": {
	source: "iana"
},
	"application/patch-ops-error+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xer"
	]
},
	"application/pdf": {
	source: "iana",
	compressible: false,
	extensions: [
		"pdf"
	]
},
	"application/pdx": {
	source: "iana"
},
	"application/pem-certificate-chain": {
	source: "iana"
},
	"application/pgp-encrypted": {
	source: "iana",
	compressible: false,
	extensions: [
		"pgp"
	]
},
	"application/pgp-keys": {
	source: "iana",
	extensions: [
		"asc"
	]
},
	"application/pgp-signature": {
	source: "iana",
	extensions: [
		"asc",
		"sig"
	]
},
	"application/pics-rules": {
	source: "apache",
	extensions: [
		"prf"
	]
},
	"application/pidf+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/pidf-diff+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/pkcs10": {
	source: "iana",
	extensions: [
		"p10"
	]
},
	"application/pkcs12": {
	source: "iana"
},
	"application/pkcs7-mime": {
	source: "iana",
	extensions: [
		"p7m",
		"p7c"
	]
},
	"application/pkcs7-signature": {
	source: "iana",
	extensions: [
		"p7s"
	]
},
	"application/pkcs8": {
	source: "iana",
	extensions: [
		"p8"
	]
},
	"application/pkcs8-encrypted": {
	source: "iana"
},
	"application/pkix-attr-cert": {
	source: "iana",
	extensions: [
		"ac"
	]
},
	"application/pkix-cert": {
	source: "iana",
	extensions: [
		"cer"
	]
},
	"application/pkix-crl": {
	source: "iana",
	extensions: [
		"crl"
	]
},
	"application/pkix-pkipath": {
	source: "iana",
	extensions: [
		"pkipath"
	]
},
	"application/pkixcmp": {
	source: "iana",
	extensions: [
		"pki"
	]
},
	"application/pls+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"pls"
	]
},
	"application/poc-settings+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/postscript": {
	source: "iana",
	compressible: true,
	extensions: [
		"ai",
		"eps",
		"ps"
	]
},
	"application/ppsp-tracker+json": {
	source: "iana",
	compressible: true
},
	"application/problem+json": {
	source: "iana",
	compressible: true
},
	"application/problem+xml": {
	source: "iana",
	compressible: true
},
	"application/provenance+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"provx"
	]
},
	"application/prs.alvestrand.titrax-sheet": {
	source: "iana"
},
	"application/prs.cww": {
	source: "iana",
	extensions: [
		"cww"
	]
},
	"application/prs.cyn": {
	source: "iana",
	charset: "7-BIT"
},
	"application/prs.hpub+zip": {
	source: "iana",
	compressible: false
},
	"application/prs.nprend": {
	source: "iana"
},
	"application/prs.plucker": {
	source: "iana"
},
	"application/prs.rdf-xml-crypt": {
	source: "iana"
},
	"application/prs.xsf+xml": {
	source: "iana",
	compressible: true
},
	"application/pskc+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"pskcxml"
	]
},
	"application/pvd+json": {
	source: "iana",
	compressible: true
},
	"application/qsig": {
	source: "iana"
},
	"application/raml+yaml": {
	compressible: true,
	extensions: [
		"raml"
	]
},
	"application/raptorfec": {
	source: "iana"
},
	"application/rdap+json": {
	source: "iana",
	compressible: true
},
	"application/rdf+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rdf",
		"owl"
	]
},
	"application/reginfo+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rif"
	]
},
	"application/relax-ng-compact-syntax": {
	source: "iana",
	extensions: [
		"rnc"
	]
},
	"application/remote-printing": {
	source: "iana"
},
	"application/reputon+json": {
	source: "iana",
	compressible: true
},
	"application/resource-lists+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rl"
	]
},
	"application/resource-lists-diff+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rld"
	]
},
	"application/rfc+xml": {
	source: "iana",
	compressible: true
},
	"application/riscos": {
	source: "iana"
},
	"application/rlmi+xml": {
	source: "iana",
	compressible: true
},
	"application/rls-services+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rs"
	]
},
	"application/route-apd+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rapd"
	]
},
	"application/route-s-tsid+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"sls"
	]
},
	"application/route-usd+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rusd"
	]
},
	"application/rpki-ghostbusters": {
	source: "iana",
	extensions: [
		"gbr"
	]
},
	"application/rpki-manifest": {
	source: "iana",
	extensions: [
		"mft"
	]
},
	"application/rpki-publication": {
	source: "iana"
},
	"application/rpki-roa": {
	source: "iana",
	extensions: [
		"roa"
	]
},
	"application/rpki-updown": {
	source: "iana"
},
	"application/rsd+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"rsd"
	]
},
	"application/rss+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"rss"
	]
},
	"application/rtf": {
	source: "iana",
	compressible: true,
	extensions: [
		"rtf"
	]
},
	"application/rtploopback": {
	source: "iana"
},
	"application/rtx": {
	source: "iana"
},
	"application/samlassertion+xml": {
	source: "iana",
	compressible: true
},
	"application/samlmetadata+xml": {
	source: "iana",
	compressible: true
},
	"application/sarif+json": {
	source: "iana",
	compressible: true
},
	"application/sarif-external-properties+json": {
	source: "iana",
	compressible: true
},
	"application/sbe": {
	source: "iana"
},
	"application/sbml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"sbml"
	]
},
	"application/scaip+xml": {
	source: "iana",
	compressible: true
},
	"application/scim+json": {
	source: "iana",
	compressible: true
},
	"application/scvp-cv-request": {
	source: "iana",
	extensions: [
		"scq"
	]
},
	"application/scvp-cv-response": {
	source: "iana",
	extensions: [
		"scs"
	]
},
	"application/scvp-vp-request": {
	source: "iana",
	extensions: [
		"spq"
	]
},
	"application/scvp-vp-response": {
	source: "iana",
	extensions: [
		"spp"
	]
},
	"application/sdp": {
	source: "iana",
	extensions: [
		"sdp"
	]
},
	"application/secevent+jwt": {
	source: "iana"
},
	"application/senml+cbor": {
	source: "iana"
},
	"application/senml+json": {
	source: "iana",
	compressible: true
},
	"application/senml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"senmlx"
	]
},
	"application/senml-etch+cbor": {
	source: "iana"
},
	"application/senml-etch+json": {
	source: "iana",
	compressible: true
},
	"application/senml-exi": {
	source: "iana"
},
	"application/sensml+cbor": {
	source: "iana"
},
	"application/sensml+json": {
	source: "iana",
	compressible: true
},
	"application/sensml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"sensmlx"
	]
},
	"application/sensml-exi": {
	source: "iana"
},
	"application/sep+xml": {
	source: "iana",
	compressible: true
},
	"application/sep-exi": {
	source: "iana"
},
	"application/session-info": {
	source: "iana"
},
	"application/set-payment": {
	source: "iana"
},
	"application/set-payment-initiation": {
	source: "iana",
	extensions: [
		"setpay"
	]
},
	"application/set-registration": {
	source: "iana"
},
	"application/set-registration-initiation": {
	source: "iana",
	extensions: [
		"setreg"
	]
},
	"application/sgml": {
	source: "iana"
},
	"application/sgml-open-catalog": {
	source: "iana"
},
	"application/shf+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"shf"
	]
},
	"application/sieve": {
	source: "iana",
	extensions: [
		"siv",
		"sieve"
	]
},
	"application/simple-filter+xml": {
	source: "iana",
	compressible: true
},
	"application/simple-message-summary": {
	source: "iana"
},
	"application/simplesymbolcontainer": {
	source: "iana"
},
	"application/sipc": {
	source: "iana"
},
	"application/slate": {
	source: "iana"
},
	"application/smil": {
	source: "iana"
},
	"application/smil+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"smi",
		"smil"
	]
},
	"application/smpte336m": {
	source: "iana"
},
	"application/soap+fastinfoset": {
	source: "iana"
},
	"application/soap+xml": {
	source: "iana",
	compressible: true
},
	"application/sparql-query": {
	source: "iana",
	extensions: [
		"rq"
	]
},
	"application/sparql-results+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"srx"
	]
},
	"application/spdx+json": {
	source: "iana",
	compressible: true
},
	"application/spirits-event+xml": {
	source: "iana",
	compressible: true
},
	"application/sql": {
	source: "iana"
},
	"application/srgs": {
	source: "iana",
	extensions: [
		"gram"
	]
},
	"application/srgs+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"grxml"
	]
},
	"application/sru+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"sru"
	]
},
	"application/ssdl+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"ssdl"
	]
},
	"application/ssml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"ssml"
	]
},
	"application/stix+json": {
	source: "iana",
	compressible: true
},
	"application/swid+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"swidtag"
	]
},
	"application/tamp-apex-update": {
	source: "iana"
},
	"application/tamp-apex-update-confirm": {
	source: "iana"
},
	"application/tamp-community-update": {
	source: "iana"
},
	"application/tamp-community-update-confirm": {
	source: "iana"
},
	"application/tamp-error": {
	source: "iana"
},
	"application/tamp-sequence-adjust": {
	source: "iana"
},
	"application/tamp-sequence-adjust-confirm": {
	source: "iana"
},
	"application/tamp-status-query": {
	source: "iana"
},
	"application/tamp-status-response": {
	source: "iana"
},
	"application/tamp-update": {
	source: "iana"
},
	"application/tamp-update-confirm": {
	source: "iana"
},
	"application/tar": {
	compressible: true
},
	"application/taxii+json": {
	source: "iana",
	compressible: true
},
	"application/td+json": {
	source: "iana",
	compressible: true
},
	"application/tei+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"tei",
		"teicorpus"
	]
},
	"application/tetra_isi": {
	source: "iana"
},
	"application/thraud+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"tfi"
	]
},
	"application/timestamp-query": {
	source: "iana"
},
	"application/timestamp-reply": {
	source: "iana"
},
	"application/timestamped-data": {
	source: "iana",
	extensions: [
		"tsd"
	]
},
	"application/tlsrpt+gzip": {
	source: "iana"
},
	"application/tlsrpt+json": {
	source: "iana",
	compressible: true
},
	"application/tnauthlist": {
	source: "iana"
},
	"application/token-introspection+jwt": {
	source: "iana"
},
	"application/toml": {
	compressible: true,
	extensions: [
		"toml"
	]
},
	"application/trickle-ice-sdpfrag": {
	source: "iana"
},
	"application/trig": {
	source: "iana",
	extensions: [
		"trig"
	]
},
	"application/ttml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"ttml"
	]
},
	"application/tve-trigger": {
	source: "iana"
},
	"application/tzif": {
	source: "iana"
},
	"application/tzif-leap": {
	source: "iana"
},
	"application/ubjson": {
	compressible: false,
	extensions: [
		"ubj"
	]
},
	"application/ulpfec": {
	source: "iana"
},
	"application/urc-grpsheet+xml": {
	source: "iana",
	compressible: true
},
	"application/urc-ressheet+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rsheet"
	]
},
	"application/urc-targetdesc+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"td"
	]
},
	"application/urc-uisocketdesc+xml": {
	source: "iana",
	compressible: true
},
	"application/vcard+json": {
	source: "iana",
	compressible: true
},
	"application/vcard+xml": {
	source: "iana",
	compressible: true
},
	"application/vemmi": {
	source: "iana"
},
	"application/vividence.scriptfile": {
	source: "apache"
},
	"application/vnd.1000minds.decision-model+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"1km"
	]
},
	"application/vnd.3gpp-prose+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp-prose-pc3ch+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp-v2x-local-service-information": {
	source: "iana"
},
	"application/vnd.3gpp.5gnas": {
	source: "iana"
},
	"application/vnd.3gpp.access-transfer-events+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.bsf+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.gmop+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.gtpc": {
	source: "iana"
},
	"application/vnd.3gpp.interworking-data": {
	source: "iana"
},
	"application/vnd.3gpp.lpp": {
	source: "iana"
},
	"application/vnd.3gpp.mc-signalling-ear": {
	source: "iana"
},
	"application/vnd.3gpp.mcdata-affiliation-command+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcdata-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcdata-payload": {
	source: "iana"
},
	"application/vnd.3gpp.mcdata-service-config+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcdata-signalling": {
	source: "iana"
},
	"application/vnd.3gpp.mcdata-ue-config+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcdata-user-profile+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-affiliation-command+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-floor-request+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-location-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-service-config+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-signed+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-ue-config+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-ue-init-config+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-user-profile+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-affiliation-command+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-affiliation-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-location-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-service-config+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-transmission-request+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-ue-config+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-user-profile+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mid-call+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.ngap": {
	source: "iana"
},
	"application/vnd.3gpp.pfcp": {
	source: "iana"
},
	"application/vnd.3gpp.pic-bw-large": {
	source: "iana",
	extensions: [
		"plb"
	]
},
	"application/vnd.3gpp.pic-bw-small": {
	source: "iana",
	extensions: [
		"psb"
	]
},
	"application/vnd.3gpp.pic-bw-var": {
	source: "iana",
	extensions: [
		"pvb"
	]
},
	"application/vnd.3gpp.s1ap": {
	source: "iana"
},
	"application/vnd.3gpp.sms": {
	source: "iana"
},
	"application/vnd.3gpp.sms+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.srvcc-ext+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.srvcc-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.state-and-event-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.ussd+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp2.bcmcsinfo+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp2.sms": {
	source: "iana"
},
	"application/vnd.3gpp2.tcap": {
	source: "iana",
	extensions: [
		"tcap"
	]
},
	"application/vnd.3lightssoftware.imagescal": {
	source: "iana"
},
	"application/vnd.3m.post-it-notes": {
	source: "iana",
	extensions: [
		"pwn"
	]
},
	"application/vnd.accpac.simply.aso": {
	source: "iana",
	extensions: [
		"aso"
	]
},
	"application/vnd.accpac.simply.imp": {
	source: "iana",
	extensions: [
		"imp"
	]
},
	"application/vnd.acucobol": {
	source: "iana",
	extensions: [
		"acu"
	]
},
	"application/vnd.acucorp": {
	source: "iana",
	extensions: [
		"atc",
		"acutc"
	]
},
	"application/vnd.adobe.air-application-installer-package+zip": {
	source: "apache",
	compressible: false,
	extensions: [
		"air"
	]
},
	"application/vnd.adobe.flash.movie": {
	source: "iana"
},
	"application/vnd.adobe.formscentral.fcdt": {
	source: "iana",
	extensions: [
		"fcdt"
	]
},
	"application/vnd.adobe.fxp": {
	source: "iana",
	extensions: [
		"fxp",
		"fxpl"
	]
},
	"application/vnd.adobe.partial-upload": {
	source: "iana"
},
	"application/vnd.adobe.xdp+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xdp"
	]
},
	"application/vnd.adobe.xfdf": {
	source: "iana",
	extensions: [
		"xfdf"
	]
},
	"application/vnd.aether.imp": {
	source: "iana"
},
	"application/vnd.afpc.afplinedata": {
	source: "iana"
},
	"application/vnd.afpc.afplinedata-pagedef": {
	source: "iana"
},
	"application/vnd.afpc.cmoca-cmresource": {
	source: "iana"
},
	"application/vnd.afpc.foca-charset": {
	source: "iana"
},
	"application/vnd.afpc.foca-codedfont": {
	source: "iana"
},
	"application/vnd.afpc.foca-codepage": {
	source: "iana"
},
	"application/vnd.afpc.modca": {
	source: "iana"
},
	"application/vnd.afpc.modca-cmtable": {
	source: "iana"
},
	"application/vnd.afpc.modca-formdef": {
	source: "iana"
},
	"application/vnd.afpc.modca-mediummap": {
	source: "iana"
},
	"application/vnd.afpc.modca-objectcontainer": {
	source: "iana"
},
	"application/vnd.afpc.modca-overlay": {
	source: "iana"
},
	"application/vnd.afpc.modca-pagesegment": {
	source: "iana"
},
	"application/vnd.age": {
	source: "iana",
	extensions: [
		"age"
	]
},
	"application/vnd.ah-barcode": {
	source: "iana"
},
	"application/vnd.ahead.space": {
	source: "iana",
	extensions: [
		"ahead"
	]
},
	"application/vnd.airzip.filesecure.azf": {
	source: "iana",
	extensions: [
		"azf"
	]
},
	"application/vnd.airzip.filesecure.azs": {
	source: "iana",
	extensions: [
		"azs"
	]
},
	"application/vnd.amadeus+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.amazon.ebook": {
	source: "apache",
	extensions: [
		"azw"
	]
},
	"application/vnd.amazon.mobi8-ebook": {
	source: "iana"
},
	"application/vnd.americandynamics.acc": {
	source: "iana",
	extensions: [
		"acc"
	]
},
	"application/vnd.amiga.ami": {
	source: "iana",
	extensions: [
		"ami"
	]
},
	"application/vnd.amundsen.maze+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.android.ota": {
	source: "iana"
},
	"application/vnd.android.package-archive": {
	source: "apache",
	compressible: false,
	extensions: [
		"apk"
	]
},
	"application/vnd.anki": {
	source: "iana"
},
	"application/vnd.anser-web-certificate-issue-initiation": {
	source: "iana",
	extensions: [
		"cii"
	]
},
	"application/vnd.anser-web-funds-transfer-initiation": {
	source: "apache",
	extensions: [
		"fti"
	]
},
	"application/vnd.antix.game-component": {
	source: "iana",
	extensions: [
		"atx"
	]
},
	"application/vnd.apache.arrow.file": {
	source: "iana"
},
	"application/vnd.apache.arrow.stream": {
	source: "iana"
},
	"application/vnd.apache.thrift.binary": {
	source: "iana"
},
	"application/vnd.apache.thrift.compact": {
	source: "iana"
},
	"application/vnd.apache.thrift.json": {
	source: "iana"
},
	"application/vnd.api+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.aplextor.warrp+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.apothekende.reservation+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.apple.installer+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mpkg"
	]
},
	"application/vnd.apple.keynote": {
	source: "iana",
	extensions: [
		"key"
	]
},
	"application/vnd.apple.mpegurl": {
	source: "iana",
	extensions: [
		"m3u8"
	]
},
	"application/vnd.apple.numbers": {
	source: "iana",
	extensions: [
		"numbers"
	]
},
	"application/vnd.apple.pages": {
	source: "iana",
	extensions: [
		"pages"
	]
},
	"application/vnd.apple.pkpass": {
	compressible: false,
	extensions: [
		"pkpass"
	]
},
	"application/vnd.arastra.swi": {
	source: "iana"
},
	"application/vnd.aristanetworks.swi": {
	source: "iana",
	extensions: [
		"swi"
	]
},
	"application/vnd.artisan+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.artsquare": {
	source: "iana"
},
	"application/vnd.astraea-software.iota": {
	source: "iana",
	extensions: [
		"iota"
	]
},
	"application/vnd.audiograph": {
	source: "iana",
	extensions: [
		"aep"
	]
},
	"application/vnd.autopackage": {
	source: "iana"
},
	"application/vnd.avalon+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.avistar+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.balsamiq.bmml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"bmml"
	]
},
	"application/vnd.balsamiq.bmpr": {
	source: "iana"
},
	"application/vnd.banana-accounting": {
	source: "iana"
},
	"application/vnd.bbf.usp.error": {
	source: "iana"
},
	"application/vnd.bbf.usp.msg": {
	source: "iana"
},
	"application/vnd.bbf.usp.msg+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.bekitzur-stech+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.bint.med-content": {
	source: "iana"
},
	"application/vnd.biopax.rdf+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.blink-idb-value-wrapper": {
	source: "iana"
},
	"application/vnd.blueice.multipass": {
	source: "iana",
	extensions: [
		"mpm"
	]
},
	"application/vnd.bluetooth.ep.oob": {
	source: "iana"
},
	"application/vnd.bluetooth.le.oob": {
	source: "iana"
},
	"application/vnd.bmi": {
	source: "iana",
	extensions: [
		"bmi"
	]
},
	"application/vnd.bpf": {
	source: "iana"
},
	"application/vnd.bpf3": {
	source: "iana"
},
	"application/vnd.businessobjects": {
	source: "iana",
	extensions: [
		"rep"
	]
},
	"application/vnd.byu.uapi+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.cab-jscript": {
	source: "iana"
},
	"application/vnd.canon-cpdl": {
	source: "iana"
},
	"application/vnd.canon-lips": {
	source: "iana"
},
	"application/vnd.capasystems-pg+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.cendio.thinlinc.clientconf": {
	source: "iana"
},
	"application/vnd.century-systems.tcp_stream": {
	source: "iana"
},
	"application/vnd.chemdraw+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"cdxml"
	]
},
	"application/vnd.chess-pgn": {
	source: "iana"
},
	"application/vnd.chipnuts.karaoke-mmd": {
	source: "iana",
	extensions: [
		"mmd"
	]
},
	"application/vnd.ciedi": {
	source: "iana"
},
	"application/vnd.cinderella": {
	source: "iana",
	extensions: [
		"cdy"
	]
},
	"application/vnd.cirpack.isdn-ext": {
	source: "iana"
},
	"application/vnd.citationstyles.style+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"csl"
	]
},
	"application/vnd.claymore": {
	source: "iana",
	extensions: [
		"cla"
	]
},
	"application/vnd.cloanto.rp9": {
	source: "iana",
	extensions: [
		"rp9"
	]
},
	"application/vnd.clonk.c4group": {
	source: "iana",
	extensions: [
		"c4g",
		"c4d",
		"c4f",
		"c4p",
		"c4u"
	]
},
	"application/vnd.cluetrust.cartomobile-config": {
	source: "iana",
	extensions: [
		"c11amc"
	]
},
	"application/vnd.cluetrust.cartomobile-config-pkg": {
	source: "iana",
	extensions: [
		"c11amz"
	]
},
	"application/vnd.coffeescript": {
	source: "iana"
},
	"application/vnd.collabio.xodocuments.document": {
	source: "iana"
},
	"application/vnd.collabio.xodocuments.document-template": {
	source: "iana"
},
	"application/vnd.collabio.xodocuments.presentation": {
	source: "iana"
},
	"application/vnd.collabio.xodocuments.presentation-template": {
	source: "iana"
},
	"application/vnd.collabio.xodocuments.spreadsheet": {
	source: "iana"
},
	"application/vnd.collabio.xodocuments.spreadsheet-template": {
	source: "iana"
},
	"application/vnd.collection+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.collection.doc+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.collection.next+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.comicbook+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.comicbook-rar": {
	source: "iana"
},
	"application/vnd.commerce-battelle": {
	source: "iana"
},
	"application/vnd.commonspace": {
	source: "iana",
	extensions: [
		"csp"
	]
},
	"application/vnd.contact.cmsg": {
	source: "iana",
	extensions: [
		"cdbcmsg"
	]
},
	"application/vnd.coreos.ignition+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.cosmocaller": {
	source: "iana",
	extensions: [
		"cmc"
	]
},
	"application/vnd.crick.clicker": {
	source: "iana",
	extensions: [
		"clkx"
	]
},
	"application/vnd.crick.clicker.keyboard": {
	source: "iana",
	extensions: [
		"clkk"
	]
},
	"application/vnd.crick.clicker.palette": {
	source: "iana",
	extensions: [
		"clkp"
	]
},
	"application/vnd.crick.clicker.template": {
	source: "iana",
	extensions: [
		"clkt"
	]
},
	"application/vnd.crick.clicker.wordbank": {
	source: "iana",
	extensions: [
		"clkw"
	]
},
	"application/vnd.criticaltools.wbs+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"wbs"
	]
},
	"application/vnd.cryptii.pipe+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.crypto-shade-file": {
	source: "iana"
},
	"application/vnd.cryptomator.encrypted": {
	source: "iana"
},
	"application/vnd.cryptomator.vault": {
	source: "iana"
},
	"application/vnd.ctc-posml": {
	source: "iana",
	extensions: [
		"pml"
	]
},
	"application/vnd.ctct.ws+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.cups-pdf": {
	source: "iana"
},
	"application/vnd.cups-postscript": {
	source: "iana"
},
	"application/vnd.cups-ppd": {
	source: "iana",
	extensions: [
		"ppd"
	]
},
	"application/vnd.cups-raster": {
	source: "iana"
},
	"application/vnd.cups-raw": {
	source: "iana"
},
	"application/vnd.curl": {
	source: "iana"
},
	"application/vnd.curl.car": {
	source: "apache",
	extensions: [
		"car"
	]
},
	"application/vnd.curl.pcurl": {
	source: "apache",
	extensions: [
		"pcurl"
	]
},
	"application/vnd.cyan.dean.root+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.cybank": {
	source: "iana"
},
	"application/vnd.cyclonedx+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.cyclonedx+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.d2l.coursepackage1p0+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.d3m-dataset": {
	source: "iana"
},
	"application/vnd.d3m-problem": {
	source: "iana"
},
	"application/vnd.dart": {
	source: "iana",
	compressible: true,
	extensions: [
		"dart"
	]
},
	"application/vnd.data-vision.rdz": {
	source: "iana",
	extensions: [
		"rdz"
	]
},
	"application/vnd.datapackage+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.dataresource+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.dbf": {
	source: "iana",
	extensions: [
		"dbf"
	]
},
	"application/vnd.debian.binary-package": {
	source: "iana"
},
	"application/vnd.dece.data": {
	source: "iana",
	extensions: [
		"uvf",
		"uvvf",
		"uvd",
		"uvvd"
	]
},
	"application/vnd.dece.ttml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"uvt",
		"uvvt"
	]
},
	"application/vnd.dece.unspecified": {
	source: "iana",
	extensions: [
		"uvx",
		"uvvx"
	]
},
	"application/vnd.dece.zip": {
	source: "iana",
	extensions: [
		"uvz",
		"uvvz"
	]
},
	"application/vnd.denovo.fcselayout-link": {
	source: "iana",
	extensions: [
		"fe_launch"
	]
},
	"application/vnd.desmume.movie": {
	source: "iana"
},
	"application/vnd.dir-bi.plate-dl-nosuffix": {
	source: "iana"
},
	"application/vnd.dm.delegation+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dna": {
	source: "iana",
	extensions: [
		"dna"
	]
},
	"application/vnd.document+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.dolby.mlp": {
	source: "apache",
	extensions: [
		"mlp"
	]
},
	"application/vnd.dolby.mobile.1": {
	source: "iana"
},
	"application/vnd.dolby.mobile.2": {
	source: "iana"
},
	"application/vnd.doremir.scorecloud-binary-document": {
	source: "iana"
},
	"application/vnd.dpgraph": {
	source: "iana",
	extensions: [
		"dpg"
	]
},
	"application/vnd.dreamfactory": {
	source: "iana",
	extensions: [
		"dfac"
	]
},
	"application/vnd.drive+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.ds-keypoint": {
	source: "apache",
	extensions: [
		"kpxx"
	]
},
	"application/vnd.dtg.local": {
	source: "iana"
},
	"application/vnd.dtg.local.flash": {
	source: "iana"
},
	"application/vnd.dtg.local.html": {
	source: "iana"
},
	"application/vnd.dvb.ait": {
	source: "iana",
	extensions: [
		"ait"
	]
},
	"application/vnd.dvb.dvbisl+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dvb.dvbj": {
	source: "iana"
},
	"application/vnd.dvb.esgcontainer": {
	source: "iana"
},
	"application/vnd.dvb.ipdcdftnotifaccess": {
	source: "iana"
},
	"application/vnd.dvb.ipdcesgaccess": {
	source: "iana"
},
	"application/vnd.dvb.ipdcesgaccess2": {
	source: "iana"
},
	"application/vnd.dvb.ipdcesgpdd": {
	source: "iana"
},
	"application/vnd.dvb.ipdcroaming": {
	source: "iana"
},
	"application/vnd.dvb.iptv.alfec-base": {
	source: "iana"
},
	"application/vnd.dvb.iptv.alfec-enhancement": {
	source: "iana"
},
	"application/vnd.dvb.notif-aggregate-root+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dvb.notif-container+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dvb.notif-generic+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dvb.notif-ia-msglist+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dvb.notif-ia-registration-request+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dvb.notif-ia-registration-response+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dvb.notif-init+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dvb.pfr": {
	source: "iana"
},
	"application/vnd.dvb.service": {
	source: "iana",
	extensions: [
		"svc"
	]
},
	"application/vnd.dxr": {
	source: "iana"
},
	"application/vnd.dynageo": {
	source: "iana",
	extensions: [
		"geo"
	]
},
	"application/vnd.dzr": {
	source: "iana"
},
	"application/vnd.easykaraoke.cdgdownload": {
	source: "iana"
},
	"application/vnd.ecdis-update": {
	source: "iana"
},
	"application/vnd.ecip.rlp": {
	source: "iana"
},
	"application/vnd.eclipse.ditto+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.ecowin.chart": {
	source: "iana",
	extensions: [
		"mag"
	]
},
	"application/vnd.ecowin.filerequest": {
	source: "iana"
},
	"application/vnd.ecowin.fileupdate": {
	source: "iana"
},
	"application/vnd.ecowin.series": {
	source: "iana"
},
	"application/vnd.ecowin.seriesrequest": {
	source: "iana"
},
	"application/vnd.ecowin.seriesupdate": {
	source: "iana"
},
	"application/vnd.efi.img": {
	source: "iana"
},
	"application/vnd.efi.iso": {
	source: "iana"
},
	"application/vnd.emclient.accessrequest+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.enliven": {
	source: "iana",
	extensions: [
		"nml"
	]
},
	"application/vnd.enphase.envoy": {
	source: "iana"
},
	"application/vnd.eprints.data+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.epson.esf": {
	source: "iana",
	extensions: [
		"esf"
	]
},
	"application/vnd.epson.msf": {
	source: "iana",
	extensions: [
		"msf"
	]
},
	"application/vnd.epson.quickanime": {
	source: "iana",
	extensions: [
		"qam"
	]
},
	"application/vnd.epson.salt": {
	source: "iana",
	extensions: [
		"slt"
	]
},
	"application/vnd.epson.ssf": {
	source: "iana",
	extensions: [
		"ssf"
	]
},
	"application/vnd.ericsson.quickcall": {
	source: "iana"
},
	"application/vnd.espass-espass+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.eszigno3+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"es3",
		"et3"
	]
},
	"application/vnd.etsi.aoc+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.asic-e+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.etsi.asic-s+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.etsi.cug+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvcommand+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvdiscovery+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvprofile+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvsad-bc+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvsad-cod+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvsad-npvr+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvservice+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvsync+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvueprofile+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.mcid+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.mheg5": {
	source: "iana"
},
	"application/vnd.etsi.overload-control-policy-dataset+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.pstn+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.sci+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.simservs+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.timestamp-token": {
	source: "iana"
},
	"application/vnd.etsi.tsl+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.tsl.der": {
	source: "iana"
},
	"application/vnd.eu.kasparian.car+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.eudora.data": {
	source: "iana"
},
	"application/vnd.evolv.ecig.profile": {
	source: "iana"
},
	"application/vnd.evolv.ecig.settings": {
	source: "iana"
},
	"application/vnd.evolv.ecig.theme": {
	source: "iana"
},
	"application/vnd.exstream-empower+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.exstream-package": {
	source: "iana"
},
	"application/vnd.ezpix-album": {
	source: "iana",
	extensions: [
		"ez2"
	]
},
	"application/vnd.ezpix-package": {
	source: "iana",
	extensions: [
		"ez3"
	]
},
	"application/vnd.f-secure.mobile": {
	source: "iana"
},
	"application/vnd.familysearch.gedcom+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.fastcopy-disk-image": {
	source: "iana"
},
	"application/vnd.fdf": {
	source: "iana",
	extensions: [
		"fdf"
	]
},
	"application/vnd.fdsn.mseed": {
	source: "iana",
	extensions: [
		"mseed"
	]
},
	"application/vnd.fdsn.seed": {
	source: "iana",
	extensions: [
		"seed",
		"dataless"
	]
},
	"application/vnd.ffsns": {
	source: "iana"
},
	"application/vnd.ficlab.flb+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.filmit.zfc": {
	source: "iana"
},
	"application/vnd.fints": {
	source: "iana"
},
	"application/vnd.firemonkeys.cloudcell": {
	source: "iana"
},
	"application/vnd.flographit": {
	source: "iana",
	extensions: [
		"gph"
	]
},
	"application/vnd.fluxtime.clip": {
	source: "iana",
	extensions: [
		"ftc"
	]
},
	"application/vnd.font-fontforge-sfd": {
	source: "iana"
},
	"application/vnd.framemaker": {
	source: "iana",
	extensions: [
		"fm",
		"frame",
		"maker",
		"book"
	]
},
	"application/vnd.frogans.fnc": {
	source: "iana",
	extensions: [
		"fnc"
	]
},
	"application/vnd.frogans.ltf": {
	source: "iana",
	extensions: [
		"ltf"
	]
},
	"application/vnd.fsc.weblaunch": {
	source: "iana",
	extensions: [
		"fsc"
	]
},
	"application/vnd.fujifilm.fb.docuworks": {
	source: "iana"
},
	"application/vnd.fujifilm.fb.docuworks.binder": {
	source: "iana"
},
	"application/vnd.fujifilm.fb.docuworks.container": {
	source: "iana"
},
	"application/vnd.fujifilm.fb.jfi+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.fujitsu.oasys": {
	source: "iana",
	extensions: [
		"oas"
	]
},
	"application/vnd.fujitsu.oasys2": {
	source: "iana",
	extensions: [
		"oa2"
	]
},
	"application/vnd.fujitsu.oasys3": {
	source: "iana",
	extensions: [
		"oa3"
	]
},
	"application/vnd.fujitsu.oasysgp": {
	source: "iana",
	extensions: [
		"fg5"
	]
},
	"application/vnd.fujitsu.oasysprs": {
	source: "iana",
	extensions: [
		"bh2"
	]
},
	"application/vnd.fujixerox.art-ex": {
	source: "iana"
},
	"application/vnd.fujixerox.art4": {
	source: "iana"
},
	"application/vnd.fujixerox.ddd": {
	source: "iana",
	extensions: [
		"ddd"
	]
},
	"application/vnd.fujixerox.docuworks": {
	source: "iana",
	extensions: [
		"xdw"
	]
},
	"application/vnd.fujixerox.docuworks.binder": {
	source: "iana",
	extensions: [
		"xbd"
	]
},
	"application/vnd.fujixerox.docuworks.container": {
	source: "iana"
},
	"application/vnd.fujixerox.hbpl": {
	source: "iana"
},
	"application/vnd.fut-misnet": {
	source: "iana"
},
	"application/vnd.futoin+cbor": {
	source: "iana"
},
	"application/vnd.futoin+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.fuzzysheet": {
	source: "iana",
	extensions: [
		"fzs"
	]
},
	"application/vnd.genomatix.tuxedo": {
	source: "iana",
	extensions: [
		"txd"
	]
},
	"application/vnd.gentics.grd+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.geo+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.geocube+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.geogebra.file": {
	source: "iana",
	extensions: [
		"ggb"
	]
},
	"application/vnd.geogebra.slides": {
	source: "iana"
},
	"application/vnd.geogebra.tool": {
	source: "iana",
	extensions: [
		"ggt"
	]
},
	"application/vnd.geometry-explorer": {
	source: "iana",
	extensions: [
		"gex",
		"gre"
	]
},
	"application/vnd.geonext": {
	source: "iana",
	extensions: [
		"gxt"
	]
},
	"application/vnd.geoplan": {
	source: "iana",
	extensions: [
		"g2w"
	]
},
	"application/vnd.geospace": {
	source: "iana",
	extensions: [
		"g3w"
	]
},
	"application/vnd.gerber": {
	source: "iana"
},
	"application/vnd.globalplatform.card-content-mgt": {
	source: "iana"
},
	"application/vnd.globalplatform.card-content-mgt-response": {
	source: "iana"
},
	"application/vnd.gmx": {
	source: "iana",
	extensions: [
		"gmx"
	]
},
	"application/vnd.google-apps.document": {
	compressible: false,
	extensions: [
		"gdoc"
	]
},
	"application/vnd.google-apps.presentation": {
	compressible: false,
	extensions: [
		"gslides"
	]
},
	"application/vnd.google-apps.spreadsheet": {
	compressible: false,
	extensions: [
		"gsheet"
	]
},
	"application/vnd.google-earth.kml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"kml"
	]
},
	"application/vnd.google-earth.kmz": {
	source: "iana",
	compressible: false,
	extensions: [
		"kmz"
	]
},
	"application/vnd.gov.sk.e-form+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.gov.sk.e-form+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.gov.sk.xmldatacontainer+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.grafeq": {
	source: "iana",
	extensions: [
		"gqf",
		"gqs"
	]
},
	"application/vnd.gridmp": {
	source: "iana"
},
	"application/vnd.groove-account": {
	source: "iana",
	extensions: [
		"gac"
	]
},
	"application/vnd.groove-help": {
	source: "iana",
	extensions: [
		"ghf"
	]
},
	"application/vnd.groove-identity-message": {
	source: "iana",
	extensions: [
		"gim"
	]
},
	"application/vnd.groove-injector": {
	source: "iana",
	extensions: [
		"grv"
	]
},
	"application/vnd.groove-tool-message": {
	source: "iana",
	extensions: [
		"gtm"
	]
},
	"application/vnd.groove-tool-template": {
	source: "iana",
	extensions: [
		"tpl"
	]
},
	"application/vnd.groove-vcard": {
	source: "iana",
	extensions: [
		"vcg"
	]
},
	"application/vnd.hal+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.hal+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"hal"
	]
},
	"application/vnd.handheld-entertainment+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"zmm"
	]
},
	"application/vnd.hbci": {
	source: "iana",
	extensions: [
		"hbci"
	]
},
	"application/vnd.hc+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.hcl-bireports": {
	source: "iana"
},
	"application/vnd.hdt": {
	source: "iana"
},
	"application/vnd.heroku+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.hhe.lesson-player": {
	source: "iana",
	extensions: [
		"les"
	]
},
	"application/vnd.hl7cda+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/vnd.hl7v2+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/vnd.hp-hpgl": {
	source: "iana",
	extensions: [
		"hpgl"
	]
},
	"application/vnd.hp-hpid": {
	source: "iana",
	extensions: [
		"hpid"
	]
},
	"application/vnd.hp-hps": {
	source: "iana",
	extensions: [
		"hps"
	]
},
	"application/vnd.hp-jlyt": {
	source: "iana",
	extensions: [
		"jlt"
	]
},
	"application/vnd.hp-pcl": {
	source: "iana",
	extensions: [
		"pcl"
	]
},
	"application/vnd.hp-pclxl": {
	source: "iana",
	extensions: [
		"pclxl"
	]
},
	"application/vnd.httphone": {
	source: "iana"
},
	"application/vnd.hydrostatix.sof-data": {
	source: "iana",
	extensions: [
		"sfd-hdstx"
	]
},
	"application/vnd.hyper+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.hyper-item+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.hyperdrive+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.hzn-3d-crossword": {
	source: "iana"
},
	"application/vnd.ibm.afplinedata": {
	source: "iana"
},
	"application/vnd.ibm.electronic-media": {
	source: "iana"
},
	"application/vnd.ibm.minipay": {
	source: "iana",
	extensions: [
		"mpy"
	]
},
	"application/vnd.ibm.modcap": {
	source: "iana",
	extensions: [
		"afp",
		"listafp",
		"list3820"
	]
},
	"application/vnd.ibm.rights-management": {
	source: "iana",
	extensions: [
		"irm"
	]
},
	"application/vnd.ibm.secure-container": {
	source: "iana",
	extensions: [
		"sc"
	]
},
	"application/vnd.iccprofile": {
	source: "iana",
	extensions: [
		"icc",
		"icm"
	]
},
	"application/vnd.ieee.1905": {
	source: "iana"
},
	"application/vnd.igloader": {
	source: "iana",
	extensions: [
		"igl"
	]
},
	"application/vnd.imagemeter.folder+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.imagemeter.image+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.immervision-ivp": {
	source: "iana",
	extensions: [
		"ivp"
	]
},
	"application/vnd.immervision-ivu": {
	source: "iana",
	extensions: [
		"ivu"
	]
},
	"application/vnd.ims.imsccv1p1": {
	source: "iana"
},
	"application/vnd.ims.imsccv1p2": {
	source: "iana"
},
	"application/vnd.ims.imsccv1p3": {
	source: "iana"
},
	"application/vnd.ims.lis.v2.result+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.ims.lti.v2.toolconsumerprofile+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.ims.lti.v2.toolproxy+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.ims.lti.v2.toolproxy.id+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.ims.lti.v2.toolsettings+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.ims.lti.v2.toolsettings.simple+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.informedcontrol.rms+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.informix-visionary": {
	source: "iana"
},
	"application/vnd.infotech.project": {
	source: "iana"
},
	"application/vnd.infotech.project+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.innopath.wamp.notification": {
	source: "iana"
},
	"application/vnd.insors.igm": {
	source: "iana",
	extensions: [
		"igm"
	]
},
	"application/vnd.intercon.formnet": {
	source: "iana",
	extensions: [
		"xpw",
		"xpx"
	]
},
	"application/vnd.intergeo": {
	source: "iana",
	extensions: [
		"i2g"
	]
},
	"application/vnd.intertrust.digibox": {
	source: "iana"
},
	"application/vnd.intertrust.nncp": {
	source: "iana"
},
	"application/vnd.intu.qbo": {
	source: "iana",
	extensions: [
		"qbo"
	]
},
	"application/vnd.intu.qfx": {
	source: "iana",
	extensions: [
		"qfx"
	]
},
	"application/vnd.iptc.g2.catalogitem+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.iptc.g2.conceptitem+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.iptc.g2.knowledgeitem+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.iptc.g2.newsitem+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.iptc.g2.newsmessage+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.iptc.g2.packageitem+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.iptc.g2.planningitem+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.ipunplugged.rcprofile": {
	source: "iana",
	extensions: [
		"rcprofile"
	]
},
	"application/vnd.irepository.package+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"irp"
	]
},
	"application/vnd.is-xpr": {
	source: "iana",
	extensions: [
		"xpr"
	]
},
	"application/vnd.isac.fcs": {
	source: "iana",
	extensions: [
		"fcs"
	]
},
	"application/vnd.iso11783-10+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.jam": {
	source: "iana",
	extensions: [
		"jam"
	]
},
	"application/vnd.japannet-directory-service": {
	source: "iana"
},
	"application/vnd.japannet-jpnstore-wakeup": {
	source: "iana"
},
	"application/vnd.japannet-payment-wakeup": {
	source: "iana"
},
	"application/vnd.japannet-registration": {
	source: "iana"
},
	"application/vnd.japannet-registration-wakeup": {
	source: "iana"
},
	"application/vnd.japannet-setstore-wakeup": {
	source: "iana"
},
	"application/vnd.japannet-verification": {
	source: "iana"
},
	"application/vnd.japannet-verification-wakeup": {
	source: "iana"
},
	"application/vnd.jcp.javame.midlet-rms": {
	source: "iana",
	extensions: [
		"rms"
	]
},
	"application/vnd.jisp": {
	source: "iana",
	extensions: [
		"jisp"
	]
},
	"application/vnd.joost.joda-archive": {
	source: "iana",
	extensions: [
		"joda"
	]
},
	"application/vnd.jsk.isdn-ngn": {
	source: "iana"
},
	"application/vnd.kahootz": {
	source: "iana",
	extensions: [
		"ktz",
		"ktr"
	]
},
	"application/vnd.kde.karbon": {
	source: "iana",
	extensions: [
		"karbon"
	]
},
	"application/vnd.kde.kchart": {
	source: "iana",
	extensions: [
		"chrt"
	]
},
	"application/vnd.kde.kformula": {
	source: "iana",
	extensions: [
		"kfo"
	]
},
	"application/vnd.kde.kivio": {
	source: "iana",
	extensions: [
		"flw"
	]
},
	"application/vnd.kde.kontour": {
	source: "iana",
	extensions: [
		"kon"
	]
},
	"application/vnd.kde.kpresenter": {
	source: "iana",
	extensions: [
		"kpr",
		"kpt"
	]
},
	"application/vnd.kde.kspread": {
	source: "iana",
	extensions: [
		"ksp"
	]
},
	"application/vnd.kde.kword": {
	source: "iana",
	extensions: [
		"kwd",
		"kwt"
	]
},
	"application/vnd.kenameaapp": {
	source: "iana",
	extensions: [
		"htke"
	]
},
	"application/vnd.kidspiration": {
	source: "iana",
	extensions: [
		"kia"
	]
},
	"application/vnd.kinar": {
	source: "iana",
	extensions: [
		"kne",
		"knp"
	]
},
	"application/vnd.koan": {
	source: "iana",
	extensions: [
		"skp",
		"skd",
		"skt",
		"skm"
	]
},
	"application/vnd.kodak-descriptor": {
	source: "iana",
	extensions: [
		"sse"
	]
},
	"application/vnd.las": {
	source: "iana"
},
	"application/vnd.las.las+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.las.las+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"lasxml"
	]
},
	"application/vnd.laszip": {
	source: "iana"
},
	"application/vnd.leap+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.liberty-request+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.llamagraphics.life-balance.desktop": {
	source: "iana",
	extensions: [
		"lbd"
	]
},
	"application/vnd.llamagraphics.life-balance.exchange+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"lbe"
	]
},
	"application/vnd.logipipe.circuit+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.loom": {
	source: "iana"
},
	"application/vnd.lotus-1-2-3": {
	source: "iana",
	extensions: [
		"123"
	]
},
	"application/vnd.lotus-approach": {
	source: "iana",
	extensions: [
		"apr"
	]
},
	"application/vnd.lotus-freelance": {
	source: "iana",
	extensions: [
		"pre"
	]
},
	"application/vnd.lotus-notes": {
	source: "iana",
	extensions: [
		"nsf"
	]
},
	"application/vnd.lotus-organizer": {
	source: "iana",
	extensions: [
		"org"
	]
},
	"application/vnd.lotus-screencam": {
	source: "iana",
	extensions: [
		"scm"
	]
},
	"application/vnd.lotus-wordpro": {
	source: "iana",
	extensions: [
		"lwp"
	]
},
	"application/vnd.macports.portpkg": {
	source: "iana",
	extensions: [
		"portpkg"
	]
},
	"application/vnd.mapbox-vector-tile": {
	source: "iana",
	extensions: [
		"mvt"
	]
},
	"application/vnd.marlin.drm.actiontoken+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.marlin.drm.conftoken+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.marlin.drm.license+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.marlin.drm.mdcf": {
	source: "iana"
},
	"application/vnd.mason+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.maxar.archive.3tz+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.maxmind.maxmind-db": {
	source: "iana"
},
	"application/vnd.mcd": {
	source: "iana",
	extensions: [
		"mcd"
	]
},
	"application/vnd.medcalcdata": {
	source: "iana",
	extensions: [
		"mc1"
	]
},
	"application/vnd.mediastation.cdkey": {
	source: "iana",
	extensions: [
		"cdkey"
	]
},
	"application/vnd.meridian-slingshot": {
	source: "iana"
},
	"application/vnd.mfer": {
	source: "iana",
	extensions: [
		"mwf"
	]
},
	"application/vnd.mfmp": {
	source: "iana",
	extensions: [
		"mfm"
	]
},
	"application/vnd.micro+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.micrografx.flo": {
	source: "iana",
	extensions: [
		"flo"
	]
},
	"application/vnd.micrografx.igx": {
	source: "iana",
	extensions: [
		"igx"
	]
},
	"application/vnd.microsoft.portable-executable": {
	source: "iana"
},
	"application/vnd.microsoft.windows.thumbnail-cache": {
	source: "iana"
},
	"application/vnd.miele+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.mif": {
	source: "iana",
	extensions: [
		"mif"
	]
},
	"application/vnd.minisoft-hp3000-save": {
	source: "iana"
},
	"application/vnd.mitsubishi.misty-guard.trustweb": {
	source: "iana"
},
	"application/vnd.mobius.daf": {
	source: "iana",
	extensions: [
		"daf"
	]
},
	"application/vnd.mobius.dis": {
	source: "iana",
	extensions: [
		"dis"
	]
},
	"application/vnd.mobius.mbk": {
	source: "iana",
	extensions: [
		"mbk"
	]
},
	"application/vnd.mobius.mqy": {
	source: "iana",
	extensions: [
		"mqy"
	]
},
	"application/vnd.mobius.msl": {
	source: "iana",
	extensions: [
		"msl"
	]
},
	"application/vnd.mobius.plc": {
	source: "iana",
	extensions: [
		"plc"
	]
},
	"application/vnd.mobius.txf": {
	source: "iana",
	extensions: [
		"txf"
	]
},
	"application/vnd.mophun.application": {
	source: "iana",
	extensions: [
		"mpn"
	]
},
	"application/vnd.mophun.certificate": {
	source: "iana",
	extensions: [
		"mpc"
	]
},
	"application/vnd.motorola.flexsuite": {
	source: "iana"
},
	"application/vnd.motorola.flexsuite.adsi": {
	source: "iana"
},
	"application/vnd.motorola.flexsuite.fis": {
	source: "iana"
},
	"application/vnd.motorola.flexsuite.gotap": {
	source: "iana"
},
	"application/vnd.motorola.flexsuite.kmr": {
	source: "iana"
},
	"application/vnd.motorola.flexsuite.ttc": {
	source: "iana"
},
	"application/vnd.motorola.flexsuite.wem": {
	source: "iana"
},
	"application/vnd.motorola.iprm": {
	source: "iana"
},
	"application/vnd.mozilla.xul+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xul"
	]
},
	"application/vnd.ms-3mfdocument": {
	source: "iana"
},
	"application/vnd.ms-artgalry": {
	source: "iana",
	extensions: [
		"cil"
	]
},
	"application/vnd.ms-asf": {
	source: "iana"
},
	"application/vnd.ms-cab-compressed": {
	source: "iana",
	extensions: [
		"cab"
	]
},
	"application/vnd.ms-color.iccprofile": {
	source: "apache"
},
	"application/vnd.ms-excel": {
	source: "iana",
	compressible: false,
	extensions: [
		"xls",
		"xlm",
		"xla",
		"xlc",
		"xlt",
		"xlw"
	]
},
	"application/vnd.ms-excel.addin.macroenabled.12": {
	source: "iana",
	extensions: [
		"xlam"
	]
},
	"application/vnd.ms-excel.sheet.binary.macroenabled.12": {
	source: "iana",
	extensions: [
		"xlsb"
	]
},
	"application/vnd.ms-excel.sheet.macroenabled.12": {
	source: "iana",
	extensions: [
		"xlsm"
	]
},
	"application/vnd.ms-excel.template.macroenabled.12": {
	source: "iana",
	extensions: [
		"xltm"
	]
},
	"application/vnd.ms-fontobject": {
	source: "iana",
	compressible: true,
	extensions: [
		"eot"
	]
},
	"application/vnd.ms-htmlhelp": {
	source: "iana",
	extensions: [
		"chm"
	]
},
	"application/vnd.ms-ims": {
	source: "iana",
	extensions: [
		"ims"
	]
},
	"application/vnd.ms-lrm": {
	source: "iana",
	extensions: [
		"lrm"
	]
},
	"application/vnd.ms-office.activex+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.ms-officetheme": {
	source: "iana",
	extensions: [
		"thmx"
	]
},
	"application/vnd.ms-opentype": {
	source: "apache",
	compressible: true
},
	"application/vnd.ms-outlook": {
	compressible: false,
	extensions: [
		"msg"
	]
},
	"application/vnd.ms-package.obfuscated-opentype": {
	source: "apache"
},
	"application/vnd.ms-pki.seccat": {
	source: "apache",
	extensions: [
		"cat"
	]
},
	"application/vnd.ms-pki.stl": {
	source: "apache",
	extensions: [
		"stl"
	]
},
	"application/vnd.ms-playready.initiator+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.ms-powerpoint": {
	source: "iana",
	compressible: false,
	extensions: [
		"ppt",
		"pps",
		"pot"
	]
},
	"application/vnd.ms-powerpoint.addin.macroenabled.12": {
	source: "iana",
	extensions: [
		"ppam"
	]
},
	"application/vnd.ms-powerpoint.presentation.macroenabled.12": {
	source: "iana",
	extensions: [
		"pptm"
	]
},
	"application/vnd.ms-powerpoint.slide.macroenabled.12": {
	source: "iana",
	extensions: [
		"sldm"
	]
},
	"application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
	source: "iana",
	extensions: [
		"ppsm"
	]
},
	"application/vnd.ms-powerpoint.template.macroenabled.12": {
	source: "iana",
	extensions: [
		"potm"
	]
},
	"application/vnd.ms-printdevicecapabilities+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.ms-printing.printticket+xml": {
	source: "apache",
	compressible: true
},
	"application/vnd.ms-printschematicket+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.ms-project": {
	source: "iana",
	extensions: [
		"mpp",
		"mpt"
	]
},
	"application/vnd.ms-tnef": {
	source: "iana"
},
	"application/vnd.ms-windows.devicepairing": {
	source: "iana"
},
	"application/vnd.ms-windows.nwprinting.oob": {
	source: "iana"
},
	"application/vnd.ms-windows.printerpairing": {
	source: "iana"
},
	"application/vnd.ms-windows.wsd.oob": {
	source: "iana"
},
	"application/vnd.ms-wmdrm.lic-chlg-req": {
	source: "iana"
},
	"application/vnd.ms-wmdrm.lic-resp": {
	source: "iana"
},
	"application/vnd.ms-wmdrm.meter-chlg-req": {
	source: "iana"
},
	"application/vnd.ms-wmdrm.meter-resp": {
	source: "iana"
},
	"application/vnd.ms-word.document.macroenabled.12": {
	source: "iana",
	extensions: [
		"docm"
	]
},
	"application/vnd.ms-word.template.macroenabled.12": {
	source: "iana",
	extensions: [
		"dotm"
	]
},
	"application/vnd.ms-works": {
	source: "iana",
	extensions: [
		"wps",
		"wks",
		"wcm",
		"wdb"
	]
},
	"application/vnd.ms-wpl": {
	source: "iana",
	extensions: [
		"wpl"
	]
},
	"application/vnd.ms-xpsdocument": {
	source: "iana",
	compressible: false,
	extensions: [
		"xps"
	]
},
	"application/vnd.msa-disk-image": {
	source: "iana"
},
	"application/vnd.mseq": {
	source: "iana",
	extensions: [
		"mseq"
	]
},
	"application/vnd.msign": {
	source: "iana"
},
	"application/vnd.multiad.creator": {
	source: "iana"
},
	"application/vnd.multiad.creator.cif": {
	source: "iana"
},
	"application/vnd.music-niff": {
	source: "iana"
},
	"application/vnd.musician": {
	source: "iana",
	extensions: [
		"mus"
	]
},
	"application/vnd.muvee.style": {
	source: "iana",
	extensions: [
		"msty"
	]
},
	"application/vnd.mynfc": {
	source: "iana",
	extensions: [
		"taglet"
	]
},
	"application/vnd.nacamar.ybrid+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.ncd.control": {
	source: "iana"
},
	"application/vnd.ncd.reference": {
	source: "iana"
},
	"application/vnd.nearst.inv+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.nebumind.line": {
	source: "iana"
},
	"application/vnd.nervana": {
	source: "iana"
},
	"application/vnd.netfpx": {
	source: "iana"
},
	"application/vnd.neurolanguage.nlu": {
	source: "iana",
	extensions: [
		"nlu"
	]
},
	"application/vnd.nimn": {
	source: "iana"
},
	"application/vnd.nintendo.nitro.rom": {
	source: "iana"
},
	"application/vnd.nintendo.snes.rom": {
	source: "iana"
},
	"application/vnd.nitf": {
	source: "iana",
	extensions: [
		"ntf",
		"nitf"
	]
},
	"application/vnd.noblenet-directory": {
	source: "iana",
	extensions: [
		"nnd"
	]
},
	"application/vnd.noblenet-sealer": {
	source: "iana",
	extensions: [
		"nns"
	]
},
	"application/vnd.noblenet-web": {
	source: "iana",
	extensions: [
		"nnw"
	]
},
	"application/vnd.nokia.catalogs": {
	source: "iana"
},
	"application/vnd.nokia.conml+wbxml": {
	source: "iana"
},
	"application/vnd.nokia.conml+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.nokia.iptv.config+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.nokia.isds-radio-presets": {
	source: "iana"
},
	"application/vnd.nokia.landmark+wbxml": {
	source: "iana"
},
	"application/vnd.nokia.landmark+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.nokia.landmarkcollection+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.nokia.n-gage.ac+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"ac"
	]
},
	"application/vnd.nokia.n-gage.data": {
	source: "iana",
	extensions: [
		"ngdat"
	]
},
	"application/vnd.nokia.n-gage.symbian.install": {
	source: "iana",
	extensions: [
		"n-gage"
	]
},
	"application/vnd.nokia.ncd": {
	source: "iana"
},
	"application/vnd.nokia.pcd+wbxml": {
	source: "iana"
},
	"application/vnd.nokia.pcd+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.nokia.radio-preset": {
	source: "iana",
	extensions: [
		"rpst"
	]
},
	"application/vnd.nokia.radio-presets": {
	source: "iana",
	extensions: [
		"rpss"
	]
},
	"application/vnd.novadigm.edm": {
	source: "iana",
	extensions: [
		"edm"
	]
},
	"application/vnd.novadigm.edx": {
	source: "iana",
	extensions: [
		"edx"
	]
},
	"application/vnd.novadigm.ext": {
	source: "iana",
	extensions: [
		"ext"
	]
},
	"application/vnd.ntt-local.content-share": {
	source: "iana"
},
	"application/vnd.ntt-local.file-transfer": {
	source: "iana"
},
	"application/vnd.ntt-local.ogw_remote-access": {
	source: "iana"
},
	"application/vnd.ntt-local.sip-ta_remote": {
	source: "iana"
},
	"application/vnd.ntt-local.sip-ta_tcp_stream": {
	source: "iana"
},
	"application/vnd.oasis.opendocument.chart": {
	source: "iana",
	extensions: [
		"odc"
	]
},
	"application/vnd.oasis.opendocument.chart-template": {
	source: "iana",
	extensions: [
		"otc"
	]
},
	"application/vnd.oasis.opendocument.database": {
	source: "iana",
	extensions: [
		"odb"
	]
},
	"application/vnd.oasis.opendocument.formula": {
	source: "iana",
	extensions: [
		"odf"
	]
},
	"application/vnd.oasis.opendocument.formula-template": {
	source: "iana",
	extensions: [
		"odft"
	]
},
	"application/vnd.oasis.opendocument.graphics": {
	source: "iana",
	compressible: false,
	extensions: [
		"odg"
	]
},
	"application/vnd.oasis.opendocument.graphics-template": {
	source: "iana",
	extensions: [
		"otg"
	]
},
	"application/vnd.oasis.opendocument.image": {
	source: "iana",
	extensions: [
		"odi"
	]
},
	"application/vnd.oasis.opendocument.image-template": {
	source: "iana",
	extensions: [
		"oti"
	]
},
	"application/vnd.oasis.opendocument.presentation": {
	source: "iana",
	compressible: false,
	extensions: [
		"odp"
	]
},
	"application/vnd.oasis.opendocument.presentation-template": {
	source: "iana",
	extensions: [
		"otp"
	]
},
	"application/vnd.oasis.opendocument.spreadsheet": {
	source: "iana",
	compressible: false,
	extensions: [
		"ods"
	]
},
	"application/vnd.oasis.opendocument.spreadsheet-template": {
	source: "iana",
	extensions: [
		"ots"
	]
},
	"application/vnd.oasis.opendocument.text": {
	source: "iana",
	compressible: false,
	extensions: [
		"odt"
	]
},
	"application/vnd.oasis.opendocument.text-master": {
	source: "iana",
	extensions: [
		"odm"
	]
},
	"application/vnd.oasis.opendocument.text-template": {
	source: "iana",
	extensions: [
		"ott"
	]
},
	"application/vnd.oasis.opendocument.text-web": {
	source: "iana",
	extensions: [
		"oth"
	]
},
	"application/vnd.obn": {
	source: "iana"
},
	"application/vnd.ocf+cbor": {
	source: "iana"
},
	"application/vnd.oci.image.manifest.v1+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.oftn.l10n+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.contentaccessdownload+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.contentaccessstreaming+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.cspg-hexbinary": {
	source: "iana"
},
	"application/vnd.oipf.dae.svg+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.dae.xhtml+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.mippvcontrolmessage+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.pae.gem": {
	source: "iana"
},
	"application/vnd.oipf.spdiscovery+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.spdlist+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.ueprofile+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.userprofile+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.olpc-sugar": {
	source: "iana",
	extensions: [
		"xo"
	]
},
	"application/vnd.oma-scws-config": {
	source: "iana"
},
	"application/vnd.oma-scws-http-request": {
	source: "iana"
},
	"application/vnd.oma-scws-http-response": {
	source: "iana"
},
	"application/vnd.oma.bcast.associated-procedure-parameter+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.bcast.drm-trigger+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.bcast.imd+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.bcast.ltkm": {
	source: "iana"
},
	"application/vnd.oma.bcast.notification+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.bcast.provisioningtrigger": {
	source: "iana"
},
	"application/vnd.oma.bcast.sgboot": {
	source: "iana"
},
	"application/vnd.oma.bcast.sgdd+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.bcast.sgdu": {
	source: "iana"
},
	"application/vnd.oma.bcast.simple-symbol-container": {
	source: "iana"
},
	"application/vnd.oma.bcast.smartcard-trigger+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.bcast.sprov+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.bcast.stkm": {
	source: "iana"
},
	"application/vnd.oma.cab-address-book+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.cab-feature-handler+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.cab-pcc+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.cab-subs-invite+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.cab-user-prefs+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.dcd": {
	source: "iana"
},
	"application/vnd.oma.dcdc": {
	source: "iana"
},
	"application/vnd.oma.dd2+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"dd2"
	]
},
	"application/vnd.oma.drm.risd+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.group-usage-list+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.lwm2m+cbor": {
	source: "iana"
},
	"application/vnd.oma.lwm2m+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.lwm2m+tlv": {
	source: "iana"
},
	"application/vnd.oma.pal+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.poc.detailed-progress-report+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.poc.final-report+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.poc.groups+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.poc.invocation-descriptor+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.poc.optimized-progress-report+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.push": {
	source: "iana"
},
	"application/vnd.oma.scidm.messages+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.xcap-directory+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.omads-email+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/vnd.omads-file+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/vnd.omads-folder+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/vnd.omaloc-supl-init": {
	source: "iana"
},
	"application/vnd.onepager": {
	source: "iana"
},
	"application/vnd.onepagertamp": {
	source: "iana"
},
	"application/vnd.onepagertamx": {
	source: "iana"
},
	"application/vnd.onepagertat": {
	source: "iana"
},
	"application/vnd.onepagertatp": {
	source: "iana"
},
	"application/vnd.onepagertatx": {
	source: "iana"
},
	"application/vnd.openblox.game+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"obgx"
	]
},
	"application/vnd.openblox.game-binary": {
	source: "iana"
},
	"application/vnd.openeye.oeb": {
	source: "iana"
},
	"application/vnd.openofficeorg.extension": {
	source: "apache",
	extensions: [
		"oxt"
	]
},
	"application/vnd.openstreetmap.data+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"osm"
	]
},
	"application/vnd.opentimestamps.ots": {
	source: "iana"
},
	"application/vnd.openxmlformats-officedocument.custom-properties+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.drawing+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.extended-properties+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.presentation": {
	source: "iana",
	compressible: false,
	extensions: [
		"pptx"
	]
},
	"application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.slide": {
	source: "iana",
	extensions: [
		"sldx"
	]
},
	"application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
	source: "iana",
	extensions: [
		"ppsx"
	]
},
	"application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.template": {
	source: "iana",
	extensions: [
		"potx"
	]
},
	"application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
	source: "iana",
	compressible: false,
	extensions: [
		"xlsx"
	]
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
	source: "iana",
	extensions: [
		"xltx"
	]
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.theme+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.themeoverride+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.vmldrawing": {
	source: "iana"
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
	source: "iana",
	compressible: false,
	extensions: [
		"docx"
	]
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
	source: "iana",
	extensions: [
		"dotx"
	]
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-package.core-properties+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-package.relationships+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oracle.resource+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.orange.indata": {
	source: "iana"
},
	"application/vnd.osa.netdeploy": {
	source: "iana"
},
	"application/vnd.osgeo.mapguide.package": {
	source: "iana",
	extensions: [
		"mgp"
	]
},
	"application/vnd.osgi.bundle": {
	source: "iana"
},
	"application/vnd.osgi.dp": {
	source: "iana",
	extensions: [
		"dp"
	]
},
	"application/vnd.osgi.subsystem": {
	source: "iana",
	extensions: [
		"esa"
	]
},
	"application/vnd.otps.ct-kip+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oxli.countgraph": {
	source: "iana"
},
	"application/vnd.pagerduty+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.palm": {
	source: "iana",
	extensions: [
		"pdb",
		"pqa",
		"oprc"
	]
},
	"application/vnd.panoply": {
	source: "iana"
},
	"application/vnd.paos.xml": {
	source: "iana"
},
	"application/vnd.patentdive": {
	source: "iana"
},
	"application/vnd.patientecommsdoc": {
	source: "iana"
},
	"application/vnd.pawaafile": {
	source: "iana",
	extensions: [
		"paw"
	]
},
	"application/vnd.pcos": {
	source: "iana"
},
	"application/vnd.pg.format": {
	source: "iana",
	extensions: [
		"str"
	]
},
	"application/vnd.pg.osasli": {
	source: "iana",
	extensions: [
		"ei6"
	]
},
	"application/vnd.piaccess.application-licence": {
	source: "iana"
},
	"application/vnd.picsel": {
	source: "iana",
	extensions: [
		"efif"
	]
},
	"application/vnd.pmi.widget": {
	source: "iana",
	extensions: [
		"wg"
	]
},
	"application/vnd.poc.group-advertisement+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.pocketlearn": {
	source: "iana",
	extensions: [
		"plf"
	]
},
	"application/vnd.powerbuilder6": {
	source: "iana",
	extensions: [
		"pbd"
	]
},
	"application/vnd.powerbuilder6-s": {
	source: "iana"
},
	"application/vnd.powerbuilder7": {
	source: "iana"
},
	"application/vnd.powerbuilder7-s": {
	source: "iana"
},
	"application/vnd.powerbuilder75": {
	source: "iana"
},
	"application/vnd.powerbuilder75-s": {
	source: "iana"
},
	"application/vnd.preminet": {
	source: "iana"
},
	"application/vnd.previewsystems.box": {
	source: "iana",
	extensions: [
		"box"
	]
},
	"application/vnd.proteus.magazine": {
	source: "iana",
	extensions: [
		"mgz"
	]
},
	"application/vnd.psfs": {
	source: "iana"
},
	"application/vnd.publishare-delta-tree": {
	source: "iana",
	extensions: [
		"qps"
	]
},
	"application/vnd.pvi.ptid1": {
	source: "iana",
	extensions: [
		"ptid"
	]
},
	"application/vnd.pwg-multiplexed": {
	source: "iana"
},
	"application/vnd.pwg-xhtml-print+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.qualcomm.brew-app-res": {
	source: "iana"
},
	"application/vnd.quarantainenet": {
	source: "iana"
},
	"application/vnd.quark.quarkxpress": {
	source: "iana",
	extensions: [
		"qxd",
		"qxt",
		"qwd",
		"qwt",
		"qxl",
		"qxb"
	]
},
	"application/vnd.quobject-quoxdocument": {
	source: "iana"
},
	"application/vnd.radisys.moml+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-audit+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-audit-conf+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-audit-conn+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-audit-dialog+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-audit-stream+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-conf+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-dialog+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-dialog-base+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-dialog-fax-detect+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-dialog-group+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-dialog-speech+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-dialog-transform+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.rainstor.data": {
	source: "iana"
},
	"application/vnd.rapid": {
	source: "iana"
},
	"application/vnd.rar": {
	source: "iana",
	extensions: [
		"rar"
	]
},
	"application/vnd.realvnc.bed": {
	source: "iana",
	extensions: [
		"bed"
	]
},
	"application/vnd.recordare.musicxml": {
	source: "iana",
	extensions: [
		"mxl"
	]
},
	"application/vnd.recordare.musicxml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"musicxml"
	]
},
	"application/vnd.renlearn.rlprint": {
	source: "iana"
},
	"application/vnd.resilient.logic": {
	source: "iana"
},
	"application/vnd.restful+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.rig.cryptonote": {
	source: "iana",
	extensions: [
		"cryptonote"
	]
},
	"application/vnd.rim.cod": {
	source: "apache",
	extensions: [
		"cod"
	]
},
	"application/vnd.rn-realmedia": {
	source: "apache",
	extensions: [
		"rm"
	]
},
	"application/vnd.rn-realmedia-vbr": {
	source: "apache",
	extensions: [
		"rmvb"
	]
},
	"application/vnd.route66.link66+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"link66"
	]
},
	"application/vnd.rs-274x": {
	source: "iana"
},
	"application/vnd.ruckus.download": {
	source: "iana"
},
	"application/vnd.s3sms": {
	source: "iana"
},
	"application/vnd.sailingtracker.track": {
	source: "iana",
	extensions: [
		"st"
	]
},
	"application/vnd.sar": {
	source: "iana"
},
	"application/vnd.sbm.cid": {
	source: "iana"
},
	"application/vnd.sbm.mid2": {
	source: "iana"
},
	"application/vnd.scribus": {
	source: "iana"
},
	"application/vnd.sealed.3df": {
	source: "iana"
},
	"application/vnd.sealed.csf": {
	source: "iana"
},
	"application/vnd.sealed.doc": {
	source: "iana"
},
	"application/vnd.sealed.eml": {
	source: "iana"
},
	"application/vnd.sealed.mht": {
	source: "iana"
},
	"application/vnd.sealed.net": {
	source: "iana"
},
	"application/vnd.sealed.ppt": {
	source: "iana"
},
	"application/vnd.sealed.tiff": {
	source: "iana"
},
	"application/vnd.sealed.xls": {
	source: "iana"
},
	"application/vnd.sealedmedia.softseal.html": {
	source: "iana"
},
	"application/vnd.sealedmedia.softseal.pdf": {
	source: "iana"
},
	"application/vnd.seemail": {
	source: "iana",
	extensions: [
		"see"
	]
},
	"application/vnd.seis+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.sema": {
	source: "iana",
	extensions: [
		"sema"
	]
},
	"application/vnd.semd": {
	source: "iana",
	extensions: [
		"semd"
	]
},
	"application/vnd.semf": {
	source: "iana",
	extensions: [
		"semf"
	]
},
	"application/vnd.shade-save-file": {
	source: "iana"
},
	"application/vnd.shana.informed.formdata": {
	source: "iana",
	extensions: [
		"ifm"
	]
},
	"application/vnd.shana.informed.formtemplate": {
	source: "iana",
	extensions: [
		"itp"
	]
},
	"application/vnd.shana.informed.interchange": {
	source: "iana",
	extensions: [
		"iif"
	]
},
	"application/vnd.shana.informed.package": {
	source: "iana",
	extensions: [
		"ipk"
	]
},
	"application/vnd.shootproof+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.shopkick+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.shp": {
	source: "iana"
},
	"application/vnd.shx": {
	source: "iana"
},
	"application/vnd.sigrok.session": {
	source: "iana"
},
	"application/vnd.simtech-mindmapper": {
	source: "iana",
	extensions: [
		"twd",
		"twds"
	]
},
	"application/vnd.siren+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.smaf": {
	source: "iana",
	extensions: [
		"mmf"
	]
},
	"application/vnd.smart.notebook": {
	source: "iana"
},
	"application/vnd.smart.teacher": {
	source: "iana",
	extensions: [
		"teacher"
	]
},
	"application/vnd.snesdev-page-table": {
	source: "iana"
},
	"application/vnd.software602.filler.form+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"fo"
	]
},
	"application/vnd.software602.filler.form-xml-zip": {
	source: "iana"
},
	"application/vnd.solent.sdkm+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"sdkm",
		"sdkd"
	]
},
	"application/vnd.spotfire.dxp": {
	source: "iana",
	extensions: [
		"dxp"
	]
},
	"application/vnd.spotfire.sfs": {
	source: "iana",
	extensions: [
		"sfs"
	]
},
	"application/vnd.sqlite3": {
	source: "iana"
},
	"application/vnd.sss-cod": {
	source: "iana"
},
	"application/vnd.sss-dtf": {
	source: "iana"
},
	"application/vnd.sss-ntf": {
	source: "iana"
},
	"application/vnd.stardivision.calc": {
	source: "apache",
	extensions: [
		"sdc"
	]
},
	"application/vnd.stardivision.draw": {
	source: "apache",
	extensions: [
		"sda"
	]
},
	"application/vnd.stardivision.impress": {
	source: "apache",
	extensions: [
		"sdd"
	]
},
	"application/vnd.stardivision.math": {
	source: "apache",
	extensions: [
		"smf"
	]
},
	"application/vnd.stardivision.writer": {
	source: "apache",
	extensions: [
		"sdw",
		"vor"
	]
},
	"application/vnd.stardivision.writer-global": {
	source: "apache",
	extensions: [
		"sgl"
	]
},
	"application/vnd.stepmania.package": {
	source: "iana",
	extensions: [
		"smzip"
	]
},
	"application/vnd.stepmania.stepchart": {
	source: "iana",
	extensions: [
		"sm"
	]
},
	"application/vnd.street-stream": {
	source: "iana"
},
	"application/vnd.sun.wadl+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"wadl"
	]
},
	"application/vnd.sun.xml.calc": {
	source: "apache",
	extensions: [
		"sxc"
	]
},
	"application/vnd.sun.xml.calc.template": {
	source: "apache",
	extensions: [
		"stc"
	]
},
	"application/vnd.sun.xml.draw": {
	source: "apache",
	extensions: [
		"sxd"
	]
},
	"application/vnd.sun.xml.draw.template": {
	source: "apache",
	extensions: [
		"std"
	]
},
	"application/vnd.sun.xml.impress": {
	source: "apache",
	extensions: [
		"sxi"
	]
},
	"application/vnd.sun.xml.impress.template": {
	source: "apache",
	extensions: [
		"sti"
	]
},
	"application/vnd.sun.xml.math": {
	source: "apache",
	extensions: [
		"sxm"
	]
},
	"application/vnd.sun.xml.writer": {
	source: "apache",
	extensions: [
		"sxw"
	]
},
	"application/vnd.sun.xml.writer.global": {
	source: "apache",
	extensions: [
		"sxg"
	]
},
	"application/vnd.sun.xml.writer.template": {
	source: "apache",
	extensions: [
		"stw"
	]
},
	"application/vnd.sus-calendar": {
	source: "iana",
	extensions: [
		"sus",
		"susp"
	]
},
	"application/vnd.svd": {
	source: "iana",
	extensions: [
		"svd"
	]
},
	"application/vnd.swiftview-ics": {
	source: "iana"
},
	"application/vnd.sycle+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.syft+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.symbian.install": {
	source: "apache",
	extensions: [
		"sis",
		"sisx"
	]
},
	"application/vnd.syncml+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"xsm"
	]
},
	"application/vnd.syncml.dm+wbxml": {
	source: "iana",
	charset: "UTF-8",
	extensions: [
		"bdm"
	]
},
	"application/vnd.syncml.dm+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"xdm"
	]
},
	"application/vnd.syncml.dm.notification": {
	source: "iana"
},
	"application/vnd.syncml.dmddf+wbxml": {
	source: "iana"
},
	"application/vnd.syncml.dmddf+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"ddf"
	]
},
	"application/vnd.syncml.dmtnds+wbxml": {
	source: "iana"
},
	"application/vnd.syncml.dmtnds+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/vnd.syncml.ds.notification": {
	source: "iana"
},
	"application/vnd.tableschema+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.tao.intent-module-archive": {
	source: "iana",
	extensions: [
		"tao"
	]
},
	"application/vnd.tcpdump.pcap": {
	source: "iana",
	extensions: [
		"pcap",
		"cap",
		"dmp"
	]
},
	"application/vnd.think-cell.ppttc+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.tmd.mediaflex.api+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.tml": {
	source: "iana"
},
	"application/vnd.tmobile-livetv": {
	source: "iana",
	extensions: [
		"tmo"
	]
},
	"application/vnd.tri.onesource": {
	source: "iana"
},
	"application/vnd.trid.tpt": {
	source: "iana",
	extensions: [
		"tpt"
	]
},
	"application/vnd.triscape.mxs": {
	source: "iana",
	extensions: [
		"mxs"
	]
},
	"application/vnd.trueapp": {
	source: "iana",
	extensions: [
		"tra"
	]
},
	"application/vnd.truedoc": {
	source: "iana"
},
	"application/vnd.ubisoft.webplayer": {
	source: "iana"
},
	"application/vnd.ufdl": {
	source: "iana",
	extensions: [
		"ufd",
		"ufdl"
	]
},
	"application/vnd.uiq.theme": {
	source: "iana",
	extensions: [
		"utz"
	]
},
	"application/vnd.umajin": {
	source: "iana",
	extensions: [
		"umj"
	]
},
	"application/vnd.unity": {
	source: "iana",
	extensions: [
		"unityweb"
	]
},
	"application/vnd.uoml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"uoml"
	]
},
	"application/vnd.uplanet.alert": {
	source: "iana"
},
	"application/vnd.uplanet.alert-wbxml": {
	source: "iana"
},
	"application/vnd.uplanet.bearer-choice": {
	source: "iana"
},
	"application/vnd.uplanet.bearer-choice-wbxml": {
	source: "iana"
},
	"application/vnd.uplanet.cacheop": {
	source: "iana"
},
	"application/vnd.uplanet.cacheop-wbxml": {
	source: "iana"
},
	"application/vnd.uplanet.channel": {
	source: "iana"
},
	"application/vnd.uplanet.channel-wbxml": {
	source: "iana"
},
	"application/vnd.uplanet.list": {
	source: "iana"
},
	"application/vnd.uplanet.list-wbxml": {
	source: "iana"
},
	"application/vnd.uplanet.listcmd": {
	source: "iana"
},
	"application/vnd.uplanet.listcmd-wbxml": {
	source: "iana"
},
	"application/vnd.uplanet.signal": {
	source: "iana"
},
	"application/vnd.uri-map": {
	source: "iana"
},
	"application/vnd.valve.source.material": {
	source: "iana"
},
	"application/vnd.vcx": {
	source: "iana",
	extensions: [
		"vcx"
	]
},
	"application/vnd.vd-study": {
	source: "iana"
},
	"application/vnd.vectorworks": {
	source: "iana"
},
	"application/vnd.vel+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.verimatrix.vcas": {
	source: "iana"
},
	"application/vnd.veritone.aion+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.veryant.thin": {
	source: "iana"
},
	"application/vnd.ves.encrypted": {
	source: "iana"
},
	"application/vnd.vidsoft.vidconference": {
	source: "iana"
},
	"application/vnd.visio": {
	source: "iana",
	extensions: [
		"vsd",
		"vst",
		"vss",
		"vsw"
	]
},
	"application/vnd.visionary": {
	source: "iana",
	extensions: [
		"vis"
	]
},
	"application/vnd.vividence.scriptfile": {
	source: "iana"
},
	"application/vnd.vsf": {
	source: "iana",
	extensions: [
		"vsf"
	]
},
	"application/vnd.wap.sic": {
	source: "iana"
},
	"application/vnd.wap.slc": {
	source: "iana"
},
	"application/vnd.wap.wbxml": {
	source: "iana",
	charset: "UTF-8",
	extensions: [
		"wbxml"
	]
},
	"application/vnd.wap.wmlc": {
	source: "iana",
	extensions: [
		"wmlc"
	]
},
	"application/vnd.wap.wmlscriptc": {
	source: "iana",
	extensions: [
		"wmlsc"
	]
},
	"application/vnd.webturbo": {
	source: "iana",
	extensions: [
		"wtb"
	]
},
	"application/vnd.wfa.dpp": {
	source: "iana"
},
	"application/vnd.wfa.p2p": {
	source: "iana"
},
	"application/vnd.wfa.wsc": {
	source: "iana"
},
	"application/vnd.windows.devicepairing": {
	source: "iana"
},
	"application/vnd.wmc": {
	source: "iana"
},
	"application/vnd.wmf.bootstrap": {
	source: "iana"
},
	"application/vnd.wolfram.mathematica": {
	source: "iana"
},
	"application/vnd.wolfram.mathematica.package": {
	source: "iana"
},
	"application/vnd.wolfram.player": {
	source: "iana",
	extensions: [
		"nbp"
	]
},
	"application/vnd.wordperfect": {
	source: "iana",
	extensions: [
		"wpd"
	]
},
	"application/vnd.wqd": {
	source: "iana",
	extensions: [
		"wqd"
	]
},
	"application/vnd.wrq-hp3000-labelled": {
	source: "iana"
},
	"application/vnd.wt.stf": {
	source: "iana",
	extensions: [
		"stf"
	]
},
	"application/vnd.wv.csp+wbxml": {
	source: "iana"
},
	"application/vnd.wv.csp+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.wv.ssp+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.xacml+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.xara": {
	source: "iana",
	extensions: [
		"xar"
	]
},
	"application/vnd.xfdl": {
	source: "iana",
	extensions: [
		"xfdl"
	]
},
	"application/vnd.xfdl.webform": {
	source: "iana"
},
	"application/vnd.xmi+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.xmpie.cpkg": {
	source: "iana"
},
	"application/vnd.xmpie.dpkg": {
	source: "iana"
},
	"application/vnd.xmpie.plan": {
	source: "iana"
},
	"application/vnd.xmpie.ppkg": {
	source: "iana"
},
	"application/vnd.xmpie.xlim": {
	source: "iana"
},
	"application/vnd.yamaha.hv-dic": {
	source: "iana",
	extensions: [
		"hvd"
	]
},
	"application/vnd.yamaha.hv-script": {
	source: "iana",
	extensions: [
		"hvs"
	]
},
	"application/vnd.yamaha.hv-voice": {
	source: "iana",
	extensions: [
		"hvp"
	]
},
	"application/vnd.yamaha.openscoreformat": {
	source: "iana",
	extensions: [
		"osf"
	]
},
	"application/vnd.yamaha.openscoreformat.osfpvg+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"osfpvg"
	]
},
	"application/vnd.yamaha.remote-setup": {
	source: "iana"
},
	"application/vnd.yamaha.smaf-audio": {
	source: "iana",
	extensions: [
		"saf"
	]
},
	"application/vnd.yamaha.smaf-phrase": {
	source: "iana",
	extensions: [
		"spf"
	]
},
	"application/vnd.yamaha.through-ngn": {
	source: "iana"
},
	"application/vnd.yamaha.tunnel-udpencap": {
	source: "iana"
},
	"application/vnd.yaoweme": {
	source: "iana"
},
	"application/vnd.yellowriver-custom-menu": {
	source: "iana",
	extensions: [
		"cmp"
	]
},
	"application/vnd.youtube.yt": {
	source: "iana"
},
	"application/vnd.zul": {
	source: "iana",
	extensions: [
		"zir",
		"zirz"
	]
},
	"application/vnd.zzazz.deck+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"zaz"
	]
},
	"application/voicexml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"vxml"
	]
},
	"application/voucher-cms+json": {
	source: "iana",
	compressible: true
},
	"application/vq-rtcpxr": {
	source: "iana"
},
	"application/wasm": {
	source: "iana",
	compressible: true,
	extensions: [
		"wasm"
	]
},
	"application/watcherinfo+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"wif"
	]
},
	"application/webpush-options+json": {
	source: "iana",
	compressible: true
},
	"application/whoispp-query": {
	source: "iana"
},
	"application/whoispp-response": {
	source: "iana"
},
	"application/widget": {
	source: "iana",
	extensions: [
		"wgt"
	]
},
	"application/winhlp": {
	source: "apache",
	extensions: [
		"hlp"
	]
},
	"application/wita": {
	source: "iana"
},
	"application/wordperfect5.1": {
	source: "iana"
},
	"application/wsdl+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"wsdl"
	]
},
	"application/wspolicy+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"wspolicy"
	]
},
	"application/x-7z-compressed": {
	source: "apache",
	compressible: false,
	extensions: [
		"7z"
	]
},
	"application/x-abiword": {
	source: "apache",
	extensions: [
		"abw"
	]
},
	"application/x-ace-compressed": {
	source: "apache",
	extensions: [
		"ace"
	]
},
	"application/x-amf": {
	source: "apache"
},
	"application/x-apple-diskimage": {
	source: "apache",
	extensions: [
		"dmg"
	]
},
	"application/x-arj": {
	compressible: false,
	extensions: [
		"arj"
	]
},
	"application/x-authorware-bin": {
	source: "apache",
	extensions: [
		"aab",
		"x32",
		"u32",
		"vox"
	]
},
	"application/x-authorware-map": {
	source: "apache",
	extensions: [
		"aam"
	]
},
	"application/x-authorware-seg": {
	source: "apache",
	extensions: [
		"aas"
	]
},
	"application/x-bcpio": {
	source: "apache",
	extensions: [
		"bcpio"
	]
},
	"application/x-bdoc": {
	compressible: false,
	extensions: [
		"bdoc"
	]
},
	"application/x-bittorrent": {
	source: "apache",
	extensions: [
		"torrent"
	]
},
	"application/x-blorb": {
	source: "apache",
	extensions: [
		"blb",
		"blorb"
	]
},
	"application/x-bzip": {
	source: "apache",
	compressible: false,
	extensions: [
		"bz"
	]
},
	"application/x-bzip2": {
	source: "apache",
	compressible: false,
	extensions: [
		"bz2",
		"boz"
	]
},
	"application/x-cbr": {
	source: "apache",
	extensions: [
		"cbr",
		"cba",
		"cbt",
		"cbz",
		"cb7"
	]
},
	"application/x-cdlink": {
	source: "apache",
	extensions: [
		"vcd"
	]
},
	"application/x-cfs-compressed": {
	source: "apache",
	extensions: [
		"cfs"
	]
},
	"application/x-chat": {
	source: "apache",
	extensions: [
		"chat"
	]
},
	"application/x-chess-pgn": {
	source: "apache",
	extensions: [
		"pgn"
	]
},
	"application/x-chrome-extension": {
	extensions: [
		"crx"
	]
},
	"application/x-cocoa": {
	source: "nginx",
	extensions: [
		"cco"
	]
},
	"application/x-compress": {
	source: "apache"
},
	"application/x-conference": {
	source: "apache",
	extensions: [
		"nsc"
	]
},
	"application/x-cpio": {
	source: "apache",
	extensions: [
		"cpio"
	]
},
	"application/x-csh": {
	source: "apache",
	extensions: [
		"csh"
	]
},
	"application/x-deb": {
	compressible: false
},
	"application/x-debian-package": {
	source: "apache",
	extensions: [
		"deb",
		"udeb"
	]
},
	"application/x-dgc-compressed": {
	source: "apache",
	extensions: [
		"dgc"
	]
},
	"application/x-director": {
	source: "apache",
	extensions: [
		"dir",
		"dcr",
		"dxr",
		"cst",
		"cct",
		"cxt",
		"w3d",
		"fgd",
		"swa"
	]
},
	"application/x-doom": {
	source: "apache",
	extensions: [
		"wad"
	]
},
	"application/x-dtbncx+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"ncx"
	]
},
	"application/x-dtbook+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"dtb"
	]
},
	"application/x-dtbresource+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"res"
	]
},
	"application/x-dvi": {
	source: "apache",
	compressible: false,
	extensions: [
		"dvi"
	]
},
	"application/x-envoy": {
	source: "apache",
	extensions: [
		"evy"
	]
},
	"application/x-eva": {
	source: "apache",
	extensions: [
		"eva"
	]
},
	"application/x-font-bdf": {
	source: "apache",
	extensions: [
		"bdf"
	]
},
	"application/x-font-dos": {
	source: "apache"
},
	"application/x-font-framemaker": {
	source: "apache"
},
	"application/x-font-ghostscript": {
	source: "apache",
	extensions: [
		"gsf"
	]
},
	"application/x-font-libgrx": {
	source: "apache"
},
	"application/x-font-linux-psf": {
	source: "apache",
	extensions: [
		"psf"
	]
},
	"application/x-font-pcf": {
	source: "apache",
	extensions: [
		"pcf"
	]
},
	"application/x-font-snf": {
	source: "apache",
	extensions: [
		"snf"
	]
},
	"application/x-font-speedo": {
	source: "apache"
},
	"application/x-font-sunos-news": {
	source: "apache"
},
	"application/x-font-type1": {
	source: "apache",
	extensions: [
		"pfa",
		"pfb",
		"pfm",
		"afm"
	]
},
	"application/x-font-vfont": {
	source: "apache"
},
	"application/x-freearc": {
	source: "apache",
	extensions: [
		"arc"
	]
},
	"application/x-futuresplash": {
	source: "apache",
	extensions: [
		"spl"
	]
},
	"application/x-gca-compressed": {
	source: "apache",
	extensions: [
		"gca"
	]
},
	"application/x-glulx": {
	source: "apache",
	extensions: [
		"ulx"
	]
},
	"application/x-gnumeric": {
	source: "apache",
	extensions: [
		"gnumeric"
	]
},
	"application/x-gramps-xml": {
	source: "apache",
	extensions: [
		"gramps"
	]
},
	"application/x-gtar": {
	source: "apache",
	extensions: [
		"gtar"
	]
},
	"application/x-gzip": {
	source: "apache"
},
	"application/x-hdf": {
	source: "apache",
	extensions: [
		"hdf"
	]
},
	"application/x-httpd-php": {
	compressible: true,
	extensions: [
		"php"
	]
},
	"application/x-install-instructions": {
	source: "apache",
	extensions: [
		"install"
	]
},
	"application/x-iso9660-image": {
	source: "apache",
	extensions: [
		"iso"
	]
},
	"application/x-iwork-keynote-sffkey": {
	extensions: [
		"key"
	]
},
	"application/x-iwork-numbers-sffnumbers": {
	extensions: [
		"numbers"
	]
},
	"application/x-iwork-pages-sffpages": {
	extensions: [
		"pages"
	]
},
	"application/x-java-archive-diff": {
	source: "nginx",
	extensions: [
		"jardiff"
	]
},
	"application/x-java-jnlp-file": {
	source: "apache",
	compressible: false,
	extensions: [
		"jnlp"
	]
},
	"application/x-javascript": {
	compressible: true
},
	"application/x-keepass2": {
	extensions: [
		"kdbx"
	]
},
	"application/x-latex": {
	source: "apache",
	compressible: false,
	extensions: [
		"latex"
	]
},
	"application/x-lua-bytecode": {
	extensions: [
		"luac"
	]
},
	"application/x-lzh-compressed": {
	source: "apache",
	extensions: [
		"lzh",
		"lha"
	]
},
	"application/x-makeself": {
	source: "nginx",
	extensions: [
		"run"
	]
},
	"application/x-mie": {
	source: "apache",
	extensions: [
		"mie"
	]
},
	"application/x-mobipocket-ebook": {
	source: "apache",
	extensions: [
		"prc",
		"mobi"
	]
},
	"application/x-mpegurl": {
	compressible: false
},
	"application/x-ms-application": {
	source: "apache",
	extensions: [
		"application"
	]
},
	"application/x-ms-shortcut": {
	source: "apache",
	extensions: [
		"lnk"
	]
},
	"application/x-ms-wmd": {
	source: "apache",
	extensions: [
		"wmd"
	]
},
	"application/x-ms-wmz": {
	source: "apache",
	extensions: [
		"wmz"
	]
},
	"application/x-ms-xbap": {
	source: "apache",
	extensions: [
		"xbap"
	]
},
	"application/x-msaccess": {
	source: "apache",
	extensions: [
		"mdb"
	]
},
	"application/x-msbinder": {
	source: "apache",
	extensions: [
		"obd"
	]
},
	"application/x-mscardfile": {
	source: "apache",
	extensions: [
		"crd"
	]
},
	"application/x-msclip": {
	source: "apache",
	extensions: [
		"clp"
	]
},
	"application/x-msdos-program": {
	extensions: [
		"exe"
	]
},
	"application/x-msdownload": {
	source: "apache",
	extensions: [
		"exe",
		"dll",
		"com",
		"bat",
		"msi"
	]
},
	"application/x-msmediaview": {
	source: "apache",
	extensions: [
		"mvb",
		"m13",
		"m14"
	]
},
	"application/x-msmetafile": {
	source: "apache",
	extensions: [
		"wmf",
		"wmz",
		"emf",
		"emz"
	]
},
	"application/x-msmoney": {
	source: "apache",
	extensions: [
		"mny"
	]
},
	"application/x-mspublisher": {
	source: "apache",
	extensions: [
		"pub"
	]
},
	"application/x-msschedule": {
	source: "apache",
	extensions: [
		"scd"
	]
},
	"application/x-msterminal": {
	source: "apache",
	extensions: [
		"trm"
	]
},
	"application/x-mswrite": {
	source: "apache",
	extensions: [
		"wri"
	]
},
	"application/x-netcdf": {
	source: "apache",
	extensions: [
		"nc",
		"cdf"
	]
},
	"application/x-ns-proxy-autoconfig": {
	compressible: true,
	extensions: [
		"pac"
	]
},
	"application/x-nzb": {
	source: "apache",
	extensions: [
		"nzb"
	]
},
	"application/x-perl": {
	source: "nginx",
	extensions: [
		"pl",
		"pm"
	]
},
	"application/x-pilot": {
	source: "nginx",
	extensions: [
		"prc",
		"pdb"
	]
},
	"application/x-pkcs12": {
	source: "apache",
	compressible: false,
	extensions: [
		"p12",
		"pfx"
	]
},
	"application/x-pkcs7-certificates": {
	source: "apache",
	extensions: [
		"p7b",
		"spc"
	]
},
	"application/x-pkcs7-certreqresp": {
	source: "apache",
	extensions: [
		"p7r"
	]
},
	"application/x-pki-message": {
	source: "iana"
},
	"application/x-rar-compressed": {
	source: "apache",
	compressible: false,
	extensions: [
		"rar"
	]
},
	"application/x-redhat-package-manager": {
	source: "nginx",
	extensions: [
		"rpm"
	]
},
	"application/x-research-info-systems": {
	source: "apache",
	extensions: [
		"ris"
	]
},
	"application/x-sea": {
	source: "nginx",
	extensions: [
		"sea"
	]
},
	"application/x-sh": {
	source: "apache",
	compressible: true,
	extensions: [
		"sh"
	]
},
	"application/x-shar": {
	source: "apache",
	extensions: [
		"shar"
	]
},
	"application/x-shockwave-flash": {
	source: "apache",
	compressible: false,
	extensions: [
		"swf"
	]
},
	"application/x-silverlight-app": {
	source: "apache",
	extensions: [
		"xap"
	]
},
	"application/x-sql": {
	source: "apache",
	extensions: [
		"sql"
	]
},
	"application/x-stuffit": {
	source: "apache",
	compressible: false,
	extensions: [
		"sit"
	]
},
	"application/x-stuffitx": {
	source: "apache",
	extensions: [
		"sitx"
	]
},
	"application/x-subrip": {
	source: "apache",
	extensions: [
		"srt"
	]
},
	"application/x-sv4cpio": {
	source: "apache",
	extensions: [
		"sv4cpio"
	]
},
	"application/x-sv4crc": {
	source: "apache",
	extensions: [
		"sv4crc"
	]
},
	"application/x-t3vm-image": {
	source: "apache",
	extensions: [
		"t3"
	]
},
	"application/x-tads": {
	source: "apache",
	extensions: [
		"gam"
	]
},
	"application/x-tar": {
	source: "apache",
	compressible: true,
	extensions: [
		"tar"
	]
},
	"application/x-tcl": {
	source: "apache",
	extensions: [
		"tcl",
		"tk"
	]
},
	"application/x-tex": {
	source: "apache",
	extensions: [
		"tex"
	]
},
	"application/x-tex-tfm": {
	source: "apache",
	extensions: [
		"tfm"
	]
},
	"application/x-texinfo": {
	source: "apache",
	extensions: [
		"texinfo",
		"texi"
	]
},
	"application/x-tgif": {
	source: "apache",
	extensions: [
		"obj"
	]
},
	"application/x-ustar": {
	source: "apache",
	extensions: [
		"ustar"
	]
},
	"application/x-virtualbox-hdd": {
	compressible: true,
	extensions: [
		"hdd"
	]
},
	"application/x-virtualbox-ova": {
	compressible: true,
	extensions: [
		"ova"
	]
},
	"application/x-virtualbox-ovf": {
	compressible: true,
	extensions: [
		"ovf"
	]
},
	"application/x-virtualbox-vbox": {
	compressible: true,
	extensions: [
		"vbox"
	]
},
	"application/x-virtualbox-vbox-extpack": {
	compressible: false,
	extensions: [
		"vbox-extpack"
	]
},
	"application/x-virtualbox-vdi": {
	compressible: true,
	extensions: [
		"vdi"
	]
},
	"application/x-virtualbox-vhd": {
	compressible: true,
	extensions: [
		"vhd"
	]
},
	"application/x-virtualbox-vmdk": {
	compressible: true,
	extensions: [
		"vmdk"
	]
},
	"application/x-wais-source": {
	source: "apache",
	extensions: [
		"src"
	]
},
	"application/x-web-app-manifest+json": {
	compressible: true,
	extensions: [
		"webapp"
	]
},
	"application/x-www-form-urlencoded": {
	source: "iana",
	compressible: true
},
	"application/x-x509-ca-cert": {
	source: "iana",
	extensions: [
		"der",
		"crt",
		"pem"
	]
},
	"application/x-x509-ca-ra-cert": {
	source: "iana"
},
	"application/x-x509-next-ca-cert": {
	source: "iana"
},
	"application/x-xfig": {
	source: "apache",
	extensions: [
		"fig"
	]
},
	"application/x-xliff+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"xlf"
	]
},
	"application/x-xpinstall": {
	source: "apache",
	compressible: false,
	extensions: [
		"xpi"
	]
},
	"application/x-xz": {
	source: "apache",
	extensions: [
		"xz"
	]
},
	"application/x-zmachine": {
	source: "apache",
	extensions: [
		"z1",
		"z2",
		"z3",
		"z4",
		"z5",
		"z6",
		"z7",
		"z8"
	]
},
	"application/x400-bp": {
	source: "iana"
},
	"application/xacml+xml": {
	source: "iana",
	compressible: true
},
	"application/xaml+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"xaml"
	]
},
	"application/xcap-att+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xav"
	]
},
	"application/xcap-caps+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xca"
	]
},
	"application/xcap-diff+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xdf"
	]
},
	"application/xcap-el+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xel"
	]
},
	"application/xcap-error+xml": {
	source: "iana",
	compressible: true
},
	"application/xcap-ns+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xns"
	]
},
	"application/xcon-conference-info+xml": {
	source: "iana",
	compressible: true
},
	"application/xcon-conference-info-diff+xml": {
	source: "iana",
	compressible: true
},
	"application/xenc+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xenc"
	]
},
	"application/xhtml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xhtml",
		"xht"
	]
},
	"application/xhtml-voice+xml": {
	source: "apache",
	compressible: true
},
	"application/xliff+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xlf"
	]
},
	"application/xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xml",
		"xsl",
		"xsd",
		"rng"
	]
},
	"application/xml-dtd": {
	source: "iana",
	compressible: true,
	extensions: [
		"dtd"
	]
},
	"application/xml-external-parsed-entity": {
	source: "iana"
},
	"application/xml-patch+xml": {
	source: "iana",
	compressible: true
},
	"application/xmpp+xml": {
	source: "iana",
	compressible: true
},
	"application/xop+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xop"
	]
},
	"application/xproc+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"xpl"
	]
},
	"application/xslt+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xsl",
		"xslt"
	]
},
	"application/xspf+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"xspf"
	]
},
	"application/xv+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mxml",
		"xhvml",
		"xvml",
		"xvm"
	]
},
	"application/yang": {
	source: "iana",
	extensions: [
		"yang"
	]
},
	"application/yang-data+json": {
	source: "iana",
	compressible: true
},
	"application/yang-data+xml": {
	source: "iana",
	compressible: true
},
	"application/yang-patch+json": {
	source: "iana",
	compressible: true
},
	"application/yang-patch+xml": {
	source: "iana",
	compressible: true
},
	"application/yin+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"yin"
	]
},
	"application/zip": {
	source: "iana",
	compressible: false,
	extensions: [
		"zip"
	]
},
	"application/zlib": {
	source: "iana"
},
	"application/zstd": {
	source: "iana"
},
	"audio/1d-interleaved-parityfec": {
	source: "iana"
},
	"audio/32kadpcm": {
	source: "iana"
},
	"audio/3gpp": {
	source: "iana",
	compressible: false,
	extensions: [
		"3gpp"
	]
},
	"audio/3gpp2": {
	source: "iana"
},
	"audio/aac": {
	source: "iana"
},
	"audio/ac3": {
	source: "iana"
},
	"audio/adpcm": {
	source: "apache",
	extensions: [
		"adp"
	]
},
	"audio/amr": {
	source: "iana",
	extensions: [
		"amr"
	]
},
	"audio/amr-wb": {
	source: "iana"
},
	"audio/amr-wb+": {
	source: "iana"
},
	"audio/aptx": {
	source: "iana"
},
	"audio/asc": {
	source: "iana"
},
	"audio/atrac-advanced-lossless": {
	source: "iana"
},
	"audio/atrac-x": {
	source: "iana"
},
	"audio/atrac3": {
	source: "iana"
},
	"audio/basic": {
	source: "iana",
	compressible: false,
	extensions: [
		"au",
		"snd"
	]
},
	"audio/bv16": {
	source: "iana"
},
	"audio/bv32": {
	source: "iana"
},
	"audio/clearmode": {
	source: "iana"
},
	"audio/cn": {
	source: "iana"
},
	"audio/dat12": {
	source: "iana"
},
	"audio/dls": {
	source: "iana"
},
	"audio/dsr-es201108": {
	source: "iana"
},
	"audio/dsr-es202050": {
	source: "iana"
},
	"audio/dsr-es202211": {
	source: "iana"
},
	"audio/dsr-es202212": {
	source: "iana"
},
	"audio/dv": {
	source: "iana"
},
	"audio/dvi4": {
	source: "iana"
},
	"audio/eac3": {
	source: "iana"
},
	"audio/encaprtp": {
	source: "iana"
},
	"audio/evrc": {
	source: "iana"
},
	"audio/evrc-qcp": {
	source: "iana"
},
	"audio/evrc0": {
	source: "iana"
},
	"audio/evrc1": {
	source: "iana"
},
	"audio/evrcb": {
	source: "iana"
},
	"audio/evrcb0": {
	source: "iana"
},
	"audio/evrcb1": {
	source: "iana"
},
	"audio/evrcnw": {
	source: "iana"
},
	"audio/evrcnw0": {
	source: "iana"
},
	"audio/evrcnw1": {
	source: "iana"
},
	"audio/evrcwb": {
	source: "iana"
},
	"audio/evrcwb0": {
	source: "iana"
},
	"audio/evrcwb1": {
	source: "iana"
},
	"audio/evs": {
	source: "iana"
},
	"audio/flexfec": {
	source: "iana"
},
	"audio/fwdred": {
	source: "iana"
},
	"audio/g711-0": {
	source: "iana"
},
	"audio/g719": {
	source: "iana"
},
	"audio/g722": {
	source: "iana"
},
	"audio/g7221": {
	source: "iana"
},
	"audio/g723": {
	source: "iana"
},
	"audio/g726-16": {
	source: "iana"
},
	"audio/g726-24": {
	source: "iana"
},
	"audio/g726-32": {
	source: "iana"
},
	"audio/g726-40": {
	source: "iana"
},
	"audio/g728": {
	source: "iana"
},
	"audio/g729": {
	source: "iana"
},
	"audio/g7291": {
	source: "iana"
},
	"audio/g729d": {
	source: "iana"
},
	"audio/g729e": {
	source: "iana"
},
	"audio/gsm": {
	source: "iana"
},
	"audio/gsm-efr": {
	source: "iana"
},
	"audio/gsm-hr-08": {
	source: "iana"
},
	"audio/ilbc": {
	source: "iana"
},
	"audio/ip-mr_v2.5": {
	source: "iana"
},
	"audio/isac": {
	source: "apache"
},
	"audio/l16": {
	source: "iana"
},
	"audio/l20": {
	source: "iana"
},
	"audio/l24": {
	source: "iana",
	compressible: false
},
	"audio/l8": {
	source: "iana"
},
	"audio/lpc": {
	source: "iana"
},
	"audio/melp": {
	source: "iana"
},
	"audio/melp1200": {
	source: "iana"
},
	"audio/melp2400": {
	source: "iana"
},
	"audio/melp600": {
	source: "iana"
},
	"audio/mhas": {
	source: "iana"
},
	"audio/midi": {
	source: "apache",
	extensions: [
		"mid",
		"midi",
		"kar",
		"rmi"
	]
},
	"audio/mobile-xmf": {
	source: "iana",
	extensions: [
		"mxmf"
	]
},
	"audio/mp3": {
	compressible: false,
	extensions: [
		"mp3"
	]
},
	"audio/mp4": {
	source: "iana",
	compressible: false,
	extensions: [
		"m4a",
		"mp4a"
	]
},
	"audio/mp4a-latm": {
	source: "iana"
},
	"audio/mpa": {
	source: "iana"
},
	"audio/mpa-robust": {
	source: "iana"
},
	"audio/mpeg": {
	source: "iana",
	compressible: false,
	extensions: [
		"mpga",
		"mp2",
		"mp2a",
		"mp3",
		"m2a",
		"m3a"
	]
},
	"audio/mpeg4-generic": {
	source: "iana"
},
	"audio/musepack": {
	source: "apache"
},
	"audio/ogg": {
	source: "iana",
	compressible: false,
	extensions: [
		"oga",
		"ogg",
		"spx",
		"opus"
	]
},
	"audio/opus": {
	source: "iana"
},
	"audio/parityfec": {
	source: "iana"
},
	"audio/pcma": {
	source: "iana"
},
	"audio/pcma-wb": {
	source: "iana"
},
	"audio/pcmu": {
	source: "iana"
},
	"audio/pcmu-wb": {
	source: "iana"
},
	"audio/prs.sid": {
	source: "iana"
},
	"audio/qcelp": {
	source: "iana"
},
	"audio/raptorfec": {
	source: "iana"
},
	"audio/red": {
	source: "iana"
},
	"audio/rtp-enc-aescm128": {
	source: "iana"
},
	"audio/rtp-midi": {
	source: "iana"
},
	"audio/rtploopback": {
	source: "iana"
},
	"audio/rtx": {
	source: "iana"
},
	"audio/s3m": {
	source: "apache",
	extensions: [
		"s3m"
	]
},
	"audio/scip": {
	source: "iana"
},
	"audio/silk": {
	source: "apache",
	extensions: [
		"sil"
	]
},
	"audio/smv": {
	source: "iana"
},
	"audio/smv-qcp": {
	source: "iana"
},
	"audio/smv0": {
	source: "iana"
},
	"audio/sofa": {
	source: "iana"
},
	"audio/sp-midi": {
	source: "iana"
},
	"audio/speex": {
	source: "iana"
},
	"audio/t140c": {
	source: "iana"
},
	"audio/t38": {
	source: "iana"
},
	"audio/telephone-event": {
	source: "iana"
},
	"audio/tetra_acelp": {
	source: "iana"
},
	"audio/tetra_acelp_bb": {
	source: "iana"
},
	"audio/tone": {
	source: "iana"
},
	"audio/tsvcis": {
	source: "iana"
},
	"audio/uemclip": {
	source: "iana"
},
	"audio/ulpfec": {
	source: "iana"
},
	"audio/usac": {
	source: "iana"
},
	"audio/vdvi": {
	source: "iana"
},
	"audio/vmr-wb": {
	source: "iana"
},
	"audio/vnd.3gpp.iufp": {
	source: "iana"
},
	"audio/vnd.4sb": {
	source: "iana"
},
	"audio/vnd.audiokoz": {
	source: "iana"
},
	"audio/vnd.celp": {
	source: "iana"
},
	"audio/vnd.cisco.nse": {
	source: "iana"
},
	"audio/vnd.cmles.radio-events": {
	source: "iana"
},
	"audio/vnd.cns.anp1": {
	source: "iana"
},
	"audio/vnd.cns.inf1": {
	source: "iana"
},
	"audio/vnd.dece.audio": {
	source: "iana",
	extensions: [
		"uva",
		"uvva"
	]
},
	"audio/vnd.digital-winds": {
	source: "iana",
	extensions: [
		"eol"
	]
},
	"audio/vnd.dlna.adts": {
	source: "iana"
},
	"audio/vnd.dolby.heaac.1": {
	source: "iana"
},
	"audio/vnd.dolby.heaac.2": {
	source: "iana"
},
	"audio/vnd.dolby.mlp": {
	source: "iana"
},
	"audio/vnd.dolby.mps": {
	source: "iana"
},
	"audio/vnd.dolby.pl2": {
	source: "iana"
},
	"audio/vnd.dolby.pl2x": {
	source: "iana"
},
	"audio/vnd.dolby.pl2z": {
	source: "iana"
},
	"audio/vnd.dolby.pulse.1": {
	source: "iana"
},
	"audio/vnd.dra": {
	source: "iana",
	extensions: [
		"dra"
	]
},
	"audio/vnd.dts": {
	source: "iana",
	extensions: [
		"dts"
	]
},
	"audio/vnd.dts.hd": {
	source: "iana",
	extensions: [
		"dtshd"
	]
},
	"audio/vnd.dts.uhd": {
	source: "iana"
},
	"audio/vnd.dvb.file": {
	source: "iana"
},
	"audio/vnd.everad.plj": {
	source: "iana"
},
	"audio/vnd.hns.audio": {
	source: "iana"
},
	"audio/vnd.lucent.voice": {
	source: "iana",
	extensions: [
		"lvp"
	]
},
	"audio/vnd.ms-playready.media.pya": {
	source: "iana",
	extensions: [
		"pya"
	]
},
	"audio/vnd.nokia.mobile-xmf": {
	source: "iana"
},
	"audio/vnd.nortel.vbk": {
	source: "iana"
},
	"audio/vnd.nuera.ecelp4800": {
	source: "iana",
	extensions: [
		"ecelp4800"
	]
},
	"audio/vnd.nuera.ecelp7470": {
	source: "iana",
	extensions: [
		"ecelp7470"
	]
},
	"audio/vnd.nuera.ecelp9600": {
	source: "iana",
	extensions: [
		"ecelp9600"
	]
},
	"audio/vnd.octel.sbc": {
	source: "iana"
},
	"audio/vnd.presonus.multitrack": {
	source: "iana"
},
	"audio/vnd.qcelp": {
	source: "iana"
},
	"audio/vnd.rhetorex.32kadpcm": {
	source: "iana"
},
	"audio/vnd.rip": {
	source: "iana",
	extensions: [
		"rip"
	]
},
	"audio/vnd.rn-realaudio": {
	compressible: false
},
	"audio/vnd.sealedmedia.softseal.mpeg": {
	source: "iana"
},
	"audio/vnd.vmx.cvsd": {
	source: "iana"
},
	"audio/vnd.wave": {
	compressible: false
},
	"audio/vorbis": {
	source: "iana",
	compressible: false
},
	"audio/vorbis-config": {
	source: "iana"
},
	"audio/wav": {
	compressible: false,
	extensions: [
		"wav"
	]
},
	"audio/wave": {
	compressible: false,
	extensions: [
		"wav"
	]
},
	"audio/webm": {
	source: "apache",
	compressible: false,
	extensions: [
		"weba"
	]
},
	"audio/x-aac": {
	source: "apache",
	compressible: false,
	extensions: [
		"aac"
	]
},
	"audio/x-aiff": {
	source: "apache",
	extensions: [
		"aif",
		"aiff",
		"aifc"
	]
},
	"audio/x-caf": {
	source: "apache",
	compressible: false,
	extensions: [
		"caf"
	]
},
	"audio/x-flac": {
	source: "apache",
	extensions: [
		"flac"
	]
},
	"audio/x-m4a": {
	source: "nginx",
	extensions: [
		"m4a"
	]
},
	"audio/x-matroska": {
	source: "apache",
	extensions: [
		"mka"
	]
},
	"audio/x-mpegurl": {
	source: "apache",
	extensions: [
		"m3u"
	]
},
	"audio/x-ms-wax": {
	source: "apache",
	extensions: [
		"wax"
	]
},
	"audio/x-ms-wma": {
	source: "apache",
	extensions: [
		"wma"
	]
},
	"audio/x-pn-realaudio": {
	source: "apache",
	extensions: [
		"ram",
		"ra"
	]
},
	"audio/x-pn-realaudio-plugin": {
	source: "apache",
	extensions: [
		"rmp"
	]
},
	"audio/x-realaudio": {
	source: "nginx",
	extensions: [
		"ra"
	]
},
	"audio/x-tta": {
	source: "apache"
},
	"audio/x-wav": {
	source: "apache",
	extensions: [
		"wav"
	]
},
	"audio/xm": {
	source: "apache",
	extensions: [
		"xm"
	]
},
	"chemical/x-cdx": {
	source: "apache",
	extensions: [
		"cdx"
	]
},
	"chemical/x-cif": {
	source: "apache",
	extensions: [
		"cif"
	]
},
	"chemical/x-cmdf": {
	source: "apache",
	extensions: [
		"cmdf"
	]
},
	"chemical/x-cml": {
	source: "apache",
	extensions: [
		"cml"
	]
},
	"chemical/x-csml": {
	source: "apache",
	extensions: [
		"csml"
	]
},
	"chemical/x-pdb": {
	source: "apache"
},
	"chemical/x-xyz": {
	source: "apache",
	extensions: [
		"xyz"
	]
},
	"font/collection": {
	source: "iana",
	extensions: [
		"ttc"
	]
},
	"font/otf": {
	source: "iana",
	compressible: true,
	extensions: [
		"otf"
	]
},
	"font/sfnt": {
	source: "iana"
},
	"font/ttf": {
	source: "iana",
	compressible: true,
	extensions: [
		"ttf"
	]
},
	"font/woff": {
	source: "iana",
	extensions: [
		"woff"
	]
},
	"font/woff2": {
	source: "iana",
	extensions: [
		"woff2"
	]
},
	"image/aces": {
	source: "iana",
	extensions: [
		"exr"
	]
},
	"image/apng": {
	compressible: false,
	extensions: [
		"apng"
	]
},
	"image/avci": {
	source: "iana",
	extensions: [
		"avci"
	]
},
	"image/avcs": {
	source: "iana",
	extensions: [
		"avcs"
	]
},
	"image/avif": {
	source: "iana",
	compressible: false,
	extensions: [
		"avif"
	]
},
	"image/bmp": {
	source: "iana",
	compressible: true,
	extensions: [
		"bmp"
	]
},
	"image/cgm": {
	source: "iana",
	extensions: [
		"cgm"
	]
},
	"image/dicom-rle": {
	source: "iana",
	extensions: [
		"drle"
	]
},
	"image/emf": {
	source: "iana",
	extensions: [
		"emf"
	]
},
	"image/fits": {
	source: "iana",
	extensions: [
		"fits"
	]
},
	"image/g3fax": {
	source: "iana",
	extensions: [
		"g3"
	]
},
	"image/gif": {
	source: "iana",
	compressible: false,
	extensions: [
		"gif"
	]
},
	"image/heic": {
	source: "iana",
	extensions: [
		"heic"
	]
},
	"image/heic-sequence": {
	source: "iana",
	extensions: [
		"heics"
	]
},
	"image/heif": {
	source: "iana",
	extensions: [
		"heif"
	]
},
	"image/heif-sequence": {
	source: "iana",
	extensions: [
		"heifs"
	]
},
	"image/hej2k": {
	source: "iana",
	extensions: [
		"hej2"
	]
},
	"image/hsj2": {
	source: "iana",
	extensions: [
		"hsj2"
	]
},
	"image/ief": {
	source: "iana",
	extensions: [
		"ief"
	]
},
	"image/jls": {
	source: "iana",
	extensions: [
		"jls"
	]
},
	"image/jp2": {
	source: "iana",
	compressible: false,
	extensions: [
		"jp2",
		"jpg2"
	]
},
	"image/jpeg": {
	source: "iana",
	compressible: false,
	extensions: [
		"jpeg",
		"jpg",
		"jpe"
	]
},
	"image/jph": {
	source: "iana",
	extensions: [
		"jph"
	]
},
	"image/jphc": {
	source: "iana",
	extensions: [
		"jhc"
	]
},
	"image/jpm": {
	source: "iana",
	compressible: false,
	extensions: [
		"jpm"
	]
},
	"image/jpx": {
	source: "iana",
	compressible: false,
	extensions: [
		"jpx",
		"jpf"
	]
},
	"image/jxr": {
	source: "iana",
	extensions: [
		"jxr"
	]
},
	"image/jxra": {
	source: "iana",
	extensions: [
		"jxra"
	]
},
	"image/jxrs": {
	source: "iana",
	extensions: [
		"jxrs"
	]
},
	"image/jxs": {
	source: "iana",
	extensions: [
		"jxs"
	]
},
	"image/jxsc": {
	source: "iana",
	extensions: [
		"jxsc"
	]
},
	"image/jxsi": {
	source: "iana",
	extensions: [
		"jxsi"
	]
},
	"image/jxss": {
	source: "iana",
	extensions: [
		"jxss"
	]
},
	"image/ktx": {
	source: "iana",
	extensions: [
		"ktx"
	]
},
	"image/ktx2": {
	source: "iana",
	extensions: [
		"ktx2"
	]
},
	"image/naplps": {
	source: "iana"
},
	"image/pjpeg": {
	compressible: false
},
	"image/png": {
	source: "iana",
	compressible: false,
	extensions: [
		"png"
	]
},
	"image/prs.btif": {
	source: "iana",
	extensions: [
		"btif"
	]
},
	"image/prs.pti": {
	source: "iana",
	extensions: [
		"pti"
	]
},
	"image/pwg-raster": {
	source: "iana"
},
	"image/sgi": {
	source: "apache",
	extensions: [
		"sgi"
	]
},
	"image/svg+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"svg",
		"svgz"
	]
},
	"image/t38": {
	source: "iana",
	extensions: [
		"t38"
	]
},
	"image/tiff": {
	source: "iana",
	compressible: false,
	extensions: [
		"tif",
		"tiff"
	]
},
	"image/tiff-fx": {
	source: "iana",
	extensions: [
		"tfx"
	]
},
	"image/vnd.adobe.photoshop": {
	source: "iana",
	compressible: true,
	extensions: [
		"psd"
	]
},
	"image/vnd.airzip.accelerator.azv": {
	source: "iana",
	extensions: [
		"azv"
	]
},
	"image/vnd.cns.inf2": {
	source: "iana"
},
	"image/vnd.dece.graphic": {
	source: "iana",
	extensions: [
		"uvi",
		"uvvi",
		"uvg",
		"uvvg"
	]
},
	"image/vnd.djvu": {
	source: "iana",
	extensions: [
		"djvu",
		"djv"
	]
},
	"image/vnd.dvb.subtitle": {
	source: "iana",
	extensions: [
		"sub"
	]
},
	"image/vnd.dwg": {
	source: "iana",
	extensions: [
		"dwg"
	]
},
	"image/vnd.dxf": {
	source: "iana",
	extensions: [
		"dxf"
	]
},
	"image/vnd.fastbidsheet": {
	source: "iana",
	extensions: [
		"fbs"
	]
},
	"image/vnd.fpx": {
	source: "iana",
	extensions: [
		"fpx"
	]
},
	"image/vnd.fst": {
	source: "iana",
	extensions: [
		"fst"
	]
},
	"image/vnd.fujixerox.edmics-mmr": {
	source: "iana",
	extensions: [
		"mmr"
	]
},
	"image/vnd.fujixerox.edmics-rlc": {
	source: "iana",
	extensions: [
		"rlc"
	]
},
	"image/vnd.globalgraphics.pgb": {
	source: "iana"
},
	"image/vnd.microsoft.icon": {
	source: "iana",
	compressible: true,
	extensions: [
		"ico"
	]
},
	"image/vnd.mix": {
	source: "iana"
},
	"image/vnd.mozilla.apng": {
	source: "iana"
},
	"image/vnd.ms-dds": {
	compressible: true,
	extensions: [
		"dds"
	]
},
	"image/vnd.ms-modi": {
	source: "iana",
	extensions: [
		"mdi"
	]
},
	"image/vnd.ms-photo": {
	source: "apache",
	extensions: [
		"wdp"
	]
},
	"image/vnd.net-fpx": {
	source: "iana",
	extensions: [
		"npx"
	]
},
	"image/vnd.pco.b16": {
	source: "iana",
	extensions: [
		"b16"
	]
},
	"image/vnd.radiance": {
	source: "iana"
},
	"image/vnd.sealed.png": {
	source: "iana"
},
	"image/vnd.sealedmedia.softseal.gif": {
	source: "iana"
},
	"image/vnd.sealedmedia.softseal.jpg": {
	source: "iana"
},
	"image/vnd.svf": {
	source: "iana"
},
	"image/vnd.tencent.tap": {
	source: "iana",
	extensions: [
		"tap"
	]
},
	"image/vnd.valve.source.texture": {
	source: "iana",
	extensions: [
		"vtf"
	]
},
	"image/vnd.wap.wbmp": {
	source: "iana",
	extensions: [
		"wbmp"
	]
},
	"image/vnd.xiff": {
	source: "iana",
	extensions: [
		"xif"
	]
},
	"image/vnd.zbrush.pcx": {
	source: "iana",
	extensions: [
		"pcx"
	]
},
	"image/webp": {
	source: "apache",
	extensions: [
		"webp"
	]
},
	"image/wmf": {
	source: "iana",
	extensions: [
		"wmf"
	]
},
	"image/x-3ds": {
	source: "apache",
	extensions: [
		"3ds"
	]
},
	"image/x-cmu-raster": {
	source: "apache",
	extensions: [
		"ras"
	]
},
	"image/x-cmx": {
	source: "apache",
	extensions: [
		"cmx"
	]
},
	"image/x-freehand": {
	source: "apache",
	extensions: [
		"fh",
		"fhc",
		"fh4",
		"fh5",
		"fh7"
	]
},
	"image/x-icon": {
	source: "apache",
	compressible: true,
	extensions: [
		"ico"
	]
},
	"image/x-jng": {
	source: "nginx",
	extensions: [
		"jng"
	]
},
	"image/x-mrsid-image": {
	source: "apache",
	extensions: [
		"sid"
	]
},
	"image/x-ms-bmp": {
	source: "nginx",
	compressible: true,
	extensions: [
		"bmp"
	]
},
	"image/x-pcx": {
	source: "apache",
	extensions: [
		"pcx"
	]
},
	"image/x-pict": {
	source: "apache",
	extensions: [
		"pic",
		"pct"
	]
},
	"image/x-portable-anymap": {
	source: "apache",
	extensions: [
		"pnm"
	]
},
	"image/x-portable-bitmap": {
	source: "apache",
	extensions: [
		"pbm"
	]
},
	"image/x-portable-graymap": {
	source: "apache",
	extensions: [
		"pgm"
	]
},
	"image/x-portable-pixmap": {
	source: "apache",
	extensions: [
		"ppm"
	]
},
	"image/x-rgb": {
	source: "apache",
	extensions: [
		"rgb"
	]
},
	"image/x-tga": {
	source: "apache",
	extensions: [
		"tga"
	]
},
	"image/x-xbitmap": {
	source: "apache",
	extensions: [
		"xbm"
	]
},
	"image/x-xcf": {
	compressible: false
},
	"image/x-xpixmap": {
	source: "apache",
	extensions: [
		"xpm"
	]
},
	"image/x-xwindowdump": {
	source: "apache",
	extensions: [
		"xwd"
	]
},
	"message/cpim": {
	source: "iana"
},
	"message/delivery-status": {
	source: "iana"
},
	"message/disposition-notification": {
	source: "iana",
	extensions: [
		"disposition-notification"
	]
},
	"message/external-body": {
	source: "iana"
},
	"message/feedback-report": {
	source: "iana"
},
	"message/global": {
	source: "iana",
	extensions: [
		"u8msg"
	]
},
	"message/global-delivery-status": {
	source: "iana",
	extensions: [
		"u8dsn"
	]
},
	"message/global-disposition-notification": {
	source: "iana",
	extensions: [
		"u8mdn"
	]
},
	"message/global-headers": {
	source: "iana",
	extensions: [
		"u8hdr"
	]
},
	"message/http": {
	source: "iana",
	compressible: false
},
	"message/imdn+xml": {
	source: "iana",
	compressible: true
},
	"message/news": {
	source: "iana"
},
	"message/partial": {
	source: "iana",
	compressible: false
},
	"message/rfc822": {
	source: "iana",
	compressible: true,
	extensions: [
		"eml",
		"mime"
	]
},
	"message/s-http": {
	source: "iana"
},
	"message/sip": {
	source: "iana"
},
	"message/sipfrag": {
	source: "iana"
},
	"message/tracking-status": {
	source: "iana"
},
	"message/vnd.si.simp": {
	source: "iana"
},
	"message/vnd.wfa.wsc": {
	source: "iana",
	extensions: [
		"wsc"
	]
},
	"model/3mf": {
	source: "iana",
	extensions: [
		"3mf"
	]
},
	"model/e57": {
	source: "iana"
},
	"model/gltf+json": {
	source: "iana",
	compressible: true,
	extensions: [
		"gltf"
	]
},
	"model/gltf-binary": {
	source: "iana",
	compressible: true,
	extensions: [
		"glb"
	]
},
	"model/iges": {
	source: "iana",
	compressible: false,
	extensions: [
		"igs",
		"iges"
	]
},
	"model/mesh": {
	source: "iana",
	compressible: false,
	extensions: [
		"msh",
		"mesh",
		"silo"
	]
},
	"model/mtl": {
	source: "iana",
	extensions: [
		"mtl"
	]
},
	"model/obj": {
	source: "iana",
	extensions: [
		"obj"
	]
},
	"model/step": {
	source: "iana"
},
	"model/step+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"stpx"
	]
},
	"model/step+zip": {
	source: "iana",
	compressible: false,
	extensions: [
		"stpz"
	]
},
	"model/step-xml+zip": {
	source: "iana",
	compressible: false,
	extensions: [
		"stpxz"
	]
},
	"model/stl": {
	source: "iana",
	extensions: [
		"stl"
	]
},
	"model/vnd.collada+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"dae"
	]
},
	"model/vnd.dwf": {
	source: "iana",
	extensions: [
		"dwf"
	]
},
	"model/vnd.flatland.3dml": {
	source: "iana"
},
	"model/vnd.gdl": {
	source: "iana",
	extensions: [
		"gdl"
	]
},
	"model/vnd.gs-gdl": {
	source: "apache"
},
	"model/vnd.gs.gdl": {
	source: "iana"
},
	"model/vnd.gtw": {
	source: "iana",
	extensions: [
		"gtw"
	]
},
	"model/vnd.moml+xml": {
	source: "iana",
	compressible: true
},
	"model/vnd.mts": {
	source: "iana",
	extensions: [
		"mts"
	]
},
	"model/vnd.opengex": {
	source: "iana",
	extensions: [
		"ogex"
	]
},
	"model/vnd.parasolid.transmit.binary": {
	source: "iana",
	extensions: [
		"x_b"
	]
},
	"model/vnd.parasolid.transmit.text": {
	source: "iana",
	extensions: [
		"x_t"
	]
},
	"model/vnd.pytha.pyox": {
	source: "iana"
},
	"model/vnd.rosette.annotated-data-model": {
	source: "iana"
},
	"model/vnd.sap.vds": {
	source: "iana",
	extensions: [
		"vds"
	]
},
	"model/vnd.usdz+zip": {
	source: "iana",
	compressible: false,
	extensions: [
		"usdz"
	]
},
	"model/vnd.valve.source.compiled-map": {
	source: "iana",
	extensions: [
		"bsp"
	]
},
	"model/vnd.vtu": {
	source: "iana",
	extensions: [
		"vtu"
	]
},
	"model/vrml": {
	source: "iana",
	compressible: false,
	extensions: [
		"wrl",
		"vrml"
	]
},
	"model/x3d+binary": {
	source: "apache",
	compressible: false,
	extensions: [
		"x3db",
		"x3dbz"
	]
},
	"model/x3d+fastinfoset": {
	source: "iana",
	extensions: [
		"x3db"
	]
},
	"model/x3d+vrml": {
	source: "apache",
	compressible: false,
	extensions: [
		"x3dv",
		"x3dvz"
	]
},
	"model/x3d+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"x3d",
		"x3dz"
	]
},
	"model/x3d-vrml": {
	source: "iana",
	extensions: [
		"x3dv"
	]
},
	"multipart/alternative": {
	source: "iana",
	compressible: false
},
	"multipart/appledouble": {
	source: "iana"
},
	"multipart/byteranges": {
	source: "iana"
},
	"multipart/digest": {
	source: "iana"
},
	"multipart/encrypted": {
	source: "iana",
	compressible: false
},
	"multipart/form-data": {
	source: "iana",
	compressible: false
},
	"multipart/header-set": {
	source: "iana"
},
	"multipart/mixed": {
	source: "iana"
},
	"multipart/multilingual": {
	source: "iana"
},
	"multipart/parallel": {
	source: "iana"
},
	"multipart/related": {
	source: "iana",
	compressible: false
},
	"multipart/report": {
	source: "iana"
},
	"multipart/signed": {
	source: "iana",
	compressible: false
},
	"multipart/vnd.bint.med-plus": {
	source: "iana"
},
	"multipart/voice-message": {
	source: "iana"
},
	"multipart/x-mixed-replace": {
	source: "iana"
},
	"text/1d-interleaved-parityfec": {
	source: "iana"
},
	"text/cache-manifest": {
	source: "iana",
	compressible: true,
	extensions: [
		"appcache",
		"manifest"
	]
},
	"text/calendar": {
	source: "iana",
	extensions: [
		"ics",
		"ifb"
	]
},
	"text/calender": {
	compressible: true
},
	"text/cmd": {
	compressible: true
},
	"text/coffeescript": {
	extensions: [
		"coffee",
		"litcoffee"
	]
},
	"text/cql": {
	source: "iana"
},
	"text/cql-expression": {
	source: "iana"
},
	"text/cql-identifier": {
	source: "iana"
},
	"text/css": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"css"
	]
},
	"text/csv": {
	source: "iana",
	compressible: true,
	extensions: [
		"csv"
	]
},
	"text/csv-schema": {
	source: "iana"
},
	"text/directory": {
	source: "iana"
},
	"text/dns": {
	source: "iana"
},
	"text/ecmascript": {
	source: "iana"
},
	"text/encaprtp": {
	source: "iana"
},
	"text/enriched": {
	source: "iana"
},
	"text/fhirpath": {
	source: "iana"
},
	"text/flexfec": {
	source: "iana"
},
	"text/fwdred": {
	source: "iana"
},
	"text/gff3": {
	source: "iana"
},
	"text/grammar-ref-list": {
	source: "iana"
},
	"text/html": {
	source: "iana",
	compressible: true,
	extensions: [
		"html",
		"htm",
		"shtml"
	]
},
	"text/jade": {
	extensions: [
		"jade"
	]
},
	"text/javascript": {
	source: "iana",
	compressible: true
},
	"text/jcr-cnd": {
	source: "iana"
},
	"text/jsx": {
	compressible: true,
	extensions: [
		"jsx"
	]
},
	"text/less": {
	compressible: true,
	extensions: [
		"less"
	]
},
	"text/markdown": {
	source: "iana",
	compressible: true,
	extensions: [
		"markdown",
		"md"
	]
},
	"text/mathml": {
	source: "nginx",
	extensions: [
		"mml"
	]
},
	"text/mdx": {
	compressible: true,
	extensions: [
		"mdx"
	]
},
	"text/mizar": {
	source: "iana"
},
	"text/n3": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"n3"
	]
},
	"text/parameters": {
	source: "iana",
	charset: "UTF-8"
},
	"text/parityfec": {
	source: "iana"
},
	"text/plain": {
	source: "iana",
	compressible: true,
	extensions: [
		"txt",
		"text",
		"conf",
		"def",
		"list",
		"log",
		"in",
		"ini"
	]
},
	"text/provenance-notation": {
	source: "iana",
	charset: "UTF-8"
},
	"text/prs.fallenstein.rst": {
	source: "iana"
},
	"text/prs.lines.tag": {
	source: "iana",
	extensions: [
		"dsc"
	]
},
	"text/prs.prop.logic": {
	source: "iana"
},
	"text/raptorfec": {
	source: "iana"
},
	"text/red": {
	source: "iana"
},
	"text/rfc822-headers": {
	source: "iana"
},
	"text/richtext": {
	source: "iana",
	compressible: true,
	extensions: [
		"rtx"
	]
},
	"text/rtf": {
	source: "iana",
	compressible: true,
	extensions: [
		"rtf"
	]
},
	"text/rtp-enc-aescm128": {
	source: "iana"
},
	"text/rtploopback": {
	source: "iana"
},
	"text/rtx": {
	source: "iana"
},
	"text/sgml": {
	source: "iana",
	extensions: [
		"sgml",
		"sgm"
	]
},
	"text/shaclc": {
	source: "iana"
},
	"text/shex": {
	source: "iana",
	extensions: [
		"shex"
	]
},
	"text/slim": {
	extensions: [
		"slim",
		"slm"
	]
},
	"text/spdx": {
	source: "iana",
	extensions: [
		"spdx"
	]
},
	"text/strings": {
	source: "iana"
},
	"text/stylus": {
	extensions: [
		"stylus",
		"styl"
	]
},
	"text/t140": {
	source: "iana"
},
	"text/tab-separated-values": {
	source: "iana",
	compressible: true,
	extensions: [
		"tsv"
	]
},
	"text/troff": {
	source: "iana",
	extensions: [
		"t",
		"tr",
		"roff",
		"man",
		"me",
		"ms"
	]
},
	"text/turtle": {
	source: "iana",
	charset: "UTF-8",
	extensions: [
		"ttl"
	]
},
	"text/ulpfec": {
	source: "iana"
},
	"text/uri-list": {
	source: "iana",
	compressible: true,
	extensions: [
		"uri",
		"uris",
		"urls"
	]
},
	"text/vcard": {
	source: "iana",
	compressible: true,
	extensions: [
		"vcard"
	]
},
	"text/vnd.a": {
	source: "iana"
},
	"text/vnd.abc": {
	source: "iana"
},
	"text/vnd.ascii-art": {
	source: "iana"
},
	"text/vnd.curl": {
	source: "iana",
	extensions: [
		"curl"
	]
},
	"text/vnd.curl.dcurl": {
	source: "apache",
	extensions: [
		"dcurl"
	]
},
	"text/vnd.curl.mcurl": {
	source: "apache",
	extensions: [
		"mcurl"
	]
},
	"text/vnd.curl.scurl": {
	source: "apache",
	extensions: [
		"scurl"
	]
},
	"text/vnd.debian.copyright": {
	source: "iana",
	charset: "UTF-8"
},
	"text/vnd.dmclientscript": {
	source: "iana"
},
	"text/vnd.dvb.subtitle": {
	source: "iana",
	extensions: [
		"sub"
	]
},
	"text/vnd.esmertec.theme-descriptor": {
	source: "iana",
	charset: "UTF-8"
},
	"text/vnd.familysearch.gedcom": {
	source: "iana",
	extensions: [
		"ged"
	]
},
	"text/vnd.ficlab.flt": {
	source: "iana"
},
	"text/vnd.fly": {
	source: "iana",
	extensions: [
		"fly"
	]
},
	"text/vnd.fmi.flexstor": {
	source: "iana",
	extensions: [
		"flx"
	]
},
	"text/vnd.gml": {
	source: "iana"
},
	"text/vnd.graphviz": {
	source: "iana",
	extensions: [
		"gv"
	]
},
	"text/vnd.hans": {
	source: "iana"
},
	"text/vnd.hgl": {
	source: "iana"
},
	"text/vnd.in3d.3dml": {
	source: "iana",
	extensions: [
		"3dml"
	]
},
	"text/vnd.in3d.spot": {
	source: "iana",
	extensions: [
		"spot"
	]
},
	"text/vnd.iptc.newsml": {
	source: "iana"
},
	"text/vnd.iptc.nitf": {
	source: "iana"
},
	"text/vnd.latex-z": {
	source: "iana"
},
	"text/vnd.motorola.reflex": {
	source: "iana"
},
	"text/vnd.ms-mediapackage": {
	source: "iana"
},
	"text/vnd.net2phone.commcenter.command": {
	source: "iana"
},
	"text/vnd.radisys.msml-basic-layout": {
	source: "iana"
},
	"text/vnd.senx.warpscript": {
	source: "iana"
},
	"text/vnd.si.uricatalogue": {
	source: "iana"
},
	"text/vnd.sosi": {
	source: "iana"
},
	"text/vnd.sun.j2me.app-descriptor": {
	source: "iana",
	charset: "UTF-8",
	extensions: [
		"jad"
	]
},
	"text/vnd.trolltech.linguist": {
	source: "iana",
	charset: "UTF-8"
},
	"text/vnd.wap.si": {
	source: "iana"
},
	"text/vnd.wap.sl": {
	source: "iana"
},
	"text/vnd.wap.wml": {
	source: "iana",
	extensions: [
		"wml"
	]
},
	"text/vnd.wap.wmlscript": {
	source: "iana",
	extensions: [
		"wmls"
	]
},
	"text/vtt": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"vtt"
	]
},
	"text/x-asm": {
	source: "apache",
	extensions: [
		"s",
		"asm"
	]
},
	"text/x-c": {
	source: "apache",
	extensions: [
		"c",
		"cc",
		"cxx",
		"cpp",
		"h",
		"hh",
		"dic"
	]
},
	"text/x-component": {
	source: "nginx",
	extensions: [
		"htc"
	]
},
	"text/x-fortran": {
	source: "apache",
	extensions: [
		"f",
		"for",
		"f77",
		"f90"
	]
},
	"text/x-gwt-rpc": {
	compressible: true
},
	"text/x-handlebars-template": {
	extensions: [
		"hbs"
	]
},
	"text/x-java-source": {
	source: "apache",
	extensions: [
		"java"
	]
},
	"text/x-jquery-tmpl": {
	compressible: true
},
	"text/x-lua": {
	extensions: [
		"lua"
	]
},
	"text/x-markdown": {
	compressible: true,
	extensions: [
		"mkd"
	]
},
	"text/x-nfo": {
	source: "apache",
	extensions: [
		"nfo"
	]
},
	"text/x-opml": {
	source: "apache",
	extensions: [
		"opml"
	]
},
	"text/x-org": {
	compressible: true,
	extensions: [
		"org"
	]
},
	"text/x-pascal": {
	source: "apache",
	extensions: [
		"p",
		"pas"
	]
},
	"text/x-processing": {
	compressible: true,
	extensions: [
		"pde"
	]
},
	"text/x-sass": {
	extensions: [
		"sass"
	]
},
	"text/x-scss": {
	extensions: [
		"scss"
	]
},
	"text/x-setext": {
	source: "apache",
	extensions: [
		"etx"
	]
},
	"text/x-sfv": {
	source: "apache",
	extensions: [
		"sfv"
	]
},
	"text/x-suse-ymp": {
	compressible: true,
	extensions: [
		"ymp"
	]
},
	"text/x-uuencode": {
	source: "apache",
	extensions: [
		"uu"
	]
},
	"text/x-vcalendar": {
	source: "apache",
	extensions: [
		"vcs"
	]
},
	"text/x-vcard": {
	source: "apache",
	extensions: [
		"vcf"
	]
},
	"text/xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xml"
	]
},
	"text/xml-external-parsed-entity": {
	source: "iana"
},
	"text/yaml": {
	compressible: true,
	extensions: [
		"yaml",
		"yml"
	]
},
	"video/1d-interleaved-parityfec": {
	source: "iana"
},
	"video/3gpp": {
	source: "iana",
	extensions: [
		"3gp",
		"3gpp"
	]
},
	"video/3gpp-tt": {
	source: "iana"
},
	"video/3gpp2": {
	source: "iana",
	extensions: [
		"3g2"
	]
},
	"video/av1": {
	source: "iana"
},
	"video/bmpeg": {
	source: "iana"
},
	"video/bt656": {
	source: "iana"
},
	"video/celb": {
	source: "iana"
},
	"video/dv": {
	source: "iana"
},
	"video/encaprtp": {
	source: "iana"
},
	"video/ffv1": {
	source: "iana"
},
	"video/flexfec": {
	source: "iana"
},
	"video/h261": {
	source: "iana",
	extensions: [
		"h261"
	]
},
	"video/h263": {
	source: "iana",
	extensions: [
		"h263"
	]
},
	"video/h263-1998": {
	source: "iana"
},
	"video/h263-2000": {
	source: "iana"
},
	"video/h264": {
	source: "iana",
	extensions: [
		"h264"
	]
},
	"video/h264-rcdo": {
	source: "iana"
},
	"video/h264-svc": {
	source: "iana"
},
	"video/h265": {
	source: "iana"
},
	"video/iso.segment": {
	source: "iana",
	extensions: [
		"m4s"
	]
},
	"video/jpeg": {
	source: "iana",
	extensions: [
		"jpgv"
	]
},
	"video/jpeg2000": {
	source: "iana"
},
	"video/jpm": {
	source: "apache",
	extensions: [
		"jpm",
		"jpgm"
	]
},
	"video/jxsv": {
	source: "iana"
},
	"video/mj2": {
	source: "iana",
	extensions: [
		"mj2",
		"mjp2"
	]
},
	"video/mp1s": {
	source: "iana"
},
	"video/mp2p": {
	source: "iana"
},
	"video/mp2t": {
	source: "iana",
	extensions: [
		"ts"
	]
},
	"video/mp4": {
	source: "iana",
	compressible: false,
	extensions: [
		"mp4",
		"mp4v",
		"mpg4"
	]
},
	"video/mp4v-es": {
	source: "iana"
},
	"video/mpeg": {
	source: "iana",
	compressible: false,
	extensions: [
		"mpeg",
		"mpg",
		"mpe",
		"m1v",
		"m2v"
	]
},
	"video/mpeg4-generic": {
	source: "iana"
},
	"video/mpv": {
	source: "iana"
},
	"video/nv": {
	source: "iana"
},
	"video/ogg": {
	source: "iana",
	compressible: false,
	extensions: [
		"ogv"
	]
},
	"video/parityfec": {
	source: "iana"
},
	"video/pointer": {
	source: "iana"
},
	"video/quicktime": {
	source: "iana",
	compressible: false,
	extensions: [
		"qt",
		"mov"
	]
},
	"video/raptorfec": {
	source: "iana"
},
	"video/raw": {
	source: "iana"
},
	"video/rtp-enc-aescm128": {
	source: "iana"
},
	"video/rtploopback": {
	source: "iana"
},
	"video/rtx": {
	source: "iana"
},
	"video/scip": {
	source: "iana"
},
	"video/smpte291": {
	source: "iana"
},
	"video/smpte292m": {
	source: "iana"
},
	"video/ulpfec": {
	source: "iana"
},
	"video/vc1": {
	source: "iana"
},
	"video/vc2": {
	source: "iana"
},
	"video/vnd.cctv": {
	source: "iana"
},
	"video/vnd.dece.hd": {
	source: "iana",
	extensions: [
		"uvh",
		"uvvh"
	]
},
	"video/vnd.dece.mobile": {
	source: "iana",
	extensions: [
		"uvm",
		"uvvm"
	]
},
	"video/vnd.dece.mp4": {
	source: "iana"
},
	"video/vnd.dece.pd": {
	source: "iana",
	extensions: [
		"uvp",
		"uvvp"
	]
},
	"video/vnd.dece.sd": {
	source: "iana",
	extensions: [
		"uvs",
		"uvvs"
	]
},
	"video/vnd.dece.video": {
	source: "iana",
	extensions: [
		"uvv",
		"uvvv"
	]
},
	"video/vnd.directv.mpeg": {
	source: "iana"
},
	"video/vnd.directv.mpeg-tts": {
	source: "iana"
},
	"video/vnd.dlna.mpeg-tts": {
	source: "iana"
},
	"video/vnd.dvb.file": {
	source: "iana",
	extensions: [
		"dvb"
	]
},
	"video/vnd.fvt": {
	source: "iana",
	extensions: [
		"fvt"
	]
},
	"video/vnd.hns.video": {
	source: "iana"
},
	"video/vnd.iptvforum.1dparityfec-1010": {
	source: "iana"
},
	"video/vnd.iptvforum.1dparityfec-2005": {
	source: "iana"
},
	"video/vnd.iptvforum.2dparityfec-1010": {
	source: "iana"
},
	"video/vnd.iptvforum.2dparityfec-2005": {
	source: "iana"
},
	"video/vnd.iptvforum.ttsavc": {
	source: "iana"
},
	"video/vnd.iptvforum.ttsmpeg2": {
	source: "iana"
},
	"video/vnd.motorola.video": {
	source: "iana"
},
	"video/vnd.motorola.videop": {
	source: "iana"
},
	"video/vnd.mpegurl": {
	source: "iana",
	extensions: [
		"mxu",
		"m4u"
	]
},
	"video/vnd.ms-playready.media.pyv": {
	source: "iana",
	extensions: [
		"pyv"
	]
},
	"video/vnd.nokia.interleaved-multimedia": {
	source: "iana"
},
	"video/vnd.nokia.mp4vr": {
	source: "iana"
},
	"video/vnd.nokia.videovoip": {
	source: "iana"
},
	"video/vnd.objectvideo": {
	source: "iana"
},
	"video/vnd.radgamettools.bink": {
	source: "iana"
},
	"video/vnd.radgamettools.smacker": {
	source: "iana"
},
	"video/vnd.sealed.mpeg1": {
	source: "iana"
},
	"video/vnd.sealed.mpeg4": {
	source: "iana"
},
	"video/vnd.sealed.swf": {
	source: "iana"
},
	"video/vnd.sealedmedia.softseal.mov": {
	source: "iana"
},
	"video/vnd.uvvu.mp4": {
	source: "iana",
	extensions: [
		"uvu",
		"uvvu"
	]
},
	"video/vnd.vivo": {
	source: "iana",
	extensions: [
		"viv"
	]
},
	"video/vnd.youtube.yt": {
	source: "iana"
},
	"video/vp8": {
	source: "iana"
},
	"video/vp9": {
	source: "iana"
},
	"video/webm": {
	source: "apache",
	compressible: false,
	extensions: [
		"webm"
	]
},
	"video/x-f4v": {
	source: "apache",
	extensions: [
		"f4v"
	]
},
	"video/x-fli": {
	source: "apache",
	extensions: [
		"fli"
	]
},
	"video/x-flv": {
	source: "apache",
	compressible: false,
	extensions: [
		"flv"
	]
},
	"video/x-m4v": {
	source: "apache",
	extensions: [
		"m4v"
	]
},
	"video/x-matroska": {
	source: "apache",
	compressible: false,
	extensions: [
		"mkv",
		"mk3d",
		"mks"
	]
},
	"video/x-mng": {
	source: "apache",
	extensions: [
		"mng"
	]
},
	"video/x-ms-asf": {
	source: "apache",
	extensions: [
		"asf",
		"asx"
	]
},
	"video/x-ms-vob": {
	source: "apache",
	extensions: [
		"vob"
	]
},
	"video/x-ms-wm": {
	source: "apache",
	extensions: [
		"wm"
	]
},
	"video/x-ms-wmv": {
	source: "apache",
	compressible: false,
	extensions: [
		"wmv"
	]
},
	"video/x-ms-wmx": {
	source: "apache",
	extensions: [
		"wmx"
	]
},
	"video/x-ms-wvx": {
	source: "apache",
	extensions: [
		"wvx"
	]
},
	"video/x-msvideo": {
	source: "apache",
	extensions: [
		"avi"
	]
},
	"video/x-sgi-movie": {
	source: "apache",
	extensions: [
		"movie"
	]
},
	"video/x-smv": {
	source: "apache",
	extensions: [
		"smv"
	]
},
	"x-conference/x-cooltalk": {
	source: "apache",
	extensions: [
		"ice"
	]
},
	"x-shader/x-fragment": {
	compressible: true
},
	"x-shader/x-vertex": {
	compressible: true
}
};

/*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */

var mimeDb;
var hasRequiredMimeDb;

function requireMimeDb () {
	if (hasRequiredMimeDb) return mimeDb;
	hasRequiredMimeDb = 1;
	/**
	 * Module exports.
	 */

	mimeDb = require$$0$1;
	return mimeDb;
}

/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */

var hasRequiredMimeTypes;

function requireMimeTypes () {
	if (hasRequiredMimeTypes) return mimeTypes;
	hasRequiredMimeTypes = 1;
	(function (exports) {

		/**
		 * Module dependencies.
		 * @private
		 */

		var db = requireMimeDb();
		var extname = require$$1$1.extname;

		/**
		 * Module variables.
		 * @private
		 */

		var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
		var TEXT_TYPE_REGEXP = /^text\//i;

		/**
		 * Module exports.
		 * @public
		 */

		exports.charset = charset;
		exports.charsets = { lookup: charset };
		exports.contentType = contentType;
		exports.extension = extension;
		exports.extensions = Object.create(null);
		exports.lookup = lookup;
		exports.types = Object.create(null);

		// Populate the extensions/types maps
		populateMaps(exports.extensions, exports.types);

		/**
		 * Get the default charset for a MIME type.
		 *
		 * @param {string} type
		 * @return {boolean|string}
		 */

		function charset (type) {
		  if (!type || typeof type !== 'string') {
		    return false
		  }

		  // TODO: use media-typer
		  var match = EXTRACT_TYPE_REGEXP.exec(type);
		  var mime = match && db[match[1].toLowerCase()];

		  if (mime && mime.charset) {
		    return mime.charset
		  }

		  // default text/* to utf-8
		  if (match && TEXT_TYPE_REGEXP.test(match[1])) {
		    return 'UTF-8'
		  }

		  return false
		}

		/**
		 * Create a full Content-Type header given a MIME type or extension.
		 *
		 * @param {string} str
		 * @return {boolean|string}
		 */

		function contentType (str) {
		  // TODO: should this even be in this module?
		  if (!str || typeof str !== 'string') {
		    return false
		  }

		  var mime = str.indexOf('/') === -1
		    ? exports.lookup(str)
		    : str;

		  if (!mime) {
		    return false
		  }

		  // TODO: use content-type or other module
		  if (mime.indexOf('charset') === -1) {
		    var charset = exports.charset(mime);
		    if (charset) mime += '; charset=' + charset.toLowerCase();
		  }

		  return mime
		}

		/**
		 * Get the default extension for a MIME type.
		 *
		 * @param {string} type
		 * @return {boolean|string}
		 */

		function extension (type) {
		  if (!type || typeof type !== 'string') {
		    return false
		  }

		  // TODO: use media-typer
		  var match = EXTRACT_TYPE_REGEXP.exec(type);

		  // get extensions
		  var exts = match && exports.extensions[match[1].toLowerCase()];

		  if (!exts || !exts.length) {
		    return false
		  }

		  return exts[0]
		}

		/**
		 * Lookup the MIME type for a file path/extension.
		 *
		 * @param {string} path
		 * @return {boolean|string}
		 */

		function lookup (path) {
		  if (!path || typeof path !== 'string') {
		    return false
		  }

		  // get the extension ("ext" or ".ext" or full path)
		  var extension = extname('x.' + path)
		    .toLowerCase()
		    .substr(1);

		  if (!extension) {
		    return false
		  }

		  return exports.types[extension] || false
		}

		/**
		 * Populate the extensions and types maps.
		 * @private
		 */

		function populateMaps (extensions, types) {
		  // source preference (least -> most)
		  var preference = ['nginx', 'apache', undefined, 'iana'];

		  Object.keys(db).forEach(function forEachMimeType (type) {
		    var mime = db[type];
		    var exts = mime.extensions;

		    if (!exts || !exts.length) {
		      return
		    }

		    // mime -> extensions
		    extensions[type] = exts;

		    // extension -> mime
		    for (var i = 0; i < exts.length; i++) {
		      var extension = exts[i];

		      if (types[extension]) {
		        var from = preference.indexOf(db[types[extension]].source);
		        var to = preference.indexOf(mime.source);

		        if (types[extension] !== 'application/octet-stream' &&
		          (from > to || (from === to && types[extension].substr(0, 12) === 'application/'))) {
		          // skip the remapping
		          continue
		        }
		      }

		      // set the extension -> mime
		      types[extension] = type;
		    }
		  });
		} 
	} (mimeTypes));
	return mimeTypes;
}

var defer_1;
var hasRequiredDefer;

function requireDefer () {
	if (hasRequiredDefer) return defer_1;
	hasRequiredDefer = 1;
	defer_1 = defer;

	/**
	 * Runs provided function on next iteration of the event loop
	 *
	 * @param {function} fn - function to run
	 */
	function defer(fn)
	{
	  var nextTick = typeof setImmediate == 'function'
	    ? setImmediate
	    : (
	      typeof process == 'object' && typeof process.nextTick == 'function'
	      ? process.nextTick
	      : null
	    );

	  if (nextTick)
	  {
	    nextTick(fn);
	  }
	  else
	  {
	    setTimeout(fn, 0);
	  }
	}
	return defer_1;
}

var async_1;
var hasRequiredAsync;

function requireAsync () {
	if (hasRequiredAsync) return async_1;
	hasRequiredAsync = 1;
	var defer = requireDefer();

	// API
	async_1 = async;

	/**
	 * Runs provided callback asynchronously
	 * even if callback itself is not
	 *
	 * @param   {function} callback - callback to invoke
	 * @returns {function} - augmented callback
	 */
	function async(callback)
	{
	  var isAsync = false;

	  // check if async happened
	  defer(function() { isAsync = true; });

	  return function async_callback(err, result)
	  {
	    if (isAsync)
	    {
	      callback(err, result);
	    }
	    else
	    {
	      defer(function nextTick_callback()
	      {
	        callback(err, result);
	      });
	    }
	  };
	}
	return async_1;
}

var abort_1;
var hasRequiredAbort;

function requireAbort () {
	if (hasRequiredAbort) return abort_1;
	hasRequiredAbort = 1;
	// API
	abort_1 = abort;

	/**
	 * Aborts leftover active jobs
	 *
	 * @param {object} state - current state object
	 */
	function abort(state)
	{
	  Object.keys(state.jobs).forEach(clean.bind(state));

	  // reset leftover jobs
	  state.jobs = {};
	}

	/**
	 * Cleans up leftover job by invoking abort function for the provided job id
	 *
	 * @this  state
	 * @param {string|number} key - job id to abort
	 */
	function clean(key)
	{
	  if (typeof this.jobs[key] == 'function')
	  {
	    this.jobs[key]();
	  }
	}
	return abort_1;
}

var iterate_1;
var hasRequiredIterate;

function requireIterate () {
	if (hasRequiredIterate) return iterate_1;
	hasRequiredIterate = 1;
	var async = requireAsync()
	  , abort = requireAbort()
	  ;

	// API
	iterate_1 = iterate;

	/**
	 * Iterates over each job object
	 *
	 * @param {array|object} list - array or object (named list) to iterate over
	 * @param {function} iterator - iterator to run
	 * @param {object} state - current job status
	 * @param {function} callback - invoked when all elements processed
	 */
	function iterate(list, iterator, state, callback)
	{
	  // store current index
	  var key = state['keyedList'] ? state['keyedList'][state.index] : state.index;

	  state.jobs[key] = runJob(iterator, key, list[key], function(error, output)
	  {
	    // don't repeat yourself
	    // skip secondary callbacks
	    if (!(key in state.jobs))
	    {
	      return;
	    }

	    // clean up jobs
	    delete state.jobs[key];

	    if (error)
	    {
	      // don't process rest of the results
	      // stop still active jobs
	      // and reset the list
	      abort(state);
	    }
	    else
	    {
	      state.results[key] = output;
	    }

	    // return salvaged results
	    callback(error, state.results);
	  });
	}

	/**
	 * Runs iterator over provided job element
	 *
	 * @param   {function} iterator - iterator to invoke
	 * @param   {string|number} key - key/index of the element in the list of jobs
	 * @param   {mixed} item - job description
	 * @param   {function} callback - invoked after iterator is done with the job
	 * @returns {function|mixed} - job abort function or something else
	 */
	function runJob(iterator, key, item, callback)
	{
	  var aborter;

	  // allow shortcut if iterator expects only two arguments
	  if (iterator.length == 2)
	  {
	    aborter = iterator(item, async(callback));
	  }
	  // otherwise go with full three arguments
	  else
	  {
	    aborter = iterator(item, key, async(callback));
	  }

	  return aborter;
	}
	return iterate_1;
}

var state_1;
var hasRequiredState;

function requireState () {
	if (hasRequiredState) return state_1;
	hasRequiredState = 1;
	// API
	state_1 = state;

	/**
	 * Creates initial state object
	 * for iteration over list
	 *
	 * @param   {array|object} list - list to iterate over
	 * @param   {function|null} sortMethod - function to use for keys sort,
	 *                                     or `null` to keep them as is
	 * @returns {object} - initial state object
	 */
	function state(list, sortMethod)
	{
	  var isNamedList = !Array.isArray(list)
	    , initState =
	    {
	      index    : 0,
	      keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
	      jobs     : {},
	      results  : isNamedList ? {} : [],
	      size     : isNamedList ? Object.keys(list).length : list.length
	    }
	    ;

	  if (sortMethod)
	  {
	    // sort array keys based on it's values
	    // sort object's keys just on own merit
	    initState.keyedList.sort(isNamedList ? sortMethod : function(a, b)
	    {
	      return sortMethod(list[a], list[b]);
	    });
	  }

	  return initState;
	}
	return state_1;
}

var terminator_1;
var hasRequiredTerminator;

function requireTerminator () {
	if (hasRequiredTerminator) return terminator_1;
	hasRequiredTerminator = 1;
	var abort = requireAbort()
	  , async = requireAsync()
	  ;

	// API
	terminator_1 = terminator;

	/**
	 * Terminates jobs in the attached state context
	 *
	 * @this  AsyncKitState#
	 * @param {function} callback - final callback to invoke after termination
	 */
	function terminator(callback)
	{
	  if (!Object.keys(this.jobs).length)
	  {
	    return;
	  }

	  // fast forward iteration index
	  this.index = this.size;

	  // abort jobs
	  abort(this);

	  // send back results we have so far
	  async(callback)(null, this.results);
	}
	return terminator_1;
}

var parallel_1;
var hasRequiredParallel;

function requireParallel () {
	if (hasRequiredParallel) return parallel_1;
	hasRequiredParallel = 1;
	var iterate    = requireIterate()
	  , initState  = requireState()
	  , terminator = requireTerminator()
	  ;

	// Public API
	parallel_1 = parallel;

	/**
	 * Runs iterator over provided array elements in parallel
	 *
	 * @param   {array|object} list - array or object (named list) to iterate over
	 * @param   {function} iterator - iterator to run
	 * @param   {function} callback - invoked when all elements processed
	 * @returns {function} - jobs terminator
	 */
	function parallel(list, iterator, callback)
	{
	  var state = initState(list);

	  while (state.index < (state['keyedList'] || list).length)
	  {
	    iterate(list, iterator, state, function(error, result)
	    {
	      if (error)
	      {
	        callback(error, result);
	        return;
	      }

	      // looks like it's the last one
	      if (Object.keys(state.jobs).length === 0)
	      {
	        callback(null, state.results);
	        return;
	      }
	    });

	    state.index++;
	  }

	  return terminator.bind(state, callback);
	}
	return parallel_1;
}

var serialOrdered = {exports: {}};

var hasRequiredSerialOrdered;

function requireSerialOrdered () {
	if (hasRequiredSerialOrdered) return serialOrdered.exports;
	hasRequiredSerialOrdered = 1;
	var iterate    = requireIterate()
	  , initState  = requireState()
	  , terminator = requireTerminator()
	  ;

	// Public API
	serialOrdered.exports = serialOrdered$1;
	// sorting helpers
	serialOrdered.exports.ascending  = ascending;
	serialOrdered.exports.descending = descending;

	/**
	 * Runs iterator over provided sorted array elements in series
	 *
	 * @param   {array|object} list - array or object (named list) to iterate over
	 * @param   {function} iterator - iterator to run
	 * @param   {function} sortMethod - custom sort function
	 * @param   {function} callback - invoked when all elements processed
	 * @returns {function} - jobs terminator
	 */
	function serialOrdered$1(list, iterator, sortMethod, callback)
	{
	  var state = initState(list, sortMethod);

	  iterate(list, iterator, state, function iteratorHandler(error, result)
	  {
	    if (error)
	    {
	      callback(error, result);
	      return;
	    }

	    state.index++;

	    // are we there yet?
	    if (state.index < (state['keyedList'] || list).length)
	    {
	      iterate(list, iterator, state, iteratorHandler);
	      return;
	    }

	    // done here
	    callback(null, state.results);
	  });

	  return terminator.bind(state, callback);
	}

	/*
	 * -- Sort methods
	 */

	/**
	 * sort helper to sort array elements in ascending order
	 *
	 * @param   {mixed} a - an item to compare
	 * @param   {mixed} b - an item to compare
	 * @returns {number} - comparison result
	 */
	function ascending(a, b)
	{
	  return a < b ? -1 : a > b ? 1 : 0;
	}

	/**
	 * sort helper to sort array elements in descending order
	 *
	 * @param   {mixed} a - an item to compare
	 * @param   {mixed} b - an item to compare
	 * @returns {number} - comparison result
	 */
	function descending(a, b)
	{
	  return -1 * ascending(a, b);
	}
	return serialOrdered.exports;
}

var serial_1;
var hasRequiredSerial;

function requireSerial () {
	if (hasRequiredSerial) return serial_1;
	hasRequiredSerial = 1;
	var serialOrdered = requireSerialOrdered();

	// Public API
	serial_1 = serial;

	/**
	 * Runs iterator over provided array elements in series
	 *
	 * @param   {array|object} list - array or object (named list) to iterate over
	 * @param   {function} iterator - iterator to run
	 * @param   {function} callback - invoked when all elements processed
	 * @returns {function} - jobs terminator
	 */
	function serial(list, iterator, callback)
	{
	  return serialOrdered(list, iterator, null, callback);
	}
	return serial_1;
}

var asynckit;
var hasRequiredAsynckit;

function requireAsynckit () {
	if (hasRequiredAsynckit) return asynckit;
	hasRequiredAsynckit = 1;
	asynckit =
	{
	  parallel      : requireParallel(),
	  serial        : requireSerial(),
	  serialOrdered : requireSerialOrdered()
	};
	return asynckit;
}

var populate;
var hasRequiredPopulate;

function requirePopulate () {
	if (hasRequiredPopulate) return populate;
	hasRequiredPopulate = 1;
	// populates missing values
	populate = function(dst, src) {

	  Object.keys(src).forEach(function(prop)
	  {
	    dst[prop] = dst[prop] || src[prop];
	  });

	  return dst;
	};
	return populate;
}

var form_data;
var hasRequiredForm_data;

function requireForm_data () {
	if (hasRequiredForm_data) return form_data;
	hasRequiredForm_data = 1;
	var CombinedStream = requireCombined_stream();
	var util = require$$1;
	var path = require$$1$1;
	var http = require$$0$2;
	var https = require$$2;
	var parseUrl = require$$5.parse;
	var fs$1 = fs;
	var Stream = stream.Stream;
	var mime = requireMimeTypes();
	var asynckit = requireAsynckit();
	var populate = requirePopulate();

	// Public API
	form_data = FormData;

	// make it a Stream
	util.inherits(FormData, CombinedStream);

	/**
	 * Create readable "multipart/form-data" streams.
	 * Can be used to submit forms
	 * and file uploads to other web applications.
	 *
	 * @constructor
	 * @param {Object} options - Properties to be added/overriden for FormData and CombinedStream
	 */
	function FormData(options) {
	  if (!(this instanceof FormData)) {
	    return new FormData(options);
	  }

	  this._overheadLength = 0;
	  this._valueLength = 0;
	  this._valuesToMeasure = [];

	  CombinedStream.call(this);

	  options = options || {};
	  for (var option in options) {
	    this[option] = options[option];
	  }
	}

	FormData.LINE_BREAK = '\r\n';
	FormData.DEFAULT_CONTENT_TYPE = 'application/octet-stream';

	FormData.prototype.append = function(field, value, options) {

	  options = options || {};

	  // allow filename as single option
	  if (typeof options == 'string') {
	    options = {filename: options};
	  }

	  var append = CombinedStream.prototype.append.bind(this);

	  // all that streamy business can't handle numbers
	  if (typeof value == 'number') {
	    value = '' + value;
	  }

	  // https://github.com/felixge/node-form-data/issues/38
	  if (Array.isArray(value)) {
	    // Please convert your array into string
	    // the way web server expects it
	    this._error(new Error('Arrays are not supported.'));
	    return;
	  }

	  var header = this._multiPartHeader(field, value, options);
	  var footer = this._multiPartFooter();

	  append(header);
	  append(value);
	  append(footer);

	  // pass along options.knownLength
	  this._trackLength(header, value, options);
	};

	FormData.prototype._trackLength = function(header, value, options) {
	  var valueLength = 0;

	  // used w/ getLengthSync(), when length is known.
	  // e.g. for streaming directly from a remote server,
	  // w/ a known file a size, and not wanting to wait for
	  // incoming file to finish to get its size.
	  if (options.knownLength != null) {
	    valueLength += +options.knownLength;
	  } else if (Buffer.isBuffer(value)) {
	    valueLength = value.length;
	  } else if (typeof value === 'string') {
	    valueLength = Buffer.byteLength(value);
	  }

	  this._valueLength += valueLength;

	  // @check why add CRLF? does this account for custom/multiple CRLFs?
	  this._overheadLength +=
	    Buffer.byteLength(header) +
	    FormData.LINE_BREAK.length;

	  // empty or either doesn't have path or not an http response or not a stream
	  if (!value || ( !value.path && !(value.readable && value.hasOwnProperty('httpVersion')) && !(value instanceof Stream))) {
	    return;
	  }

	  // no need to bother with the length
	  if (!options.knownLength) {
	    this._valuesToMeasure.push(value);
	  }
	};

	FormData.prototype._lengthRetriever = function(value, callback) {

	  if (value.hasOwnProperty('fd')) {

	    // take read range into a account
	    // `end` = Infinity > read file till the end
	    //
	    // TODO: Looks like there is bug in Node fs.createReadStream
	    // it doesn't respect `end` options without `start` options
	    // Fix it when node fixes it.
	    // https://github.com/joyent/node/issues/7819
	    if (value.end != undefined && value.end != Infinity && value.start != undefined) {

	      // when end specified
	      // no need to calculate range
	      // inclusive, starts with 0
	      callback(null, value.end + 1 - (value.start ? value.start : 0));

	    // not that fast snoopy
	    } else {
	      // still need to fetch file size from fs
	      fs$1.stat(value.path, function(err, stat) {

	        var fileSize;

	        if (err) {
	          callback(err);
	          return;
	        }

	        // update final size based on the range options
	        fileSize = stat.size - (value.start ? value.start : 0);
	        callback(null, fileSize);
	      });
	    }

	  // or http response
	  } else if (value.hasOwnProperty('httpVersion')) {
	    callback(null, +value.headers['content-length']);

	  // or request stream http://github.com/mikeal/request
	  } else if (value.hasOwnProperty('httpModule')) {
	    // wait till response come back
	    value.on('response', function(response) {
	      value.pause();
	      callback(null, +response.headers['content-length']);
	    });
	    value.resume();

	  // something else
	  } else {
	    callback('Unknown stream');
	  }
	};

	FormData.prototype._multiPartHeader = function(field, value, options) {
	  // custom header specified (as string)?
	  // it becomes responsible for boundary
	  // (e.g. to handle extra CRLFs on .NET servers)
	  if (typeof options.header == 'string') {
	    return options.header;
	  }

	  var contentDisposition = this._getContentDisposition(value, options);
	  var contentType = this._getContentType(value, options);

	  var contents = '';
	  var headers  = {
	    // add custom disposition as third element or keep it two elements if not
	    'Content-Disposition': ['form-data', 'name="' + field + '"'].concat(contentDisposition || []),
	    // if no content type. allow it to be empty array
	    'Content-Type': [].concat(contentType || [])
	  };

	  // allow custom headers.
	  if (typeof options.header == 'object') {
	    populate(headers, options.header);
	  }

	  var header;
	  for (var prop in headers) {
	    if (!headers.hasOwnProperty(prop)) continue;
	    header = headers[prop];

	    // skip nullish headers.
	    if (header == null) {
	      continue;
	    }

	    // convert all headers to arrays.
	    if (!Array.isArray(header)) {
	      header = [header];
	    }

	    // add non-empty headers.
	    if (header.length) {
	      contents += prop + ': ' + header.join('; ') + FormData.LINE_BREAK;
	    }
	  }

	  return '--' + this.getBoundary() + FormData.LINE_BREAK + contents + FormData.LINE_BREAK;
	};

	FormData.prototype._getContentDisposition = function(value, options) {

	  var filename
	    , contentDisposition
	    ;

	  if (typeof options.filepath === 'string') {
	    // custom filepath for relative paths
	    filename = path.normalize(options.filepath).replace(/\\/g, '/');
	  } else if (options.filename || value.name || value.path) {
	    // custom filename take precedence
	    // formidable and the browser add a name property
	    // fs- and request- streams have path property
	    filename = path.basename(options.filename || value.name || value.path);
	  } else if (value.readable && value.hasOwnProperty('httpVersion')) {
	    // or try http response
	    filename = path.basename(value.client._httpMessage.path || '');
	  }

	  if (filename) {
	    contentDisposition = 'filename="' + filename + '"';
	  }

	  return contentDisposition;
	};

	FormData.prototype._getContentType = function(value, options) {

	  // use custom content-type above all
	  var contentType = options.contentType;

	  // or try `name` from formidable, browser
	  if (!contentType && value.name) {
	    contentType = mime.lookup(value.name);
	  }

	  // or try `path` from fs-, request- streams
	  if (!contentType && value.path) {
	    contentType = mime.lookup(value.path);
	  }

	  // or if it's http-reponse
	  if (!contentType && value.readable && value.hasOwnProperty('httpVersion')) {
	    contentType = value.headers['content-type'];
	  }

	  // or guess it from the filepath or filename
	  if (!contentType && (options.filepath || options.filename)) {
	    contentType = mime.lookup(options.filepath || options.filename);
	  }

	  // fallback to the default content type if `value` is not simple value
	  if (!contentType && typeof value == 'object') {
	    contentType = FormData.DEFAULT_CONTENT_TYPE;
	  }

	  return contentType;
	};

	FormData.prototype._multiPartFooter = function() {
	  return function(next) {
	    var footer = FormData.LINE_BREAK;

	    var lastPart = (this._streams.length === 0);
	    if (lastPart) {
	      footer += this._lastBoundary();
	    }

	    next(footer);
	  }.bind(this);
	};

	FormData.prototype._lastBoundary = function() {
	  return '--' + this.getBoundary() + '--' + FormData.LINE_BREAK;
	};

	FormData.prototype.getHeaders = function(userHeaders) {
	  var header;
	  var formHeaders = {
	    'content-type': 'multipart/form-data; boundary=' + this.getBoundary()
	  };

	  for (header in userHeaders) {
	    if (userHeaders.hasOwnProperty(header)) {
	      formHeaders[header.toLowerCase()] = userHeaders[header];
	    }
	  }

	  return formHeaders;
	};

	FormData.prototype.setBoundary = function(boundary) {
	  this._boundary = boundary;
	};

	FormData.prototype.getBoundary = function() {
	  if (!this._boundary) {
	    this._generateBoundary();
	  }

	  return this._boundary;
	};

	FormData.prototype.getBuffer = function() {
	  var dataBuffer = new Buffer.alloc( 0 );
	  var boundary = this.getBoundary();

	  // Create the form content. Add Line breaks to the end of data.
	  for (var i = 0, len = this._streams.length; i < len; i++) {
	    if (typeof this._streams[i] !== 'function') {

	      // Add content to the buffer.
	      if(Buffer.isBuffer(this._streams[i])) {
	        dataBuffer = Buffer.concat( [dataBuffer, this._streams[i]]);
	      }else {
	        dataBuffer = Buffer.concat( [dataBuffer, Buffer.from(this._streams[i])]);
	      }

	      // Add break after content.
	      if (typeof this._streams[i] !== 'string' || this._streams[i].substring( 2, boundary.length + 2 ) !== boundary) {
	        dataBuffer = Buffer.concat( [dataBuffer, Buffer.from(FormData.LINE_BREAK)] );
	      }
	    }
	  }

	  // Add the footer and return the Buffer object.
	  return Buffer.concat( [dataBuffer, Buffer.from(this._lastBoundary())] );
	};

	FormData.prototype._generateBoundary = function() {
	  // This generates a 50 character boundary similar to those used by Firefox.
	  // They are optimized for boyer-moore parsing.
	  var boundary = '--------------------------';
	  for (var i = 0; i < 24; i++) {
	    boundary += Math.floor(Math.random() * 10).toString(16);
	  }

	  this._boundary = boundary;
	};

	// Note: getLengthSync DOESN'T calculate streams length
	// As workaround one can calculate file size manually
	// and add it as knownLength option
	FormData.prototype.getLengthSync = function() {
	  var knownLength = this._overheadLength + this._valueLength;

	  // Don't get confused, there are 3 "internal" streams for each keyval pair
	  // so it basically checks if there is any value added to the form
	  if (this._streams.length) {
	    knownLength += this._lastBoundary().length;
	  }

	  // https://github.com/form-data/form-data/issues/40
	  if (!this.hasKnownLength()) {
	    // Some async length retrievers are present
	    // therefore synchronous length calculation is false.
	    // Please use getLength(callback) to get proper length
	    this._error(new Error('Cannot calculate proper length in synchronous way.'));
	  }

	  return knownLength;
	};

	// Public API to check if length of added values is known
	// https://github.com/form-data/form-data/issues/196
	// https://github.com/form-data/form-data/issues/262
	FormData.prototype.hasKnownLength = function() {
	  var hasKnownLength = true;

	  if (this._valuesToMeasure.length) {
	    hasKnownLength = false;
	  }

	  return hasKnownLength;
	};

	FormData.prototype.getLength = function(cb) {
	  var knownLength = this._overheadLength + this._valueLength;

	  if (this._streams.length) {
	    knownLength += this._lastBoundary().length;
	  }

	  if (!this._valuesToMeasure.length) {
	    process.nextTick(cb.bind(this, null, knownLength));
	    return;
	  }

	  asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
	    if (err) {
	      cb(err);
	      return;
	    }

	    values.forEach(function(length) {
	      knownLength += length;
	    });

	    cb(null, knownLength);
	  });
	};

	FormData.prototype.submit = function(params, cb) {
	  var request
	    , options
	    , defaults = {method: 'post'}
	    ;

	  // parse provided url if it's string
	  // or treat it as options object
	  if (typeof params == 'string') {

	    params = parseUrl(params);
	    options = populate({
	      port: params.port,
	      path: params.pathname,
	      host: params.hostname,
	      protocol: params.protocol
	    }, defaults);

	  // use custom params
	  } else {

	    options = populate(params, defaults);
	    // if no port provided use default one
	    if (!options.port) {
	      options.port = options.protocol == 'https:' ? 443 : 80;
	    }
	  }

	  // put that good code in getHeaders to some use
	  options.headers = this.getHeaders(params.headers);

	  // https if specified, fallback to http in any other case
	  if (options.protocol == 'https:') {
	    request = https.request(options);
	  } else {
	    request = http.request(options);
	  }

	  // get content length and fire away
	  this.getLength(function(err, length) {
	    if (err && err !== 'Unknown stream') {
	      this._error(err);
	      return;
	    }

	    // add content length
	    if (length) {
	      request.setHeader('Content-Length', length);
	    }

	    this.pipe(request);
	    if (cb) {
	      var onResponse;

	      var callback = function (error, responce) {
	        request.removeListener('error', callback);
	        request.removeListener('response', onResponse);

	        return cb.call(this, error, responce);
	      };

	      onResponse = callback.bind(this, null);

	      request.on('error', callback);
	      request.on('response', onResponse);
	    }
	  }.bind(this));

	  return request;
	};

	FormData.prototype._error = function(err) {
	  if (!this.error) {
	    this.error = err;
	    this.pause();
	    this.emit('error', err);
	  }
	};

	FormData.prototype.toString = function () {
	  return '[object FormData]';
	};
	return form_data;
}

var form_dataExports = requireForm_data();
var FormData$1 = /*@__PURE__*/getDefaultExportFromCjs(form_dataExports);

/**
 * Determines if the given thing is a array or js object.
 *
 * @param {string} thing - The object or array to be visited.
 *
 * @returns {boolean}
 */
function isVisitable(thing) {
  return utils$2.isPlainObject(thing) || utils$2.isArray(thing);
}

/**
 * It removes the brackets from the end of a string
 *
 * @param {string} key - The key of the parameter.
 *
 * @returns {string} the key without the brackets.
 */
function removeBrackets(key) {
  return utils$2.endsWith(key, '[]') ? key.slice(0, -2) : key;
}

/**
 * It takes a path, a key, and a boolean, and returns a string
 *
 * @param {string} path - The path to the current key.
 * @param {string} key - The key of the current object being iterated over.
 * @param {string} dots - If true, the key will be rendered with dots instead of brackets.
 *
 * @returns {string} The path to the current key.
 */
function renderKey(path, key, dots) {
  if (!path) return key;
  return path.concat(key).map(function each(token, i) {
    // eslint-disable-next-line no-param-reassign
    token = removeBrackets(token);
    return !dots && i ? '[' + token + ']' : token;
  }).join(dots ? '.' : '');
}

/**
 * If the array is an array and none of its elements are visitable, then it's a flat array.
 *
 * @param {Array<any>} arr - The array to check
 *
 * @returns {boolean}
 */
function isFlatArray(arr) {
  return utils$2.isArray(arr) && !arr.some(isVisitable);
}

const predicates = utils$2.toFlatObject(utils$2, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});

/**
 * Convert a data object to FormData
 *
 * @param {Object} obj
 * @param {?Object} [formData]
 * @param {?Object} [options]
 * @param {Function} [options.visitor]
 * @param {Boolean} [options.metaTokens = true]
 * @param {Boolean} [options.dots = false]
 * @param {?Boolean} [options.indexes = false]
 *
 * @returns {Object}
 **/

/**
 * It converts an object into a FormData object
 *
 * @param {Object<any, any>} obj - The object to convert to form data.
 * @param {string} formData - The FormData object to append to.
 * @param {Object<string, any>} options
 *
 * @returns
 */
function toFormData(obj, formData, options) {
  if (!utils$2.isObject(obj)) {
    throw new TypeError('target must be an object');
  }

  // eslint-disable-next-line no-param-reassign
  formData = formData || new (FormData$1 || FormData)();

  // eslint-disable-next-line no-param-reassign
  options = utils$2.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    // eslint-disable-next-line no-eq-null,eqeqeq
    return !utils$2.isUndefined(source[option]);
  });

  const metaTokens = options.metaTokens;
  // eslint-disable-next-line no-use-before-define
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== 'undefined' && Blob;
  const useBlob = _Blob && utils$2.isSpecCompliantForm(formData);

  if (!utils$2.isFunction(visitor)) {
    throw new TypeError('visitor must be a function');
  }

  function convertValue(value) {
    if (value === null) return '';

    if (utils$2.isDate(value)) {
      return value.toISOString();
    }

    if (!useBlob && utils$2.isBlob(value)) {
      throw new AxiosError('Blob is not supported. Use a Buffer instead.');
    }

    if (utils$2.isArrayBuffer(value) || utils$2.isTypedArray(value)) {
      return useBlob && typeof Blob === 'function' ? new Blob([value]) : Buffer.from(value);
    }

    return value;
  }

  /**
   * Default visitor.
   *
   * @param {*} value
   * @param {String|Number} key
   * @param {Array<String|Number>} path
   * @this {FormData}
   *
   * @returns {boolean} return true to visit the each prop of the value recursively
   */
  function defaultVisitor(value, key, path) {
    let arr = value;

    if (value && !path && typeof value === 'object') {
      if (utils$2.endsWith(key, '{}')) {
        // eslint-disable-next-line no-param-reassign
        key = metaTokens ? key : key.slice(0, -2);
        // eslint-disable-next-line no-param-reassign
        value = JSON.stringify(value);
      } else if (
        (utils$2.isArray(value) && isFlatArray(value)) ||
        ((utils$2.isFileList(value) || utils$2.endsWith(key, '[]')) && (arr = utils$2.toArray(value))
        )) {
        // eslint-disable-next-line no-param-reassign
        key = removeBrackets(key);

        arr.forEach(function each(el, index) {
          !(utils$2.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index, dots) : (indexes === null ? key : key + '[]'),
            convertValue(el)
          );
        });
        return false;
      }
    }

    if (isVisitable(value)) {
      return true;
    }

    formData.append(renderKey(path, key, dots), convertValue(value));

    return false;
  }

  const stack = [];

  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });

  function build(value, path) {
    if (utils$2.isUndefined(value)) return;

    if (stack.indexOf(value) !== -1) {
      throw Error('Circular reference detected in ' + path.join('.'));
    }

    stack.push(value);

    utils$2.forEach(value, function each(el, key) {
      const result = !(utils$2.isUndefined(el) || el === null) && visitor.call(
        formData, el, utils$2.isString(key) ? key.trim() : key, path, exposedHelpers
      );

      if (result === true) {
        build(el, path ? path.concat(key) : [key]);
      }
    });

    stack.pop();
  }

  if (!utils$2.isObject(obj)) {
    throw new TypeError('data must be an object');
  }

  build(obj);

  return formData;
}

/**
 * It encodes a string by replacing all characters that are not in the unreserved set with
 * their percent-encoded equivalents
 *
 * @param {string} str - The string to encode.
 *
 * @returns {string} The encoded string.
 */
function encode$1(str) {
  const charMap = {
    '!': '%21',
    "'": '%27',
    '(': '%28',
    ')': '%29',
    '~': '%7E',
    '%20': '+',
    '%00': '\x00'
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}

/**
 * It takes a params object and converts it to a FormData object
 *
 * @param {Object<string, any>} params - The parameters to be converted to a FormData object.
 * @param {Object<string, any>} options - The options object passed to the Axios constructor.
 *
 * @returns {void}
 */
function AxiosURLSearchParams(params, options) {
  this._pairs = [];

  params && toFormData(params, this, options);
}

const prototype = AxiosURLSearchParams.prototype;

prototype.append = function append(name, value) {
  this._pairs.push([name, value]);
};

prototype.toString = function toString(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode$1);
  } : encode$1;

  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + '=' + _encode(pair[1]);
  }, '').join('&');
};

/**
 * It replaces all instances of the characters `:`, `$`, `,`, `+`, `[`, and `]` with their
 * URI encoded counterparts
 *
 * @param {string} val The value to be encoded.
 *
 * @returns {string} The encoded value.
 */
function encode(val) {
  return encodeURIComponent(val).
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @param {?object} options
 *
 * @returns {string} The formatted url
 */
function buildURL(url, params, options) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }
  
  const _encode = options && options.encode || encode;

  const serializeFn = options && options.serialize;

  let serializedParams;

  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils$2.isURLSearchParams(params) ?
      params.toString() :
      new AxiosURLSearchParams(params, options).toString(_encode);
  }

  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");

    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
}

class InterceptorManager {
  constructor() {
    this.handlers = [];
  }

  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }

  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }

  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }

  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils$2.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  }
}

var InterceptorManager$1 = InterceptorManager;

var transitionalDefaults = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};

var URLSearchParams = require$$5.URLSearchParams;

var platform$1 = {
  isNode: true,
  classes: {
    URLSearchParams,
    FormData: FormData$1,
    Blob: typeof Blob !== 'undefined' && Blob || null
  },
  protocols: [ 'http', 'https', 'file', 'data' ]
};

const hasBrowserEnv = typeof window !== 'undefined' && typeof document !== 'undefined';

const _navigator = typeof navigator === 'object' && navigator || undefined;

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 *
 * @returns {boolean}
 */
const hasStandardBrowserEnv = hasBrowserEnv &&
  (!_navigator || ['ReactNative', 'NativeScript', 'NS'].indexOf(_navigator.product) < 0);

/**
 * Determine if we're running in a standard browser webWorker environment
 *
 * Although the `isStandardBrowserEnv` method indicates that
 * `allows axios to run in a web worker`, the WebWorker will still be
 * filtered out due to its judgment standard
 * `typeof window !== 'undefined' && typeof document !== 'undefined'`.
 * This leads to a problem when axios post `FormData` in webWorker
 */
const hasStandardBrowserWebWorkerEnv = (() => {
  return (
    typeof WorkerGlobalScope !== 'undefined' &&
    // eslint-disable-next-line no-undef
    self instanceof WorkerGlobalScope &&
    typeof self.importScripts === 'function'
  );
})();

const origin = hasBrowserEnv && window.location.href || 'http://localhost';

var utils$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    hasBrowserEnv: hasBrowserEnv,
    hasStandardBrowserEnv: hasStandardBrowserEnv,
    hasStandardBrowserWebWorkerEnv: hasStandardBrowserWebWorkerEnv,
    navigator: _navigator,
    origin: origin
});

var platform = {
  ...utils$1,
  ...platform$1
};

function toURLEncodedForm(data, options) {
  return toFormData(data, new platform.classes.URLSearchParams(), Object.assign({
    visitor: function(value, key, path, helpers) {
      if (platform.isNode && utils$2.isBuffer(value)) {
        this.append(key, value.toString('base64'));
        return false;
      }

      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}

/**
 * It takes a string like `foo[x][y][z]` and returns an array like `['foo', 'x', 'y', 'z']
 *
 * @param {string} name - The name of the property to get.
 *
 * @returns An array of strings.
 */
function parsePropPath(name) {
  // foo[x][y][z]
  // foo.x.y.z
  // foo-x-y-z
  // foo x y z
  return utils$2.matchAll(/\w+|\[(\w*)]/g, name).map(match => {
    return match[0] === '[]' ? '' : match[1] || match[0];
  });
}

/**
 * Convert an array to an object.
 *
 * @param {Array<any>} arr - The array to convert to an object.
 *
 * @returns An object with the same keys and values as the array.
 */
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i;
  const len = keys.length;
  let key;
  for (i = 0; i < len; i++) {
    key = keys[i];
    obj[key] = arr[key];
  }
  return obj;
}

/**
 * It takes a FormData object and returns a JavaScript object
 *
 * @param {string} formData The FormData object to convert to JSON.
 *
 * @returns {Object<string, any> | null} The converted object.
 */
function formDataToJSON(formData) {
  function buildPath(path, value, target, index) {
    let name = path[index++];

    if (name === '__proto__') return true;

    const isNumericKey = Number.isFinite(+name);
    const isLast = index >= path.length;
    name = !name && utils$2.isArray(target) ? target.length : name;

    if (isLast) {
      if (utils$2.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }

      return !isNumericKey;
    }

    if (!target[name] || !utils$2.isObject(target[name])) {
      target[name] = [];
    }

    const result = buildPath(path, value, target[name], index);

    if (result && utils$2.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }

    return !isNumericKey;
  }

  if (utils$2.isFormData(formData) && utils$2.isFunction(formData.entries)) {
    const obj = {};

    utils$2.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });

    return obj;
  }

  return null;
}

/**
 * It takes a string, tries to parse it, and if it fails, it returns the stringified version
 * of the input
 *
 * @param {any} rawValue - The value to be stringified.
 * @param {Function} parser - A function that parses a string into a JavaScript object.
 * @param {Function} encoder - A function that takes a value and returns a string.
 *
 * @returns {string} A stringified version of the rawValue.
 */
function stringifySafely(rawValue, parser, encoder) {
  if (utils$2.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils$2.trim(rawValue);
    } catch (e) {
      if (e.name !== 'SyntaxError') {
        throw e;
      }
    }
  }

  return (encoder || JSON.stringify)(rawValue);
}

const defaults$1 = {

  transitional: transitionalDefaults,

  adapter: ['xhr', 'http', 'fetch'],

  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || '';
    const hasJSONContentType = contentType.indexOf('application/json') > -1;
    const isObjectPayload = utils$2.isObject(data);

    if (isObjectPayload && utils$2.isHTMLForm(data)) {
      data = new FormData(data);
    }

    const isFormData = utils$2.isFormData(data);

    if (isFormData) {
      return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
    }

    if (utils$2.isArrayBuffer(data) ||
      utils$2.isBuffer(data) ||
      utils$2.isStream(data) ||
      utils$2.isFile(data) ||
      utils$2.isBlob(data) ||
      utils$2.isReadableStream(data)
    ) {
      return data;
    }
    if (utils$2.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils$2.isURLSearchParams(data)) {
      headers.setContentType('application/x-www-form-urlencoded;charset=utf-8', false);
      return data.toString();
    }

    let isFileList;

    if (isObjectPayload) {
      if (contentType.indexOf('application/x-www-form-urlencoded') > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }

      if ((isFileList = utils$2.isFileList(data)) || contentType.indexOf('multipart/form-data') > -1) {
        const _FormData = this.env && this.env.FormData;

        return toFormData(
          isFileList ? {'files[]': data} : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }

    if (isObjectPayload || hasJSONContentType ) {
      headers.setContentType('application/json', false);
      return stringifySafely(data);
    }

    return data;
  }],

  transformResponse: [function transformResponse(data) {
    const transitional = this.transitional || defaults$1.transitional;
    const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
    const JSONRequested = this.responseType === 'json';

    if (utils$2.isResponse(data) || utils$2.isReadableStream(data)) {
      return data;
    }

    if (data && utils$2.isString(data) && ((forcedJSONParsing && !this.responseType) || JSONRequested)) {
      const silentJSONParsing = transitional && transitional.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;

      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === 'SyntaxError') {
            throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }

    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,
  maxBodyLength: -1,

  env: {
    FormData: platform.classes.FormData,
    Blob: platform.classes.Blob
  },

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },

  headers: {
    common: {
      'Accept': 'application/json, text/plain, */*',
      'Content-Type': undefined
    }
  }
};

utils$2.forEach(['delete', 'get', 'head', 'post', 'put', 'patch'], (method) => {
  defaults$1.headers[method] = {};
});

var defaults$2 = defaults$1;

// RawAxiosHeaders whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
const ignoreDuplicateOf = utils$2.toObjectSet([
  'age', 'authorization', 'content-length', 'content-type', 'etag',
  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  'referer', 'retry-after', 'user-agent'
]);

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} rawHeaders Headers needing to be parsed
 *
 * @returns {Object} Headers parsed into an object
 */
var parseHeaders = rawHeaders => {
  const parsed = {};
  let key;
  let val;
  let i;

  rawHeaders && rawHeaders.split('\n').forEach(function parser(line) {
    i = line.indexOf(':');
    key = line.substring(0, i).trim().toLowerCase();
    val = line.substring(i + 1).trim();

    if (!key || (parsed[key] && ignoreDuplicateOf[key])) {
      return;
    }

    if (key === 'set-cookie') {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
    }
  });

  return parsed;
};

const $internals = Symbol('internals');

function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}

function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }

  return utils$2.isArray(value) ? value.map(normalizeValue) : String(value);
}

function parseTokens(str) {
  const tokens = Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;

  while ((match = tokensRE.exec(str))) {
    tokens[match[1]] = match[2];
  }

  return tokens;
}

const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());

function matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
  if (utils$2.isFunction(filter)) {
    return filter.call(this, value, header);
  }

  if (isHeaderNameFilter) {
    value = header;
  }

  if (!utils$2.isString(value)) return;

  if (utils$2.isString(filter)) {
    return value.indexOf(filter) !== -1;
  }

  if (utils$2.isRegExp(filter)) {
    return filter.test(value);
  }
}

function formatHeader(header) {
  return header.trim()
    .toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
      return char.toUpperCase() + str;
    });
}

function buildAccessors(obj, header) {
  const accessorName = utils$2.toCamelCase(' ' + header);

  ['get', 'set', 'has'].forEach(methodName => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}

class AxiosHeaders {
  constructor(headers) {
    headers && this.set(headers);
  }

  set(header, valueOrRewrite, rewrite) {
    const self = this;

    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);

      if (!lHeader) {
        throw new Error('header name must be a non-empty string');
      }

      const key = utils$2.findKey(self, lHeader);

      if(!key || self[key] === undefined || _rewrite === true || (_rewrite === undefined && self[key] !== false)) {
        self[key || _header] = normalizeValue(_value);
      }
    }

    const setHeaders = (headers, _rewrite) =>
      utils$2.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));

    if (utils$2.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if(utils$2.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders(header), valueOrRewrite);
    } else if (utils$2.isHeaders(header)) {
      for (const [key, value] of header.entries()) {
        setHeader(value, key, rewrite);
      }
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }

    return this;
  }

  get(header, parser) {
    header = normalizeHeader(header);

    if (header) {
      const key = utils$2.findKey(this, header);

      if (key) {
        const value = this[key];

        if (!parser) {
          return value;
        }

        if (parser === true) {
          return parseTokens(value);
        }

        if (utils$2.isFunction(parser)) {
          return parser.call(this, value, key);
        }

        if (utils$2.isRegExp(parser)) {
          return parser.exec(value);
        }

        throw new TypeError('parser must be boolean|regexp|function');
      }
    }
  }

  has(header, matcher) {
    header = normalizeHeader(header);

    if (header) {
      const key = utils$2.findKey(this, header);

      return !!(key && this[key] !== undefined && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }

    return false;
  }

  delete(header, matcher) {
    const self = this;
    let deleted = false;

    function deleteHeader(_header) {
      _header = normalizeHeader(_header);

      if (_header) {
        const key = utils$2.findKey(self, _header);

        if (key && (!matcher || matchHeaderValue(self, self[key], key, matcher))) {
          delete self[key];

          deleted = true;
        }
      }
    }

    if (utils$2.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }

    return deleted;
  }

  clear(matcher) {
    const keys = Object.keys(this);
    let i = keys.length;
    let deleted = false;

    while (i--) {
      const key = keys[i];
      if(!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }

    return deleted;
  }

  normalize(format) {
    const self = this;
    const headers = {};

    utils$2.forEach(this, (value, header) => {
      const key = utils$2.findKey(headers, header);

      if (key) {
        self[key] = normalizeValue(value);
        delete self[header];
        return;
      }

      const normalized = format ? formatHeader(header) : String(header).trim();

      if (normalized !== header) {
        delete self[header];
      }

      self[normalized] = normalizeValue(value);

      headers[normalized] = true;
    });

    return this;
  }

  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }

  toJSON(asStrings) {
    const obj = Object.create(null);

    utils$2.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils$2.isArray(value) ? value.join(', ') : value);
    });

    return obj;
  }

  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }

  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ': ' + value).join('\n');
  }

  get [Symbol.toStringTag]() {
    return 'AxiosHeaders';
  }

  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }

  static concat(first, ...targets) {
    const computed = new this(first);

    targets.forEach((target) => computed.set(target));

    return computed;
  }

  static accessor(header) {
    const internals = this[$internals] = (this[$internals] = {
      accessors: {}
    });

    const accessors = internals.accessors;
    const prototype = this.prototype;

    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);

      if (!accessors[lHeader]) {
        buildAccessors(prototype, _header);
        accessors[lHeader] = true;
      }
    }

    utils$2.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);

    return this;
  }
}

AxiosHeaders.accessor(['Content-Type', 'Content-Length', 'Accept', 'Accept-Encoding', 'User-Agent', 'Authorization']);

// reserved names hotfix
utils$2.reduceDescriptors(AxiosHeaders.prototype, ({value}, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1); // map `set` => `Set`
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  }
});

utils$2.freezeMethods(AxiosHeaders);

var AxiosHeaders$1 = AxiosHeaders;

/**
 * Transform the data for a request or a response
 *
 * @param {Array|Function} fns A single function or Array of functions
 * @param {?Object} response The response object
 *
 * @returns {*} The resulting transformed data
 */
function transformData(fns, response) {
  const config = this || defaults$2;
  const context = response || config;
  const headers = AxiosHeaders$1.from(context.headers);
  let data = context.data;

  utils$2.forEach(fns, function transform(fn) {
    data = fn.call(config, data, headers.normalize(), response ? response.status : undefined);
  });

  headers.normalize();

  return data;
}

function isCancel(value) {
  return !!(value && value.__CANCEL__);
}

/**
 * A `CanceledError` is an object that is thrown when an operation is canceled.
 *
 * @param {string=} message The message.
 * @param {Object=} config The config.
 * @param {Object=} request The request.
 *
 * @returns {CanceledError} The created error.
 */
function CanceledError(message, config, request) {
  // eslint-disable-next-line no-eq-null,eqeqeq
  AxiosError.call(this, message == null ? 'canceled' : message, AxiosError.ERR_CANCELED, config, request);
  this.name = 'CanceledError';
}

utils$2.inherits(CanceledError, AxiosError, {
  __CANCEL__: true
});

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 *
 * @returns {object} The response.
 */
function settle(resolve, reject, response) {
  const validateStatus = response.config.validateStatus;
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError(
      'Request failed with status code ' + response.status,
      [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}

/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 *
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}

/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 *
 * @returns {string} The combined URL
 */
function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/?\/$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
}

/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 *
 * @returns {string} The combined full path
 */
function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}

var proxyFromEnv = {};

var hasRequiredProxyFromEnv;

function requireProxyFromEnv () {
	if (hasRequiredProxyFromEnv) return proxyFromEnv;
	hasRequiredProxyFromEnv = 1;

	var parseUrl = require$$5.parse;

	var DEFAULT_PORTS = {
	  ftp: 21,
	  gopher: 70,
	  http: 80,
	  https: 443,
	  ws: 80,
	  wss: 443,
	};

	var stringEndsWith = String.prototype.endsWith || function(s) {
	  return s.length <= this.length &&
	    this.indexOf(s, this.length - s.length) !== -1;
	};

	/**
	 * @param {string|object} url - The URL, or the result from url.parse.
	 * @return {string} The URL of the proxy that should handle the request to the
	 *  given URL. If no proxy is set, this will be an empty string.
	 */
	function getProxyForUrl(url) {
	  var parsedUrl = typeof url === 'string' ? parseUrl(url) : url || {};
	  var proto = parsedUrl.protocol;
	  var hostname = parsedUrl.host;
	  var port = parsedUrl.port;
	  if (typeof hostname !== 'string' || !hostname || typeof proto !== 'string') {
	    return '';  // Don't proxy URLs without a valid scheme or host.
	  }

	  proto = proto.split(':', 1)[0];
	  // Stripping ports in this way instead of using parsedUrl.hostname to make
	  // sure that the brackets around IPv6 addresses are kept.
	  hostname = hostname.replace(/:\d*$/, '');
	  port = parseInt(port) || DEFAULT_PORTS[proto] || 0;
	  if (!shouldProxy(hostname, port)) {
	    return '';  // Don't proxy URLs that match NO_PROXY.
	  }

	  var proxy =
	    getEnv('npm_config_' + proto + '_proxy') ||
	    getEnv(proto + '_proxy') ||
	    getEnv('npm_config_proxy') ||
	    getEnv('all_proxy');
	  if (proxy && proxy.indexOf('://') === -1) {
	    // Missing scheme in proxy, default to the requested URL's scheme.
	    proxy = proto + '://' + proxy;
	  }
	  return proxy;
	}

	/**
	 * Determines whether a given URL should be proxied.
	 *
	 * @param {string} hostname - The host name of the URL.
	 * @param {number} port - The effective port of the URL.
	 * @returns {boolean} Whether the given URL should be proxied.
	 * @private
	 */
	function shouldProxy(hostname, port) {
	  var NO_PROXY =
	    (getEnv('npm_config_no_proxy') || getEnv('no_proxy')).toLowerCase();
	  if (!NO_PROXY) {
	    return true;  // Always proxy if NO_PROXY is not set.
	  }
	  if (NO_PROXY === '*') {
	    return false;  // Never proxy if wildcard is set.
	  }

	  return NO_PROXY.split(/[,\s]/).every(function(proxy) {
	    if (!proxy) {
	      return true;  // Skip zero-length hosts.
	    }
	    var parsedProxy = proxy.match(/^(.+):(\d+)$/);
	    var parsedProxyHostname = parsedProxy ? parsedProxy[1] : proxy;
	    var parsedProxyPort = parsedProxy ? parseInt(parsedProxy[2]) : 0;
	    if (parsedProxyPort && parsedProxyPort !== port) {
	      return true;  // Skip if ports don't match.
	    }

	    if (!/^[.*]/.test(parsedProxyHostname)) {
	      // No wildcards, so stop proxying if there is an exact match.
	      return hostname !== parsedProxyHostname;
	    }

	    if (parsedProxyHostname.charAt(0) === '*') {
	      // Remove leading wildcard.
	      parsedProxyHostname = parsedProxyHostname.slice(1);
	    }
	    // Stop proxying if the hostname ends with the no_proxy host.
	    return !stringEndsWith.call(hostname, parsedProxyHostname);
	  });
	}

	/**
	 * Get the value for an environment variable.
	 *
	 * @param {string} key - The name of the environment variable.
	 * @return {string} The value of the environment variable.
	 * @private
	 */
	function getEnv(key) {
	  return process.env[key.toLowerCase()] || process.env[key.toUpperCase()] || '';
	}

	proxyFromEnv.getProxyForUrl = getProxyForUrl;
	return proxyFromEnv;
}

var proxyFromEnvExports = requireProxyFromEnv();

var followRedirects$1 = {exports: {}};

var src = {exports: {}};

var browser = {exports: {}};

/**
 * Helpers.
 */

var ms;
var hasRequiredMs;

function requireMs () {
	if (hasRequiredMs) return ms;
	hasRequiredMs = 1;
	var s = 1000;
	var m = s * 60;
	var h = m * 60;
	var d = h * 24;
	var w = d * 7;
	var y = d * 365.25;

	/**
	 * Parse or format the given `val`.
	 *
	 * Options:
	 *
	 *  - `long` verbose formatting [false]
	 *
	 * @param {String|Number} val
	 * @param {Object} [options]
	 * @throws {Error} throw an error if val is not a non-empty string or a number
	 * @return {String|Number}
	 * @api public
	 */

	ms = function(val, options) {
	  options = options || {};
	  var type = typeof val;
	  if (type === 'string' && val.length > 0) {
	    return parse(val);
	  } else if (type === 'number' && isFinite(val)) {
	    return options.long ? fmtLong(val) : fmtShort(val);
	  }
	  throw new Error(
	    'val is not a non-empty string or a valid number. val=' +
	      JSON.stringify(val)
	  );
	};

	/**
	 * Parse the given `str` and return milliseconds.
	 *
	 * @param {String} str
	 * @return {Number}
	 * @api private
	 */

	function parse(str) {
	  str = String(str);
	  if (str.length > 100) {
	    return;
	  }
	  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
	    str
	  );
	  if (!match) {
	    return;
	  }
	  var n = parseFloat(match[1]);
	  var type = (match[2] || 'ms').toLowerCase();
	  switch (type) {
	    case 'years':
	    case 'year':
	    case 'yrs':
	    case 'yr':
	    case 'y':
	      return n * y;
	    case 'weeks':
	    case 'week':
	    case 'w':
	      return n * w;
	    case 'days':
	    case 'day':
	    case 'd':
	      return n * d;
	    case 'hours':
	    case 'hour':
	    case 'hrs':
	    case 'hr':
	    case 'h':
	      return n * h;
	    case 'minutes':
	    case 'minute':
	    case 'mins':
	    case 'min':
	    case 'm':
	      return n * m;
	    case 'seconds':
	    case 'second':
	    case 'secs':
	    case 'sec':
	    case 's':
	      return n * s;
	    case 'milliseconds':
	    case 'millisecond':
	    case 'msecs':
	    case 'msec':
	    case 'ms':
	      return n;
	    default:
	      return undefined;
	  }
	}

	/**
	 * Short format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */

	function fmtShort(ms) {
	  var msAbs = Math.abs(ms);
	  if (msAbs >= d) {
	    return Math.round(ms / d) + 'd';
	  }
	  if (msAbs >= h) {
	    return Math.round(ms / h) + 'h';
	  }
	  if (msAbs >= m) {
	    return Math.round(ms / m) + 'm';
	  }
	  if (msAbs >= s) {
	    return Math.round(ms / s) + 's';
	  }
	  return ms + 'ms';
	}

	/**
	 * Long format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */

	function fmtLong(ms) {
	  var msAbs = Math.abs(ms);
	  if (msAbs >= d) {
	    return plural(ms, msAbs, d, 'day');
	  }
	  if (msAbs >= h) {
	    return plural(ms, msAbs, h, 'hour');
	  }
	  if (msAbs >= m) {
	    return plural(ms, msAbs, m, 'minute');
	  }
	  if (msAbs >= s) {
	    return plural(ms, msAbs, s, 'second');
	  }
	  return ms + ' ms';
	}

	/**
	 * Pluralization helper.
	 */

	function plural(ms, msAbs, n, name) {
	  var isPlural = msAbs >= n * 1.5;
	  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
	}
	return ms;
}

var common;
var hasRequiredCommon;

function requireCommon () {
	if (hasRequiredCommon) return common;
	hasRequiredCommon = 1;
	/**
	 * This is the common logic for both the Node.js and web browser
	 * implementations of `debug()`.
	 */

	function setup(env) {
		createDebug.debug = createDebug;
		createDebug.default = createDebug;
		createDebug.coerce = coerce;
		createDebug.disable = disable;
		createDebug.enable = enable;
		createDebug.enabled = enabled;
		createDebug.humanize = requireMs();
		createDebug.destroy = destroy;

		Object.keys(env).forEach(key => {
			createDebug[key] = env[key];
		});

		/**
		* The currently active debug mode names, and names to skip.
		*/

		createDebug.names = [];
		createDebug.skips = [];

		/**
		* Map of special "%n" handling functions, for the debug "format" argument.
		*
		* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
		*/
		createDebug.formatters = {};

		/**
		* Selects a color for a debug namespace
		* @param {String} namespace The namespace string for the debug instance to be colored
		* @return {Number|String} An ANSI color code for the given namespace
		* @api private
		*/
		function selectColor(namespace) {
			let hash = 0;

			for (let i = 0; i < namespace.length; i++) {
				hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
				hash |= 0; // Convert to 32bit integer
			}

			return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
		}
		createDebug.selectColor = selectColor;

		/**
		* Create a debugger with the given `namespace`.
		*
		* @param {String} namespace
		* @return {Function}
		* @api public
		*/
		function createDebug(namespace) {
			let prevTime;
			let enableOverride = null;
			let namespacesCache;
			let enabledCache;

			function debug(...args) {
				// Disabled?
				if (!debug.enabled) {
					return;
				}

				const self = debug;

				// Set `diff` timestamp
				const curr = Number(new Date());
				const ms = curr - (prevTime || curr);
				self.diff = ms;
				self.prev = prevTime;
				self.curr = curr;
				prevTime = curr;

				args[0] = createDebug.coerce(args[0]);

				if (typeof args[0] !== 'string') {
					// Anything else let's inspect with %O
					args.unshift('%O');
				}

				// Apply any `formatters` transformations
				let index = 0;
				args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
					// If we encounter an escaped % then don't increase the array index
					if (match === '%%') {
						return '%';
					}
					index++;
					const formatter = createDebug.formatters[format];
					if (typeof formatter === 'function') {
						const val = args[index];
						match = formatter.call(self, val);

						// Now we need to remove `args[index]` since it's inlined in the `format`
						args.splice(index, 1);
						index--;
					}
					return match;
				});

				// Apply env-specific formatting (colors, etc.)
				createDebug.formatArgs.call(self, args);

				const logFn = self.log || createDebug.log;
				logFn.apply(self, args);
			}

			debug.namespace = namespace;
			debug.useColors = createDebug.useColors();
			debug.color = createDebug.selectColor(namespace);
			debug.extend = extend;
			debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

			Object.defineProperty(debug, 'enabled', {
				enumerable: true,
				configurable: false,
				get: () => {
					if (enableOverride !== null) {
						return enableOverride;
					}
					if (namespacesCache !== createDebug.namespaces) {
						namespacesCache = createDebug.namespaces;
						enabledCache = createDebug.enabled(namespace);
					}

					return enabledCache;
				},
				set: v => {
					enableOverride = v;
				}
			});

			// Env-specific initialization logic for debug instances
			if (typeof createDebug.init === 'function') {
				createDebug.init(debug);
			}

			return debug;
		}

		function extend(namespace, delimiter) {
			const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
			newDebug.log = this.log;
			return newDebug;
		}

		/**
		* Enables a debug mode by namespaces. This can include modes
		* separated by a colon and wildcards.
		*
		* @param {String} namespaces
		* @api public
		*/
		function enable(namespaces) {
			createDebug.save(namespaces);
			createDebug.namespaces = namespaces;

			createDebug.names = [];
			createDebug.skips = [];

			let i;
			const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
			const len = split.length;

			for (i = 0; i < len; i++) {
				if (!split[i]) {
					// ignore empty strings
					continue;
				}

				namespaces = split[i].replace(/\*/g, '.*?');

				if (namespaces[0] === '-') {
					createDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));
				} else {
					createDebug.names.push(new RegExp('^' + namespaces + '$'));
				}
			}
		}

		/**
		* Disable debug output.
		*
		* @return {String} namespaces
		* @api public
		*/
		function disable() {
			const namespaces = [
				...createDebug.names.map(toNamespace),
				...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
			].join(',');
			createDebug.enable('');
			return namespaces;
		}

		/**
		* Returns true if the given mode name is enabled, false otherwise.
		*
		* @param {String} name
		* @return {Boolean}
		* @api public
		*/
		function enabled(name) {
			if (name[name.length - 1] === '*') {
				return true;
			}

			let i;
			let len;

			for (i = 0, len = createDebug.skips.length; i < len; i++) {
				if (createDebug.skips[i].test(name)) {
					return false;
				}
			}

			for (i = 0, len = createDebug.names.length; i < len; i++) {
				if (createDebug.names[i].test(name)) {
					return true;
				}
			}

			return false;
		}

		/**
		* Convert regexp to namespace
		*
		* @param {RegExp} regxep
		* @return {String} namespace
		* @api private
		*/
		function toNamespace(regexp) {
			return regexp.toString()
				.substring(2, regexp.toString().length - 2)
				.replace(/\.\*\?$/, '*');
		}

		/**
		* Coerce `val`.
		*
		* @param {Mixed} val
		* @return {Mixed}
		* @api private
		*/
		function coerce(val) {
			if (val instanceof Error) {
				return val.stack || val.message;
			}
			return val;
		}

		/**
		* XXX DO NOT USE. This is a temporary stub function.
		* XXX It WILL be removed in the next major release.
		*/
		function destroy() {
			console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
		}

		createDebug.enable(createDebug.load());

		return createDebug;
	}

	common = setup;
	return common;
}

/* eslint-env browser */

var hasRequiredBrowser;

function requireBrowser () {
	if (hasRequiredBrowser) return browser.exports;
	hasRequiredBrowser = 1;
	(function (module, exports) {
		/**
		 * This is the web browser implementation of `debug()`.
		 */

		exports.formatArgs = formatArgs;
		exports.save = save;
		exports.load = load;
		exports.useColors = useColors;
		exports.storage = localstorage();
		exports.destroy = (() => {
			let warned = false;

			return () => {
				if (!warned) {
					warned = true;
					console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
				}
			};
		})();

		/**
		 * Colors.
		 */

		exports.colors = [
			'#0000CC',
			'#0000FF',
			'#0033CC',
			'#0033FF',
			'#0066CC',
			'#0066FF',
			'#0099CC',
			'#0099FF',
			'#00CC00',
			'#00CC33',
			'#00CC66',
			'#00CC99',
			'#00CCCC',
			'#00CCFF',
			'#3300CC',
			'#3300FF',
			'#3333CC',
			'#3333FF',
			'#3366CC',
			'#3366FF',
			'#3399CC',
			'#3399FF',
			'#33CC00',
			'#33CC33',
			'#33CC66',
			'#33CC99',
			'#33CCCC',
			'#33CCFF',
			'#6600CC',
			'#6600FF',
			'#6633CC',
			'#6633FF',
			'#66CC00',
			'#66CC33',
			'#9900CC',
			'#9900FF',
			'#9933CC',
			'#9933FF',
			'#99CC00',
			'#99CC33',
			'#CC0000',
			'#CC0033',
			'#CC0066',
			'#CC0099',
			'#CC00CC',
			'#CC00FF',
			'#CC3300',
			'#CC3333',
			'#CC3366',
			'#CC3399',
			'#CC33CC',
			'#CC33FF',
			'#CC6600',
			'#CC6633',
			'#CC9900',
			'#CC9933',
			'#CCCC00',
			'#CCCC33',
			'#FF0000',
			'#FF0033',
			'#FF0066',
			'#FF0099',
			'#FF00CC',
			'#FF00FF',
			'#FF3300',
			'#FF3333',
			'#FF3366',
			'#FF3399',
			'#FF33CC',
			'#FF33FF',
			'#FF6600',
			'#FF6633',
			'#FF9900',
			'#FF9933',
			'#FFCC00',
			'#FFCC33'
		];

		/**
		 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
		 * and the Firebug extension (any Firefox version) are known
		 * to support "%c" CSS customizations.
		 *
		 * TODO: add a `localStorage` variable to explicitly enable/disable colors
		 */

		// eslint-disable-next-line complexity
		function useColors() {
			// NB: In an Electron preload script, document will be defined but not fully
			// initialized. Since we know we're in Chrome, we'll just detect this case
			// explicitly
			if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
				return true;
			}

			// Internet Explorer and Edge do not support colors.
			if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
				return false;
			}

			// Is webkit? http://stackoverflow.com/a/16459606/376773
			// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
			return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
				// Is firebug? http://stackoverflow.com/a/398120/376773
				(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
				// Is firefox >= v31?
				// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
				(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
				// Double check webkit in userAgent just in case we are in a worker
				(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
		}

		/**
		 * Colorize log arguments if enabled.
		 *
		 * @api public
		 */

		function formatArgs(args) {
			args[0] = (this.useColors ? '%c' : '') +
				this.namespace +
				(this.useColors ? ' %c' : ' ') +
				args[0] +
				(this.useColors ? '%c ' : ' ') +
				'+' + module.exports.humanize(this.diff);

			if (!this.useColors) {
				return;
			}

			const c = 'color: ' + this.color;
			args.splice(1, 0, c, 'color: inherit');

			// The final "%c" is somewhat tricky, because there could be other
			// arguments passed either before or after the %c, so we need to
			// figure out the correct index to insert the CSS into
			let index = 0;
			let lastC = 0;
			args[0].replace(/%[a-zA-Z%]/g, match => {
				if (match === '%%') {
					return;
				}
				index++;
				if (match === '%c') {
					// We only are interested in the *last* %c
					// (the user may have provided their own)
					lastC = index;
				}
			});

			args.splice(lastC, 0, c);
		}

		/**
		 * Invokes `console.debug()` when available.
		 * No-op when `console.debug` is not a "function".
		 * If `console.debug` is not available, falls back
		 * to `console.log`.
		 *
		 * @api public
		 */
		exports.log = console.debug || console.log || (() => {});

		/**
		 * Save `namespaces`.
		 *
		 * @param {String} namespaces
		 * @api private
		 */
		function save(namespaces) {
			try {
				if (namespaces) {
					exports.storage.setItem('debug', namespaces);
				} else {
					exports.storage.removeItem('debug');
				}
			} catch (error) {
				// Swallow
				// XXX (@Qix-) should we be logging these?
			}
		}

		/**
		 * Load `namespaces`.
		 *
		 * @return {String} returns the previously persisted debug modes
		 * @api private
		 */
		function load() {
			let r;
			try {
				r = exports.storage.getItem('debug');
			} catch (error) {
				// Swallow
				// XXX (@Qix-) should we be logging these?
			}

			// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
			if (!r && typeof process !== 'undefined' && 'env' in process) {
				r = process.env.DEBUG;
			}

			return r;
		}

		/**
		 * Localstorage attempts to return the localstorage.
		 *
		 * This is necessary because safari throws
		 * when a user disables cookies/localstorage
		 * and you attempt to access it.
		 *
		 * @return {LocalStorage}
		 * @api private
		 */

		function localstorage() {
			try {
				// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
				// The Browser also has localStorage in the global context.
				return localStorage;
			} catch (error) {
				// Swallow
				// XXX (@Qix-) should we be logging these?
			}
		}

		module.exports = requireCommon()(exports);

		const {formatters} = module.exports;

		/**
		 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
		 */

		formatters.j = function (v) {
			try {
				return JSON.stringify(v);
			} catch (error) {
				return '[UnexpectedJSONParseError]: ' + error.message;
			}
		}; 
	} (browser, browser.exports));
	return browser.exports;
}

var node = {exports: {}};

var hasFlag;
var hasRequiredHasFlag;

function requireHasFlag () {
	if (hasRequiredHasFlag) return hasFlag;
	hasRequiredHasFlag = 1;
	hasFlag = (flag, argv) => {
		argv = argv || process.argv;
		const prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');
		const pos = argv.indexOf(prefix + flag);
		const terminatorPos = argv.indexOf('--');
		return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
	};
	return hasFlag;
}

var supportsColor_1;
var hasRequiredSupportsColor;

function requireSupportsColor () {
	if (hasRequiredSupportsColor) return supportsColor_1;
	hasRequiredSupportsColor = 1;
	const os = require$$0$3;
	const hasFlag = requireHasFlag();

	const env = process.env;

	let forceColor;
	if (hasFlag('no-color') ||
		hasFlag('no-colors') ||
		hasFlag('color=false')) {
		forceColor = false;
	} else if (hasFlag('color') ||
		hasFlag('colors') ||
		hasFlag('color=true') ||
		hasFlag('color=always')) {
		forceColor = true;
	}
	if ('FORCE_COLOR' in env) {
		forceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;
	}

	function translateLevel(level) {
		if (level === 0) {
			return false;
		}

		return {
			level,
			hasBasic: true,
			has256: level >= 2,
			has16m: level >= 3
		};
	}

	function supportsColor(stream) {
		if (forceColor === false) {
			return 0;
		}

		if (hasFlag('color=16m') ||
			hasFlag('color=full') ||
			hasFlag('color=truecolor')) {
			return 3;
		}

		if (hasFlag('color=256')) {
			return 2;
		}

		if (stream && !stream.isTTY && forceColor !== true) {
			return 0;
		}

		const min = forceColor ? 1 : 0;

		if (process.platform === 'win32') {
			// Node.js 7.5.0 is the first version of Node.js to include a patch to
			// libuv that enables 256 color output on Windows. Anything earlier and it
			// won't work. However, here we target Node.js 8 at minimum as it is an LTS
			// release, and Node.js 7 is not. Windows 10 build 10586 is the first Windows
			// release that supports 256 colors. Windows 10 build 14931 is the first release
			// that supports 16m/TrueColor.
			const osRelease = os.release().split('.');
			if (
				Number(process.versions.node.split('.')[0]) >= 8 &&
				Number(osRelease[0]) >= 10 &&
				Number(osRelease[2]) >= 10586
			) {
				return Number(osRelease[2]) >= 14931 ? 3 : 2;
			}

			return 1;
		}

		if ('CI' in env) {
			if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI'].some(sign => sign in env) || env.CI_NAME === 'codeship') {
				return 1;
			}

			return min;
		}

		if ('TEAMCITY_VERSION' in env) {
			return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
		}

		if (env.COLORTERM === 'truecolor') {
			return 3;
		}

		if ('TERM_PROGRAM' in env) {
			const version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);

			switch (env.TERM_PROGRAM) {
				case 'iTerm.app':
					return version >= 3 ? 3 : 2;
				case 'Apple_Terminal':
					return 2;
				// No default
			}
		}

		if (/-256(color)?$/i.test(env.TERM)) {
			return 2;
		}

		if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
			return 1;
		}

		if ('COLORTERM' in env) {
			return 1;
		}

		if (env.TERM === 'dumb') {
			return min;
		}

		return min;
	}

	function getSupportLevel(stream) {
		const level = supportsColor(stream);
		return translateLevel(level);
	}

	supportsColor_1 = {
		supportsColor: getSupportLevel,
		stdout: getSupportLevel(process.stdout),
		stderr: getSupportLevel(process.stderr)
	};
	return supportsColor_1;
}

/**
 * Module dependencies.
 */

var hasRequiredNode;

function requireNode () {
	if (hasRequiredNode) return node.exports;
	hasRequiredNode = 1;
	(function (module, exports) {
		const tty = require$$0$4;
		const util = require$$1;

		/**
		 * This is the Node.js implementation of `debug()`.
		 */

		exports.init = init;
		exports.log = log;
		exports.formatArgs = formatArgs;
		exports.save = save;
		exports.load = load;
		exports.useColors = useColors;
		exports.destroy = util.deprecate(
			() => {},
			'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'
		);

		/**
		 * Colors.
		 */

		exports.colors = [6, 2, 3, 4, 5, 1];

		try {
			// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)
			// eslint-disable-next-line import/no-extraneous-dependencies
			const supportsColor = requireSupportsColor();

			if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
				exports.colors = [
					20,
					21,
					26,
					27,
					32,
					33,
					38,
					39,
					40,
					41,
					42,
					43,
					44,
					45,
					56,
					57,
					62,
					63,
					68,
					69,
					74,
					75,
					76,
					77,
					78,
					79,
					80,
					81,
					92,
					93,
					98,
					99,
					112,
					113,
					128,
					129,
					134,
					135,
					148,
					149,
					160,
					161,
					162,
					163,
					164,
					165,
					166,
					167,
					168,
					169,
					170,
					171,
					172,
					173,
					178,
					179,
					184,
					185,
					196,
					197,
					198,
					199,
					200,
					201,
					202,
					203,
					204,
					205,
					206,
					207,
					208,
					209,
					214,
					215,
					220,
					221
				];
			}
		} catch (error) {
			// Swallow - we only care if `supports-color` is available; it doesn't have to be.
		}

		/**
		 * Build up the default `inspectOpts` object from the environment variables.
		 *
		 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
		 */

		exports.inspectOpts = Object.keys(process.env).filter(key => {
			return /^debug_/i.test(key);
		}).reduce((obj, key) => {
			// Camel-case
			const prop = key
				.substring(6)
				.toLowerCase()
				.replace(/_([a-z])/g, (_, k) => {
					return k.toUpperCase();
				});

			// Coerce string value into JS value
			let val = process.env[key];
			if (/^(yes|on|true|enabled)$/i.test(val)) {
				val = true;
			} else if (/^(no|off|false|disabled)$/i.test(val)) {
				val = false;
			} else if (val === 'null') {
				val = null;
			} else {
				val = Number(val);
			}

			obj[prop] = val;
			return obj;
		}, {});

		/**
		 * Is stdout a TTY? Colored output is enabled when `true`.
		 */

		function useColors() {
			return 'colors' in exports.inspectOpts ?
				Boolean(exports.inspectOpts.colors) :
				tty.isatty(process.stderr.fd);
		}

		/**
		 * Adds ANSI color escape codes if enabled.
		 *
		 * @api public
		 */

		function formatArgs(args) {
			const {namespace: name, useColors} = this;

			if (useColors) {
				const c = this.color;
				const colorCode = '\u001B[3' + (c < 8 ? c : '8;5;' + c);
				const prefix = `  ${colorCode};1m${name} \u001B[0m`;

				args[0] = prefix + args[0].split('\n').join('\n' + prefix);
				args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\u001B[0m');
			} else {
				args[0] = getDate() + name + ' ' + args[0];
			}
		}

		function getDate() {
			if (exports.inspectOpts.hideDate) {
				return '';
			}
			return new Date().toISOString() + ' ';
		}

		/**
		 * Invokes `util.format()` with the specified arguments and writes to stderr.
		 */

		function log(...args) {
			return process.stderr.write(util.format(...args) + '\n');
		}

		/**
		 * Save `namespaces`.
		 *
		 * @param {String} namespaces
		 * @api private
		 */
		function save(namespaces) {
			if (namespaces) {
				process.env.DEBUG = namespaces;
			} else {
				// If you set a process.env field to null or undefined, it gets cast to the
				// string 'null' or 'undefined'. Just delete instead.
				delete process.env.DEBUG;
			}
		}

		/**
		 * Load `namespaces`.
		 *
		 * @return {String} returns the previously persisted debug modes
		 * @api private
		 */

		function load() {
			return process.env.DEBUG;
		}

		/**
		 * Init logic for `debug` instances.
		 *
		 * Create a new `inspectOpts` object in case `useColors` is set
		 * differently for a particular `debug` instance.
		 */

		function init(debug) {
			debug.inspectOpts = {};

			const keys = Object.keys(exports.inspectOpts);
			for (let i = 0; i < keys.length; i++) {
				debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
			}
		}

		module.exports = requireCommon()(exports);

		const {formatters} = module.exports;

		/**
		 * Map %o to `util.inspect()`, all on a single line.
		 */

		formatters.o = function (v) {
			this.inspectOpts.colors = this.useColors;
			return util.inspect(v, this.inspectOpts)
				.split('\n')
				.map(str => str.trim())
				.join(' ');
		};

		/**
		 * Map %O to `util.inspect()`, allowing multiple lines if needed.
		 */

		formatters.O = function (v) {
			this.inspectOpts.colors = this.useColors;
			return util.inspect(v, this.inspectOpts);
		}; 
	} (node, node.exports));
	return node.exports;
}

/**
 * Detect Electron renderer / nwjs process, which is node, but we should
 * treat as a browser.
 */

var hasRequiredSrc;

function requireSrc () {
	if (hasRequiredSrc) return src.exports;
	hasRequiredSrc = 1;
	if (typeof process === 'undefined' || process.type === 'renderer' || process.browser === true || process.__nwjs) {
		src.exports = requireBrowser();
	} else {
		src.exports = requireNode();
	}
	return src.exports;
}

var debug_1;
var hasRequiredDebug;

function requireDebug () {
	if (hasRequiredDebug) return debug_1;
	hasRequiredDebug = 1;
	var debug;

	debug_1 = function () {
	  if (!debug) {
	    try {
	      /* eslint global-require: off */
	      debug = requireSrc()("follow-redirects");
	    }
	    catch (error) { /* */ }
	    if (typeof debug !== "function") {
	      debug = function () { /* */ };
	    }
	  }
	  debug.apply(null, arguments);
	};
	return debug_1;
}

var hasRequiredFollowRedirects;

function requireFollowRedirects () {
	if (hasRequiredFollowRedirects) return followRedirects$1.exports;
	hasRequiredFollowRedirects = 1;
	var url = require$$5;
	var URL = url.URL;
	var http = require$$0$2;
	var https = require$$2;
	var Writable = stream.Writable;
	var assert = require$$0$5;
	var debug = requireDebug();

	// Preventive platform detection
	// istanbul ignore next
	(function detectUnsupportedEnvironment() {
	  var looksLikeNode = typeof process !== "undefined";
	  var looksLikeBrowser = typeof window !== "undefined" && typeof document !== "undefined";
	  var looksLikeV8 = isFunction(Error.captureStackTrace);
	  if (!looksLikeNode && (looksLikeBrowser || !looksLikeV8)) {
	    console.warn("The follow-redirects package should be excluded from browser builds.");
	  }
	}());

	// Whether to use the native URL object or the legacy url module
	var useNativeURL = false;
	try {
	  assert(new URL(""));
	}
	catch (error) {
	  useNativeURL = error.code === "ERR_INVALID_URL";
	}

	// URL fields to preserve in copy operations
	var preservedUrlFields = [
	  "auth",
	  "host",
	  "hostname",
	  "href",
	  "path",
	  "pathname",
	  "port",
	  "protocol",
	  "query",
	  "search",
	  "hash",
	];

	// Create handlers that pass events from native requests
	var events = ["abort", "aborted", "connect", "error", "socket", "timeout"];
	var eventHandlers = Object.create(null);
	events.forEach(function (event) {
	  eventHandlers[event] = function (arg1, arg2, arg3) {
	    this._redirectable.emit(event, arg1, arg2, arg3);
	  };
	});

	// Error types with codes
	var InvalidUrlError = createErrorType(
	  "ERR_INVALID_URL",
	  "Invalid URL",
	  TypeError
	);
	var RedirectionError = createErrorType(
	  "ERR_FR_REDIRECTION_FAILURE",
	  "Redirected request failed"
	);
	var TooManyRedirectsError = createErrorType(
	  "ERR_FR_TOO_MANY_REDIRECTS",
	  "Maximum number of redirects exceeded",
	  RedirectionError
	);
	var MaxBodyLengthExceededError = createErrorType(
	  "ERR_FR_MAX_BODY_LENGTH_EXCEEDED",
	  "Request body larger than maxBodyLength limit"
	);
	var WriteAfterEndError = createErrorType(
	  "ERR_STREAM_WRITE_AFTER_END",
	  "write after end"
	);

	// istanbul ignore next
	var destroy = Writable.prototype.destroy || noop;

	// An HTTP(S) request that can be redirected
	function RedirectableRequest(options, responseCallback) {
	  // Initialize the request
	  Writable.call(this);
	  this._sanitizeOptions(options);
	  this._options = options;
	  this._ended = false;
	  this._ending = false;
	  this._redirectCount = 0;
	  this._redirects = [];
	  this._requestBodyLength = 0;
	  this._requestBodyBuffers = [];

	  // Attach a callback if passed
	  if (responseCallback) {
	    this.on("response", responseCallback);
	  }

	  // React to responses of native requests
	  var self = this;
	  this._onNativeResponse = function (response) {
	    try {
	      self._processResponse(response);
	    }
	    catch (cause) {
	      self.emit("error", cause instanceof RedirectionError ?
	        cause : new RedirectionError({ cause: cause }));
	    }
	  };

	  // Perform the first request
	  this._performRequest();
	}
	RedirectableRequest.prototype = Object.create(Writable.prototype);

	RedirectableRequest.prototype.abort = function () {
	  destroyRequest(this._currentRequest);
	  this._currentRequest.abort();
	  this.emit("abort");
	};

	RedirectableRequest.prototype.destroy = function (error) {
	  destroyRequest(this._currentRequest, error);
	  destroy.call(this, error);
	  return this;
	};

	// Writes buffered data to the current native request
	RedirectableRequest.prototype.write = function (data, encoding, callback) {
	  // Writing is not allowed if end has been called
	  if (this._ending) {
	    throw new WriteAfterEndError();
	  }

	  // Validate input and shift parameters if necessary
	  if (!isString(data) && !isBuffer(data)) {
	    throw new TypeError("data should be a string, Buffer or Uint8Array");
	  }
	  if (isFunction(encoding)) {
	    callback = encoding;
	    encoding = null;
	  }

	  // Ignore empty buffers, since writing them doesn't invoke the callback
	  // https://github.com/nodejs/node/issues/22066
	  if (data.length === 0) {
	    if (callback) {
	      callback();
	    }
	    return;
	  }
	  // Only write when we don't exceed the maximum body length
	  if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
	    this._requestBodyLength += data.length;
	    this._requestBodyBuffers.push({ data: data, encoding: encoding });
	    this._currentRequest.write(data, encoding, callback);
	  }
	  // Error when we exceed the maximum body length
	  else {
	    this.emit("error", new MaxBodyLengthExceededError());
	    this.abort();
	  }
	};

	// Ends the current native request
	RedirectableRequest.prototype.end = function (data, encoding, callback) {
	  // Shift parameters if necessary
	  if (isFunction(data)) {
	    callback = data;
	    data = encoding = null;
	  }
	  else if (isFunction(encoding)) {
	    callback = encoding;
	    encoding = null;
	  }

	  // Write data if needed and end
	  if (!data) {
	    this._ended = this._ending = true;
	    this._currentRequest.end(null, null, callback);
	  }
	  else {
	    var self = this;
	    var currentRequest = this._currentRequest;
	    this.write(data, encoding, function () {
	      self._ended = true;
	      currentRequest.end(null, null, callback);
	    });
	    this._ending = true;
	  }
	};

	// Sets a header value on the current native request
	RedirectableRequest.prototype.setHeader = function (name, value) {
	  this._options.headers[name] = value;
	  this._currentRequest.setHeader(name, value);
	};

	// Clears a header value on the current native request
	RedirectableRequest.prototype.removeHeader = function (name) {
	  delete this._options.headers[name];
	  this._currentRequest.removeHeader(name);
	};

	// Global timeout for all underlying requests
	RedirectableRequest.prototype.setTimeout = function (msecs, callback) {
	  var self = this;

	  // Destroys the socket on timeout
	  function destroyOnTimeout(socket) {
	    socket.setTimeout(msecs);
	    socket.removeListener("timeout", socket.destroy);
	    socket.addListener("timeout", socket.destroy);
	  }

	  // Sets up a timer to trigger a timeout event
	  function startTimer(socket) {
	    if (self._timeout) {
	      clearTimeout(self._timeout);
	    }
	    self._timeout = setTimeout(function () {
	      self.emit("timeout");
	      clearTimer();
	    }, msecs);
	    destroyOnTimeout(socket);
	  }

	  // Stops a timeout from triggering
	  function clearTimer() {
	    // Clear the timeout
	    if (self._timeout) {
	      clearTimeout(self._timeout);
	      self._timeout = null;
	    }

	    // Clean up all attached listeners
	    self.removeListener("abort", clearTimer);
	    self.removeListener("error", clearTimer);
	    self.removeListener("response", clearTimer);
	    self.removeListener("close", clearTimer);
	    if (callback) {
	      self.removeListener("timeout", callback);
	    }
	    if (!self.socket) {
	      self._currentRequest.removeListener("socket", startTimer);
	    }
	  }

	  // Attach callback if passed
	  if (callback) {
	    this.on("timeout", callback);
	  }

	  // Start the timer if or when the socket is opened
	  if (this.socket) {
	    startTimer(this.socket);
	  }
	  else {
	    this._currentRequest.once("socket", startTimer);
	  }

	  // Clean up on events
	  this.on("socket", destroyOnTimeout);
	  this.on("abort", clearTimer);
	  this.on("error", clearTimer);
	  this.on("response", clearTimer);
	  this.on("close", clearTimer);

	  return this;
	};

	// Proxy all other public ClientRequest methods
	[
	  "flushHeaders", "getHeader",
	  "setNoDelay", "setSocketKeepAlive",
	].forEach(function (method) {
	  RedirectableRequest.prototype[method] = function (a, b) {
	    return this._currentRequest[method](a, b);
	  };
	});

	// Proxy all public ClientRequest properties
	["aborted", "connection", "socket"].forEach(function (property) {
	  Object.defineProperty(RedirectableRequest.prototype, property, {
	    get: function () { return this._currentRequest[property]; },
	  });
	});

	RedirectableRequest.prototype._sanitizeOptions = function (options) {
	  // Ensure headers are always present
	  if (!options.headers) {
	    options.headers = {};
	  }

	  // Since http.request treats host as an alias of hostname,
	  // but the url module interprets host as hostname plus port,
	  // eliminate the host property to avoid confusion.
	  if (options.host) {
	    // Use hostname if set, because it has precedence
	    if (!options.hostname) {
	      options.hostname = options.host;
	    }
	    delete options.host;
	  }

	  // Complete the URL object when necessary
	  if (!options.pathname && options.path) {
	    var searchPos = options.path.indexOf("?");
	    if (searchPos < 0) {
	      options.pathname = options.path;
	    }
	    else {
	      options.pathname = options.path.substring(0, searchPos);
	      options.search = options.path.substring(searchPos);
	    }
	  }
	};


	// Executes the next native request (initial or redirect)
	RedirectableRequest.prototype._performRequest = function () {
	  // Load the native protocol
	  var protocol = this._options.protocol;
	  var nativeProtocol = this._options.nativeProtocols[protocol];
	  if (!nativeProtocol) {
	    throw new TypeError("Unsupported protocol " + protocol);
	  }

	  // If specified, use the agent corresponding to the protocol
	  // (HTTP and HTTPS use different types of agents)
	  if (this._options.agents) {
	    var scheme = protocol.slice(0, -1);
	    this._options.agent = this._options.agents[scheme];
	  }

	  // Create the native request and set up its event handlers
	  var request = this._currentRequest =
	        nativeProtocol.request(this._options, this._onNativeResponse);
	  request._redirectable = this;
	  for (var event of events) {
	    request.on(event, eventHandlers[event]);
	  }

	  // RFC72305.3.1: When making a request directly to an origin server, []
	  // a client MUST send only the absolute path [] as the request-target.
	  this._currentUrl = /^\//.test(this._options.path) ?
	    url.format(this._options) :
	    // When making a request to a proxy, []
	    // a client MUST send the target URI in absolute-form [].
	    this._options.path;

	  // End a redirected request
	  // (The first request must be ended explicitly with RedirectableRequest#end)
	  if (this._isRedirect) {
	    // Write the request entity and end
	    var i = 0;
	    var self = this;
	    var buffers = this._requestBodyBuffers;
	    (function writeNext(error) {
	      // Only write if this request has not been redirected yet
	      // istanbul ignore else
	      if (request === self._currentRequest) {
	        // Report any write errors
	        // istanbul ignore if
	        if (error) {
	          self.emit("error", error);
	        }
	        // Write the next buffer if there are still left
	        else if (i < buffers.length) {
	          var buffer = buffers[i++];
	          // istanbul ignore else
	          if (!request.finished) {
	            request.write(buffer.data, buffer.encoding, writeNext);
	          }
	        }
	        // End the request if `end` has been called on us
	        else if (self._ended) {
	          request.end();
	        }
	      }
	    }());
	  }
	};

	// Processes a response from the current native request
	RedirectableRequest.prototype._processResponse = function (response) {
	  // Store the redirected response
	  var statusCode = response.statusCode;
	  if (this._options.trackRedirects) {
	    this._redirects.push({
	      url: this._currentUrl,
	      headers: response.headers,
	      statusCode: statusCode,
	    });
	  }

	  // RFC72316.4: The 3xx (Redirection) class of status code indicates
	  // that further action needs to be taken by the user agent in order to
	  // fulfill the request. If a Location header field is provided,
	  // the user agent MAY automatically redirect its request to the URI
	  // referenced by the Location field value,
	  // even if the specific status code is not understood.

	  // If the response is not a redirect; return it as-is
	  var location = response.headers.location;
	  if (!location || this._options.followRedirects === false ||
	      statusCode < 300 || statusCode >= 400) {
	    response.responseUrl = this._currentUrl;
	    response.redirects = this._redirects;
	    this.emit("response", response);

	    // Clean up
	    this._requestBodyBuffers = [];
	    return;
	  }

	  // The response is a redirect, so abort the current request
	  destroyRequest(this._currentRequest);
	  // Discard the remainder of the response to avoid waiting for data
	  response.destroy();

	  // RFC72316.4: A client SHOULD detect and intervene
	  // in cyclical redirections (i.e., "infinite" redirection loops).
	  if (++this._redirectCount > this._options.maxRedirects) {
	    throw new TooManyRedirectsError();
	  }

	  // Store the request headers if applicable
	  var requestHeaders;
	  var beforeRedirect = this._options.beforeRedirect;
	  if (beforeRedirect) {
	    requestHeaders = Object.assign({
	      // The Host header was set by nativeProtocol.request
	      Host: response.req.getHeader("host"),
	    }, this._options.headers);
	  }

	  // RFC72316.4: Automatic redirection needs to done with
	  // care for methods not known to be safe, []
	  // RFC72316.4.23: For historical reasons, a user agent MAY change
	  // the request method from POST to GET for the subsequent request.
	  var method = this._options.method;
	  if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" ||
	      // RFC72316.4.4: The 303 (See Other) status code indicates that
	      // the server is redirecting the user agent to a different resource []
	      // A user agent can perform a retrieval request targeting that URI
	      // (a GET or HEAD request if using HTTP) []
	      (statusCode === 303) && !/^(?:GET|HEAD)$/.test(this._options.method)) {
	    this._options.method = "GET";
	    // Drop a possible entity and headers related to it
	    this._requestBodyBuffers = [];
	    removeMatchingHeaders(/^content-/i, this._options.headers);
	  }

	  // Drop the Host header, as the redirect might lead to a different host
	  var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);

	  // If the redirect is relative, carry over the host of the last request
	  var currentUrlParts = parseUrl(this._currentUrl);
	  var currentHost = currentHostHeader || currentUrlParts.host;
	  var currentUrl = /^\w+:/.test(location) ? this._currentUrl :
	    url.format(Object.assign(currentUrlParts, { host: currentHost }));

	  // Create the redirected request
	  var redirectUrl = resolveUrl(location, currentUrl);
	  debug("redirecting to", redirectUrl.href);
	  this._isRedirect = true;
	  spreadUrlObject(redirectUrl, this._options);

	  // Drop confidential headers when redirecting to a less secure protocol
	  // or to a different domain that is not a superdomain
	  if (redirectUrl.protocol !== currentUrlParts.protocol &&
	     redirectUrl.protocol !== "https:" ||
	     redirectUrl.host !== currentHost &&
	     !isSubdomain(redirectUrl.host, currentHost)) {
	    removeMatchingHeaders(/^(?:(?:proxy-)?authorization|cookie)$/i, this._options.headers);
	  }

	  // Evaluate the beforeRedirect callback
	  if (isFunction(beforeRedirect)) {
	    var responseDetails = {
	      headers: response.headers,
	      statusCode: statusCode,
	    };
	    var requestDetails = {
	      url: currentUrl,
	      method: method,
	      headers: requestHeaders,
	    };
	    beforeRedirect(this._options, responseDetails, requestDetails);
	    this._sanitizeOptions(this._options);
	  }

	  // Perform the redirected request
	  this._performRequest();
	};

	// Wraps the key/value object of protocols with redirect functionality
	function wrap(protocols) {
	  // Default settings
	  var exports = {
	    maxRedirects: 21,
	    maxBodyLength: 10 * 1024 * 1024,
	  };

	  // Wrap each protocol
	  var nativeProtocols = {};
	  Object.keys(protocols).forEach(function (scheme) {
	    var protocol = scheme + ":";
	    var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
	    var wrappedProtocol = exports[scheme] = Object.create(nativeProtocol);

	    // Executes a request, following redirects
	    function request(input, options, callback) {
	      // Parse parameters, ensuring that input is an object
	      if (isURL(input)) {
	        input = spreadUrlObject(input);
	      }
	      else if (isString(input)) {
	        input = spreadUrlObject(parseUrl(input));
	      }
	      else {
	        callback = options;
	        options = validateUrl(input);
	        input = { protocol: protocol };
	      }
	      if (isFunction(options)) {
	        callback = options;
	        options = null;
	      }

	      // Set defaults
	      options = Object.assign({
	        maxRedirects: exports.maxRedirects,
	        maxBodyLength: exports.maxBodyLength,
	      }, input, options);
	      options.nativeProtocols = nativeProtocols;
	      if (!isString(options.host) && !isString(options.hostname)) {
	        options.hostname = "::1";
	      }

	      assert.equal(options.protocol, protocol, "protocol mismatch");
	      debug("options", options);
	      return new RedirectableRequest(options, callback);
	    }

	    // Executes a GET request, following redirects
	    function get(input, options, callback) {
	      var wrappedRequest = wrappedProtocol.request(input, options, callback);
	      wrappedRequest.end();
	      return wrappedRequest;
	    }

	    // Expose the properties on the wrapped protocol
	    Object.defineProperties(wrappedProtocol, {
	      request: { value: request, configurable: true, enumerable: true, writable: true },
	      get: { value: get, configurable: true, enumerable: true, writable: true },
	    });
	  });
	  return exports;
	}

	function noop() { /* empty */ }

	function parseUrl(input) {
	  var parsed;
	  // istanbul ignore else
	  if (useNativeURL) {
	    parsed = new URL(input);
	  }
	  else {
	    // Ensure the URL is valid and absolute
	    parsed = validateUrl(url.parse(input));
	    if (!isString(parsed.protocol)) {
	      throw new InvalidUrlError({ input });
	    }
	  }
	  return parsed;
	}

	function resolveUrl(relative, base) {
	  // istanbul ignore next
	  return useNativeURL ? new URL(relative, base) : parseUrl(url.resolve(base, relative));
	}

	function validateUrl(input) {
	  if (/^\[/.test(input.hostname) && !/^\[[:0-9a-f]+\]$/i.test(input.hostname)) {
	    throw new InvalidUrlError({ input: input.href || input });
	  }
	  if (/^\[/.test(input.host) && !/^\[[:0-9a-f]+\](:\d+)?$/i.test(input.host)) {
	    throw new InvalidUrlError({ input: input.href || input });
	  }
	  return input;
	}

	function spreadUrlObject(urlObject, target) {
	  var spread = target || {};
	  for (var key of preservedUrlFields) {
	    spread[key] = urlObject[key];
	  }

	  // Fix IPv6 hostname
	  if (spread.hostname.startsWith("[")) {
	    spread.hostname = spread.hostname.slice(1, -1);
	  }
	  // Ensure port is a number
	  if (spread.port !== "") {
	    spread.port = Number(spread.port);
	  }
	  // Concatenate path
	  spread.path = spread.search ? spread.pathname + spread.search : spread.pathname;

	  return spread;
	}

	function removeMatchingHeaders(regex, headers) {
	  var lastValue;
	  for (var header in headers) {
	    if (regex.test(header)) {
	      lastValue = headers[header];
	      delete headers[header];
	    }
	  }
	  return (lastValue === null || typeof lastValue === "undefined") ?
	    undefined : String(lastValue).trim();
	}

	function createErrorType(code, message, baseClass) {
	  // Create constructor
	  function CustomError(properties) {
	    // istanbul ignore else
	    if (isFunction(Error.captureStackTrace)) {
	      Error.captureStackTrace(this, this.constructor);
	    }
	    Object.assign(this, properties || {});
	    this.code = code;
	    this.message = this.cause ? message + ": " + this.cause.message : message;
	  }

	  // Attach constructor and set default properties
	  CustomError.prototype = new (baseClass || Error)();
	  Object.defineProperties(CustomError.prototype, {
	    constructor: {
	      value: CustomError,
	      enumerable: false,
	    },
	    name: {
	      value: "Error [" + code + "]",
	      enumerable: false,
	    },
	  });
	  return CustomError;
	}

	function destroyRequest(request, error) {
	  for (var event of events) {
	    request.removeListener(event, eventHandlers[event]);
	  }
	  request.on("error", noop);
	  request.destroy(error);
	}

	function isSubdomain(subdomain, domain) {
	  assert(isString(subdomain) && isString(domain));
	  var dot = subdomain.length - domain.length - 1;
	  return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
	}

	function isString(value) {
	  return typeof value === "string" || value instanceof String;
	}

	function isFunction(value) {
	  return typeof value === "function";
	}

	function isBuffer(value) {
	  return typeof value === "object" && ("length" in value);
	}

	function isURL(value) {
	  return URL && value instanceof URL;
	}

	// Exports
	followRedirects$1.exports = wrap({ http: http, https: https });
	followRedirects$1.exports.wrap = wrap;
	return followRedirects$1.exports;
}

var followRedirectsExports = requireFollowRedirects();
var followRedirects = /*@__PURE__*/getDefaultExportFromCjs(followRedirectsExports);

const VERSION = "1.7.7";

function parseProtocol(url) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || '';
}

const DATA_URL_PATTERN = /^(?:([^;]+);)?(?:[^;]+;)?(base64|),([\s\S]*)$/;

/**
 * Parse data uri to a Buffer or Blob
 *
 * @param {String} uri
 * @param {?Boolean} asBlob
 * @param {?Object} options
 * @param {?Function} options.Blob
 *
 * @returns {Buffer|Blob}
 */
function fromDataURI(uri, asBlob, options) {
  const _Blob = options && options.Blob || platform.classes.Blob;
  const protocol = parseProtocol(uri);

  if (asBlob === undefined && _Blob) {
    asBlob = true;
  }

  if (protocol === 'data') {
    uri = protocol.length ? uri.slice(protocol.length + 1) : uri;

    const match = DATA_URL_PATTERN.exec(uri);

    if (!match) {
      throw new AxiosError('Invalid URL', AxiosError.ERR_INVALID_URL);
    }

    const mime = match[1];
    const isBase64 = match[2];
    const body = match[3];
    const buffer = Buffer.from(decodeURIComponent(body), isBase64 ? 'base64' : 'utf8');

    if (asBlob) {
      if (!_Blob) {
        throw new AxiosError('Blob is not supported', AxiosError.ERR_NOT_SUPPORT);
      }

      return new _Blob([buffer], {type: mime});
    }

    return buffer;
  }

  throw new AxiosError('Unsupported protocol ' + protocol, AxiosError.ERR_NOT_SUPPORT);
}

const kInternals = Symbol('internals');

class AxiosTransformStream extends stream.Transform{
  constructor(options) {
    options = utils$2.toFlatObject(options, {
      maxRate: 0,
      chunkSize: 64 * 1024,
      minChunkSize: 100,
      timeWindow: 500,
      ticksRate: 2,
      samplesCount: 15
    }, null, (prop, source) => {
      return !utils$2.isUndefined(source[prop]);
    });

    super({
      readableHighWaterMark: options.chunkSize
    });

    const internals = this[kInternals] = {
      timeWindow: options.timeWindow,
      chunkSize: options.chunkSize,
      maxRate: options.maxRate,
      minChunkSize: options.minChunkSize,
      bytesSeen: 0,
      isCaptured: false,
      notifiedBytesLoaded: 0,
      ts: Date.now(),
      bytes: 0,
      onReadCallback: null
    };

    this.on('newListener', event => {
      if (event === 'progress') {
        if (!internals.isCaptured) {
          internals.isCaptured = true;
        }
      }
    });
  }

  _read(size) {
    const internals = this[kInternals];

    if (internals.onReadCallback) {
      internals.onReadCallback();
    }

    return super._read(size);
  }

  _transform(chunk, encoding, callback) {
    const internals = this[kInternals];
    const maxRate = internals.maxRate;

    const readableHighWaterMark = this.readableHighWaterMark;

    const timeWindow = internals.timeWindow;

    const divider = 1000 / timeWindow;
    const bytesThreshold = (maxRate / divider);
    const minChunkSize = internals.minChunkSize !== false ? Math.max(internals.minChunkSize, bytesThreshold * 0.01) : 0;

    const pushChunk = (_chunk, _callback) => {
      const bytes = Buffer.byteLength(_chunk);
      internals.bytesSeen += bytes;
      internals.bytes += bytes;

      internals.isCaptured && this.emit('progress', internals.bytesSeen);

      if (this.push(_chunk)) {
        process.nextTick(_callback);
      } else {
        internals.onReadCallback = () => {
          internals.onReadCallback = null;
          process.nextTick(_callback);
        };
      }
    };

    const transformChunk = (_chunk, _callback) => {
      const chunkSize = Buffer.byteLength(_chunk);
      let chunkRemainder = null;
      let maxChunkSize = readableHighWaterMark;
      let bytesLeft;
      let passed = 0;

      if (maxRate) {
        const now = Date.now();

        if (!internals.ts || (passed = (now - internals.ts)) >= timeWindow) {
          internals.ts = now;
          bytesLeft = bytesThreshold - internals.bytes;
          internals.bytes = bytesLeft < 0 ? -bytesLeft : 0;
          passed = 0;
        }

        bytesLeft = bytesThreshold - internals.bytes;
      }

      if (maxRate) {
        if (bytesLeft <= 0) {
          // next time window
          return setTimeout(() => {
            _callback(null, _chunk);
          }, timeWindow - passed);
        }

        if (bytesLeft < maxChunkSize) {
          maxChunkSize = bytesLeft;
        }
      }

      if (maxChunkSize && chunkSize > maxChunkSize && (chunkSize - maxChunkSize) > minChunkSize) {
        chunkRemainder = _chunk.subarray(maxChunkSize);
        _chunk = _chunk.subarray(0, maxChunkSize);
      }

      pushChunk(_chunk, chunkRemainder ? () => {
        process.nextTick(_callback, null, chunkRemainder);
      } : _callback);
    };

    transformChunk(chunk, function transformNextChunk(err, _chunk) {
      if (err) {
        return callback(err);
      }

      if (_chunk) {
        transformChunk(_chunk, transformNextChunk);
      } else {
        callback(null);
      }
    });
  }
}

var AxiosTransformStream$1 = AxiosTransformStream;

const {asyncIterator} = Symbol;

const readBlob = async function* (blob) {
  if (blob.stream) {
    yield* blob.stream();
  } else if (blob.arrayBuffer) {
    yield await blob.arrayBuffer();
  } else if (blob[asyncIterator]) {
    yield* blob[asyncIterator]();
  } else {
    yield blob;
  }
};

var readBlob$1 = readBlob;

const BOUNDARY_ALPHABET = utils$2.ALPHABET.ALPHA_DIGIT + '-_';

const textEncoder = new require$$1.TextEncoder();

const CRLF = '\r\n';
const CRLF_BYTES = textEncoder.encode(CRLF);
const CRLF_BYTES_COUNT = 2;

class FormDataPart {
  constructor(name, value) {
    const {escapeName} = this.constructor;
    const isStringValue = utils$2.isString(value);

    let headers = `Content-Disposition: form-data; name="${escapeName(name)}"${
      !isStringValue && value.name ? `; filename="${escapeName(value.name)}"` : ''
    }${CRLF}`;

    if (isStringValue) {
      value = textEncoder.encode(String(value).replace(/\r?\n|\r\n?/g, CRLF));
    } else {
      headers += `Content-Type: ${value.type || "application/octet-stream"}${CRLF}`;
    }

    this.headers = textEncoder.encode(headers + CRLF);

    this.contentLength = isStringValue ? value.byteLength : value.size;

    this.size = this.headers.byteLength + this.contentLength + CRLF_BYTES_COUNT;

    this.name = name;
    this.value = value;
  }

  async *encode(){
    yield this.headers;

    const {value} = this;

    if(utils$2.isTypedArray(value)) {
      yield value;
    } else {
      yield* readBlob$1(value);
    }

    yield CRLF_BYTES;
  }

  static escapeName(name) {
      return String(name).replace(/[\r\n"]/g, (match) => ({
        '\r' : '%0D',
        '\n' : '%0A',
        '"' : '%22',
      }[match]));
  }
}

const formDataToStream = (form, headersHandler, options) => {
  const {
    tag = 'form-data-boundary',
    size = 25,
    boundary = tag + '-' + utils$2.generateString(size, BOUNDARY_ALPHABET)
  } = options || {};

  if(!utils$2.isFormData(form)) {
    throw TypeError('FormData instance required');
  }

  if (boundary.length < 1 || boundary.length > 70) {
    throw Error('boundary must be 10-70 characters long')
  }

  const boundaryBytes = textEncoder.encode('--' + boundary + CRLF);
  const footerBytes = textEncoder.encode('--' + boundary + '--' + CRLF + CRLF);
  let contentLength = footerBytes.byteLength;

  const parts = Array.from(form.entries()).map(([name, value]) => {
    const part = new FormDataPart(name, value);
    contentLength += part.size;
    return part;
  });

  contentLength += boundaryBytes.byteLength * parts.length;

  contentLength = utils$2.toFiniteNumber(contentLength);

  const computedHeaders = {
    'Content-Type': `multipart/form-data; boundary=${boundary}`
  };

  if (Number.isFinite(contentLength)) {
    computedHeaders['Content-Length'] = contentLength;
  }

  headersHandler && headersHandler(computedHeaders);

  return stream.Readable.from((async function *() {
    for(const part of parts) {
      yield boundaryBytes;
      yield* part.encode();
    }

    yield footerBytes;
  })());
};

var formDataToStream$1 = formDataToStream;

class ZlibHeaderTransformStream extends stream.Transform {
  __transform(chunk, encoding, callback) {
    this.push(chunk);
    callback();
  }

  _transform(chunk, encoding, callback) {
    if (chunk.length !== 0) {
      this._transform = this.__transform;

      // Add Default Compression headers if no zlib headers are present
      if (chunk[0] !== 120) { // Hex: 78
        const header = Buffer.alloc(2);
        header[0] = 120; // Hex: 78
        header[1] = 156; // Hex: 9C 
        this.push(header, encoding);
      }
    }

    this.__transform(chunk, encoding, callback);
  }
}

var ZlibHeaderTransformStream$1 = ZlibHeaderTransformStream;

const callbackify = (fn, reducer) => {
  return utils$2.isAsyncFn(fn) ? function (...args) {
    const cb = args.pop();
    fn.apply(this, args).then((value) => {
      try {
        reducer ? cb(null, ...reducer(value)) : cb(null, value);
      } catch (err) {
        cb(err);
      }
    }, cb);
  } : fn;
};

var callbackify$1 = callbackify;

/**
 * Calculate data maxRate
 * @param {Number} [samplesCount= 10]
 * @param {Number} [min= 1000]
 * @returns {Function}
 */
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;

  min = min !== undefined ? min : 1000;

  return function push(chunkLength) {
    const now = Date.now();

    const startedAt = timestamps[tail];

    if (!firstSampleTS) {
      firstSampleTS = now;
    }

    bytes[head] = chunkLength;
    timestamps[head] = now;

    let i = tail;
    let bytesCount = 0;

    while (i !== head) {
      bytesCount += bytes[i++];
      i = i % samplesCount;
    }

    head = (head + 1) % samplesCount;

    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }

    if (now - firstSampleTS < min) {
      return;
    }

    const passed = startedAt && now - startedAt;

    return passed ? Math.round(bytesCount * 1000 / passed) : undefined;
  };
}

/**
 * Throttle decorator
 * @param {Function} fn
 * @param {Number} freq
 * @return {Function}
 */
function throttle(fn, freq) {
  let timestamp = 0;
  let threshold = 1000 / freq;
  let lastArgs;
  let timer;

  const invoke = (args, now = Date.now()) => {
    timestamp = now;
    lastArgs = null;
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
    fn.apply(null, args);
  };

  const throttled = (...args) => {
    const now = Date.now();
    const passed = now - timestamp;
    if ( passed >= threshold) {
      invoke(args, now);
    } else {
      lastArgs = args;
      if (!timer) {
        timer = setTimeout(() => {
          timer = null;
          invoke(lastArgs);
        }, threshold - passed);
      }
    }
  };

  const flush = () => lastArgs && invoke(lastArgs);

  return [throttled, flush];
}

const progressEventReducer = (listener, isDownloadStream, freq = 3) => {
  let bytesNotified = 0;
  const _speedometer = speedometer(50, 250);

  return throttle(e => {
    const loaded = e.loaded;
    const total = e.lengthComputable ? e.total : undefined;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;

    bytesNotified = loaded;

    const data = {
      loaded,
      total,
      progress: total ? (loaded / total) : undefined,
      bytes: progressBytes,
      rate: rate ? rate : undefined,
      estimated: rate && total && inRange ? (total - loaded) / rate : undefined,
      event: e,
      lengthComputable: total != null,
      [isDownloadStream ? 'download' : 'upload']: true
    };

    listener(data);
  }, freq);
};

const progressEventDecorator = (total, throttled) => {
  const lengthComputable = total != null;

  return [(loaded) => throttled[0]({
    lengthComputable,
    total,
    loaded
  }), throttled[1]];
};

const asyncDecorator = (fn) => (...args) => utils$2.asap(() => fn(...args));

const zlibOptions = {
  flush: zlib$1.constants.Z_SYNC_FLUSH,
  finishFlush: zlib$1.constants.Z_SYNC_FLUSH
};

const brotliOptions = {
  flush: zlib$1.constants.BROTLI_OPERATION_FLUSH,
  finishFlush: zlib$1.constants.BROTLI_OPERATION_FLUSH
};

const isBrotliSupported = utils$2.isFunction(zlib$1.createBrotliDecompress);

const {http: httpFollow, https: httpsFollow} = followRedirects;

const isHttps = /https:?/;

const supportedProtocols = platform.protocols.map(protocol => {
  return protocol + ':';
});

const flushOnFinish = (stream, [throttled, flush]) => {
  stream
    .on('end', flush)
    .on('error', flush);

  return throttled;
};

/**
 * If the proxy or config beforeRedirects functions are defined, call them with the options
 * object.
 *
 * @param {Object<string, any>} options - The options object that was passed to the request.
 *
 * @returns {Object<string, any>}
 */
function dispatchBeforeRedirect(options, responseDetails) {
  if (options.beforeRedirects.proxy) {
    options.beforeRedirects.proxy(options);
  }
  if (options.beforeRedirects.config) {
    options.beforeRedirects.config(options, responseDetails);
  }
}

/**
 * If the proxy or config afterRedirects functions are defined, call them with the options
 *
 * @param {http.ClientRequestArgs} options
 * @param {AxiosProxyConfig} configProxy configuration from Axios options object
 * @param {string} location
 *
 * @returns {http.ClientRequestArgs}
 */
function setProxy(options, configProxy, location) {
  let proxy = configProxy;
  if (!proxy && proxy !== false) {
    const proxyUrl = proxyFromEnvExports.getProxyForUrl(location);
    if (proxyUrl) {
      proxy = new URL(proxyUrl);
    }
  }
  if (proxy) {
    // Basic proxy authorization
    if (proxy.username) {
      proxy.auth = (proxy.username || '') + ':' + (proxy.password || '');
    }

    if (proxy.auth) {
      // Support proxy auth object form
      if (proxy.auth.username || proxy.auth.password) {
        proxy.auth = (proxy.auth.username || '') + ':' + (proxy.auth.password || '');
      }
      const base64 = Buffer
        .from(proxy.auth, 'utf8')
        .toString('base64');
      options.headers['Proxy-Authorization'] = 'Basic ' + base64;
    }

    options.headers.host = options.hostname + (options.port ? ':' + options.port : '');
    const proxyHost = proxy.hostname || proxy.host;
    options.hostname = proxyHost;
    // Replace 'host' since options is not a URL object
    options.host = proxyHost;
    options.port = proxy.port;
    options.path = location;
    if (proxy.protocol) {
      options.protocol = proxy.protocol.includes(':') ? proxy.protocol : `${proxy.protocol}:`;
    }
  }

  options.beforeRedirects.proxy = function beforeRedirect(redirectOptions) {
    // Configure proxy for redirected request, passing the original config proxy to apply
    // the exact same logic as if the redirected request was performed by axios directly.
    setProxy(redirectOptions, configProxy, redirectOptions.href);
  };
}

const isHttpAdapterSupported = typeof process !== 'undefined' && utils$2.kindOf(process) === 'process';

// temporary hotfix

const wrapAsync = (asyncExecutor) => {
  return new Promise((resolve, reject) => {
    let onDone;
    let isDone;

    const done = (value, isRejected) => {
      if (isDone) return;
      isDone = true;
      onDone && onDone(value, isRejected);
    };

    const _resolve = (value) => {
      done(value);
      resolve(value);
    };

    const _reject = (reason) => {
      done(reason, true);
      reject(reason);
    };

    asyncExecutor(_resolve, _reject, (onDoneHandler) => (onDone = onDoneHandler)).catch(_reject);
  })
};

const resolveFamily = ({address, family}) => {
  if (!utils$2.isString(address)) {
    throw TypeError('address must be a string');
  }
  return ({
    address,
    family: family || (address.indexOf('.') < 0 ? 6 : 4)
  });
};

const buildAddressEntry = (address, family) => resolveFamily(utils$2.isObject(address) ? address : {address, family});

/*eslint consistent-return:0*/
var httpAdapter = isHttpAdapterSupported && function httpAdapter(config) {
  return wrapAsync(async function dispatchHttpRequest(resolve, reject, onDone) {
    let {data, lookup, family} = config;
    const {responseType, responseEncoding} = config;
    const method = config.method.toUpperCase();
    let isDone;
    let rejected = false;
    let req;

    if (lookup) {
      const _lookup = callbackify$1(lookup, (value) => utils$2.isArray(value) ? value : [value]);
      // hotfix to support opt.all option which is required for node 20.x
      lookup = (hostname, opt, cb) => {
        _lookup(hostname, opt, (err, arg0, arg1) => {
          if (err) {
            return cb(err);
          }

          const addresses = utils$2.isArray(arg0) ? arg0.map(addr => buildAddressEntry(addr)) : [buildAddressEntry(arg0, arg1)];

          opt.all ? cb(err, addresses) : cb(err, addresses[0].address, addresses[0].family);
        });
      };
    }

    // temporary internal emitter until the AxiosRequest class will be implemented
    const emitter = new require$$2$1.EventEmitter();

    const onFinished = () => {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(abort);
      }

      if (config.signal) {
        config.signal.removeEventListener('abort', abort);
      }

      emitter.removeAllListeners();
    };

    onDone((value, isRejected) => {
      isDone = true;
      if (isRejected) {
        rejected = true;
        onFinished();
      }
    });

    function abort(reason) {
      emitter.emit('abort', !reason || reason.type ? new CanceledError(null, config, req) : reason);
    }

    emitter.once('abort', reject);

    if (config.cancelToken || config.signal) {
      config.cancelToken && config.cancelToken.subscribe(abort);
      if (config.signal) {
        config.signal.aborted ? abort() : config.signal.addEventListener('abort', abort);
      }
    }

    // Parse url
    const fullPath = buildFullPath(config.baseURL, config.url);
    const parsed = new URL(fullPath, platform.hasBrowserEnv ? platform.origin : undefined);
    const protocol = parsed.protocol || supportedProtocols[0];

    if (protocol === 'data:') {
      let convertedData;

      if (method !== 'GET') {
        return settle(resolve, reject, {
          status: 405,
          statusText: 'method not allowed',
          headers: {},
          config
        });
      }

      try {
        convertedData = fromDataURI(config.url, responseType === 'blob', {
          Blob: config.env && config.env.Blob
        });
      } catch (err) {
        throw AxiosError.from(err, AxiosError.ERR_BAD_REQUEST, config);
      }

      if (responseType === 'text') {
        convertedData = convertedData.toString(responseEncoding);

        if (!responseEncoding || responseEncoding === 'utf8') {
          convertedData = utils$2.stripBOM(convertedData);
        }
      } else if (responseType === 'stream') {
        convertedData = stream.Readable.from(convertedData);
      }

      return settle(resolve, reject, {
        data: convertedData,
        status: 200,
        statusText: 'OK',
        headers: new AxiosHeaders$1(),
        config
      });
    }

    if (supportedProtocols.indexOf(protocol) === -1) {
      return reject(new AxiosError(
        'Unsupported protocol ' + protocol,
        AxiosError.ERR_BAD_REQUEST,
        config
      ));
    }

    const headers = AxiosHeaders$1.from(config.headers).normalize();

    // Set User-Agent (required by some servers)
    // See https://github.com/axios/axios/issues/69
    // User-Agent is specified; handle case where no UA header is desired
    // Only set header if it hasn't been set in config
    headers.set('User-Agent', 'axios/' + VERSION, false);

    const {onUploadProgress, onDownloadProgress} = config;
    const maxRate = config.maxRate;
    let maxUploadRate = undefined;
    let maxDownloadRate = undefined;

    // support for spec compliant FormData objects
    if (utils$2.isSpecCompliantForm(data)) {
      const userBoundary = headers.getContentType(/boundary=([-_\w\d]{10,70})/i);

      data = formDataToStream$1(data, (formHeaders) => {
        headers.set(formHeaders);
      }, {
        tag: `axios-${VERSION}-boundary`,
        boundary: userBoundary && userBoundary[1] || undefined
      });
      // support for https://www.npmjs.com/package/form-data api
    } else if (utils$2.isFormData(data) && utils$2.isFunction(data.getHeaders)) {
      headers.set(data.getHeaders());

      if (!headers.hasContentLength()) {
        try {
          const knownLength = await require$$1.promisify(data.getLength).call(data);
          Number.isFinite(knownLength) && knownLength >= 0 && headers.setContentLength(knownLength);
          /*eslint no-empty:0*/
        } catch (e) {
        }
      }
    } else if (utils$2.isBlob(data)) {
      data.size && headers.setContentType(data.type || 'application/octet-stream');
      headers.setContentLength(data.size || 0);
      data = stream.Readable.from(readBlob$1(data));
    } else if (data && !utils$2.isStream(data)) {
      if (Buffer.isBuffer(data)) ; else if (utils$2.isArrayBuffer(data)) {
        data = Buffer.from(new Uint8Array(data));
      } else if (utils$2.isString(data)) {
        data = Buffer.from(data, 'utf-8');
      } else {
        return reject(new AxiosError(
          'Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream',
          AxiosError.ERR_BAD_REQUEST,
          config
        ));
      }

      // Add Content-Length header if data exists
      headers.setContentLength(data.length, false);

      if (config.maxBodyLength > -1 && data.length > config.maxBodyLength) {
        return reject(new AxiosError(
          'Request body larger than maxBodyLength limit',
          AxiosError.ERR_BAD_REQUEST,
          config
        ));
      }
    }

    const contentLength = utils$2.toFiniteNumber(headers.getContentLength());

    if (utils$2.isArray(maxRate)) {
      maxUploadRate = maxRate[0];
      maxDownloadRate = maxRate[1];
    } else {
      maxUploadRate = maxDownloadRate = maxRate;
    }

    if (data && (onUploadProgress || maxUploadRate)) {
      if (!utils$2.isStream(data)) {
        data = stream.Readable.from(data, {objectMode: false});
      }

      data = stream.pipeline([data, new AxiosTransformStream$1({
        maxRate: utils$2.toFiniteNumber(maxUploadRate)
      })], utils$2.noop);

      onUploadProgress && data.on('progress', flushOnFinish(
        data,
        progressEventDecorator(
          contentLength,
          progressEventReducer(asyncDecorator(onUploadProgress), false, 3)
        )
      ));
    }

    // HTTP basic authentication
    let auth = undefined;
    if (config.auth) {
      const username = config.auth.username || '';
      const password = config.auth.password || '';
      auth = username + ':' + password;
    }

    if (!auth && parsed.username) {
      const urlUsername = parsed.username;
      const urlPassword = parsed.password;
      auth = urlUsername + ':' + urlPassword;
    }

    auth && headers.delete('authorization');

    let path;

    try {
      path = buildURL(
        parsed.pathname + parsed.search,
        config.params,
        config.paramsSerializer
      ).replace(/^\?/, '');
    } catch (err) {
      const customErr = new Error(err.message);
      customErr.config = config;
      customErr.url = config.url;
      customErr.exists = true;
      return reject(customErr);
    }

    headers.set(
      'Accept-Encoding',
      'gzip, compress, deflate' + (isBrotliSupported ? ', br' : ''), false
      );

    const options = {
      path,
      method: method,
      headers: headers.toJSON(),
      agents: { http: config.httpAgent, https: config.httpsAgent },
      auth,
      protocol,
      family,
      beforeRedirect: dispatchBeforeRedirect,
      beforeRedirects: {}
    };

    // cacheable-lookup integration hotfix
    !utils$2.isUndefined(lookup) && (options.lookup = lookup);

    if (config.socketPath) {
      options.socketPath = config.socketPath;
    } else {
      options.hostname = parsed.hostname.startsWith("[") ? parsed.hostname.slice(1, -1) : parsed.hostname;
      options.port = parsed.port;
      setProxy(options, config.proxy, protocol + '//' + parsed.hostname + (parsed.port ? ':' + parsed.port : '') + options.path);
    }

    let transport;
    const isHttpsRequest = isHttps.test(options.protocol);
    options.agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;
    if (config.transport) {
      transport = config.transport;
    } else if (config.maxRedirects === 0) {
      transport = isHttpsRequest ? require$$2 : require$$0$2;
    } else {
      if (config.maxRedirects) {
        options.maxRedirects = config.maxRedirects;
      }
      if (config.beforeRedirect) {
        options.beforeRedirects.config = config.beforeRedirect;
      }
      transport = isHttpsRequest ? httpsFollow : httpFollow;
    }

    if (config.maxBodyLength > -1) {
      options.maxBodyLength = config.maxBodyLength;
    } else {
      // follow-redirects does not skip comparison, so it should always succeed for axios -1 unlimited
      options.maxBodyLength = Infinity;
    }

    if (config.insecureHTTPParser) {
      options.insecureHTTPParser = config.insecureHTTPParser;
    }

    // Create the request
    req = transport.request(options, function handleResponse(res) {
      if (req.destroyed) return;

      const streams = [res];

      const responseLength = +res.headers['content-length'];

      if (onDownloadProgress || maxDownloadRate) {
        const transformStream = new AxiosTransformStream$1({
          maxRate: utils$2.toFiniteNumber(maxDownloadRate)
        });

        onDownloadProgress && transformStream.on('progress', flushOnFinish(
          transformStream,
          progressEventDecorator(
            responseLength,
            progressEventReducer(asyncDecorator(onDownloadProgress), true, 3)
          )
        ));

        streams.push(transformStream);
      }

      // decompress the response body transparently if required
      let responseStream = res;

      // return the last request in case of redirects
      const lastRequest = res.req || req;

      // if decompress disabled we should not decompress
      if (config.decompress !== false && res.headers['content-encoding']) {
        // if no content, but headers still say that it is encoded,
        // remove the header not confuse downstream operations
        if (method === 'HEAD' || res.statusCode === 204) {
          delete res.headers['content-encoding'];
        }

        switch ((res.headers['content-encoding'] || '').toLowerCase()) {
        /*eslint default-case:0*/
        case 'gzip':
        case 'x-gzip':
        case 'compress':
        case 'x-compress':
          // add the unzipper to the body stream processing pipeline
          streams.push(zlib$1.createUnzip(zlibOptions));

          // remove the content-encoding in order to not confuse downstream operations
          delete res.headers['content-encoding'];
          break;
        case 'deflate':
          streams.push(new ZlibHeaderTransformStream$1());

          // add the unzipper to the body stream processing pipeline
          streams.push(zlib$1.createUnzip(zlibOptions));

          // remove the content-encoding in order to not confuse downstream operations
          delete res.headers['content-encoding'];
          break;
        case 'br':
          if (isBrotliSupported) {
            streams.push(zlib$1.createBrotliDecompress(brotliOptions));
            delete res.headers['content-encoding'];
          }
        }
      }

      responseStream = streams.length > 1 ? stream.pipeline(streams, utils$2.noop) : streams[0];

      const offListeners = stream.finished(responseStream, () => {
        offListeners();
        onFinished();
      });

      const response = {
        status: res.statusCode,
        statusText: res.statusMessage,
        headers: new AxiosHeaders$1(res.headers),
        config,
        request: lastRequest
      };

      if (responseType === 'stream') {
        response.data = responseStream;
        settle(resolve, reject, response);
      } else {
        const responseBuffer = [];
        let totalResponseBytes = 0;

        responseStream.on('data', function handleStreamData(chunk) {
          responseBuffer.push(chunk);
          totalResponseBytes += chunk.length;

          // make sure the content length is not over the maxContentLength if specified
          if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {
            // stream.destroy() emit aborted event before calling reject() on Node.js v16
            rejected = true;
            responseStream.destroy();
            reject(new AxiosError('maxContentLength size of ' + config.maxContentLength + ' exceeded',
              AxiosError.ERR_BAD_RESPONSE, config, lastRequest));
          }
        });

        responseStream.on('aborted', function handlerStreamAborted() {
          if (rejected) {
            return;
          }

          const err = new AxiosError(
            'maxContentLength size of ' + config.maxContentLength + ' exceeded',
            AxiosError.ERR_BAD_RESPONSE,
            config,
            lastRequest
          );
          responseStream.destroy(err);
          reject(err);
        });

        responseStream.on('error', function handleStreamError(err) {
          if (req.destroyed) return;
          reject(AxiosError.from(err, null, config, lastRequest));
        });

        responseStream.on('end', function handleStreamEnd() {
          try {
            let responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);
            if (responseType !== 'arraybuffer') {
              responseData = responseData.toString(responseEncoding);
              if (!responseEncoding || responseEncoding === 'utf8') {
                responseData = utils$2.stripBOM(responseData);
              }
            }
            response.data = responseData;
          } catch (err) {
            return reject(AxiosError.from(err, null, config, response.request, response));
          }
          settle(resolve, reject, response);
        });
      }

      emitter.once('abort', err => {
        if (!responseStream.destroyed) {
          responseStream.emit('error', err);
          responseStream.destroy();
        }
      });
    });

    emitter.once('abort', err => {
      reject(err);
      req.destroy(err);
    });

    // Handle errors
    req.on('error', function handleRequestError(err) {
      // @todo remove
      // if (req.aborted && err.code !== AxiosError.ERR_FR_TOO_MANY_REDIRECTS) return;
      reject(AxiosError.from(err, null, config, req));
    });

    // set tcp keep alive to prevent drop connection by peer
    req.on('socket', function handleRequestSocket(socket) {
      // default interval of sending ack packet is 1 minute
      socket.setKeepAlive(true, 1000 * 60);
    });

    // Handle request timeout
    if (config.timeout) {
      // This is forcing a int timeout to avoid problems if the `req` interface doesn't handle other types.
      const timeout = parseInt(config.timeout, 10);

      if (Number.isNaN(timeout)) {
        reject(new AxiosError(
          'error trying to parse `config.timeout` to int',
          AxiosError.ERR_BAD_OPTION_VALUE,
          config,
          req
        ));

        return;
      }

      // Sometime, the response will be very slow, and does not respond, the connect event will be block by event loop system.
      // And timer callback will be fired, and abort() will be invoked before connection, then get "socket hang up" and code ECONNRESET.
      // At this time, if we have a large number of request, nodejs will hang up some socket on background. and the number will up and up.
      // And then these socket which be hang up will devouring CPU little by little.
      // ClientRequest.setTimeout will be fired on the specify milliseconds, and can make sure that abort() will be fired after connect.
      req.setTimeout(timeout, function handleRequestTimeout() {
        if (isDone) return;
        let timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';
        const transitional = config.transitional || transitionalDefaults;
        if (config.timeoutErrorMessage) {
          timeoutErrorMessage = config.timeoutErrorMessage;
        }
        reject(new AxiosError(
          timeoutErrorMessage,
          transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
          config,
          req
        ));
        abort();
      });
    }


    // Send the request
    if (utils$2.isStream(data)) {
      let ended = false;
      let errored = false;

      data.on('end', () => {
        ended = true;
      });

      data.once('error', err => {
        errored = true;
        req.destroy(err);
      });

      data.on('close', () => {
        if (!ended && !errored) {
          abort(new CanceledError('Request stream has been aborted', config, req));
        }
      });

      data.pipe(req);
    } else {
      req.end(data);
    }
  });
};

var isURLSameOrigin = platform.hasStandardBrowserEnv ?

// Standard browser envs have full support of the APIs needed to test
// whether the request URL is of the same origin as current location.
  (function standardBrowserEnv() {
    const msie = platform.navigator && /(msie|trident)/i.test(platform.navigator.userAgent);
    const urlParsingNode = document.createElement('a');
    let originURL;

    /**
    * Parse a URL to discover its components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */
    function resolveURL(url) {
      let href = url;

      if (msie) {
        // IE needs attribute set twice to normalize properties
        urlParsingNode.setAttribute('href', href);
        href = urlParsingNode.href;
      }

      urlParsingNode.setAttribute('href', href);

      // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
          urlParsingNode.pathname :
          '/' + urlParsingNode.pathname
      };
    }

    originURL = resolveURL(window.location.href);

    /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */
    return function isURLSameOrigin(requestURL) {
      const parsed = (utils$2.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
      return (parsed.protocol === originURL.protocol &&
          parsed.host === originURL.host);
    };
  })() :

  // Non standard browser envs (web workers, react-native) lack needed support.
  (function nonStandardBrowserEnv() {
    return function isURLSameOrigin() {
      return true;
    };
  })();

var cookies = platform.hasStandardBrowserEnv ?

  // Standard browser envs support document.cookie
  {
    write(name, value, expires, path, domain, secure) {
      const cookie = [name + '=' + encodeURIComponent(value)];

      utils$2.isNumber(expires) && cookie.push('expires=' + new Date(expires).toGMTString());

      utils$2.isString(path) && cookie.push('path=' + path);

      utils$2.isString(domain) && cookie.push('domain=' + domain);

      secure === true && cookie.push('secure');

      document.cookie = cookie.join('; ');
    },

    read(name) {
      const match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
      return (match ? decodeURIComponent(match[3]) : null);
    },

    remove(name) {
      this.write(name, '', Date.now() - 86400000);
    }
  }

  :

  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {},
    read() {
      return null;
    },
    remove() {}
  };

const headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? { ...thing } : thing;

/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 *
 * @returns {Object} New object resulting from merging config2 to config1
 */
function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  const config = {};

  function getMergedValue(target, source, caseless) {
    if (utils$2.isPlainObject(target) && utils$2.isPlainObject(source)) {
      return utils$2.merge.call({caseless}, target, source);
    } else if (utils$2.isPlainObject(source)) {
      return utils$2.merge({}, source);
    } else if (utils$2.isArray(source)) {
      return source.slice();
    }
    return source;
  }

  // eslint-disable-next-line consistent-return
  function mergeDeepProperties(a, b, caseless) {
    if (!utils$2.isUndefined(b)) {
      return getMergedValue(a, b, caseless);
    } else if (!utils$2.isUndefined(a)) {
      return getMergedValue(undefined, a, caseless);
    }
  }

  // eslint-disable-next-line consistent-return
  function valueFromConfig2(a, b) {
    if (!utils$2.isUndefined(b)) {
      return getMergedValue(undefined, b);
    }
  }

  // eslint-disable-next-line consistent-return
  function defaultToConfig2(a, b) {
    if (!utils$2.isUndefined(b)) {
      return getMergedValue(undefined, b);
    } else if (!utils$2.isUndefined(a)) {
      return getMergedValue(undefined, a);
    }
  }

  // eslint-disable-next-line consistent-return
  function mergeDirectKeys(a, b, prop) {
    if (prop in config2) {
      return getMergedValue(a, b);
    } else if (prop in config1) {
      return getMergedValue(undefined, a);
    }
  }

  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a, b) => mergeDeepProperties(headersToObject(a), headersToObject(b), true)
  };

  utils$2.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    const merge = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge(config1[prop], config2[prop], prop);
    (utils$2.isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue);
  });

  return config;
}

var resolveConfig = (config) => {
  const newConfig = mergeConfig({}, config);

  let {data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth} = newConfig;

  newConfig.headers = headers = AxiosHeaders$1.from(headers);

  newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url), config.params, config.paramsSerializer);

  // HTTP basic authentication
  if (auth) {
    headers.set('Authorization', 'Basic ' +
      btoa((auth.username || '') + ':' + (auth.password ? unescape(encodeURIComponent(auth.password)) : ''))
    );
  }

  let contentType;

  if (utils$2.isFormData(data)) {
    if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
      headers.setContentType(undefined); // Let the browser set it
    } else if ((contentType = headers.getContentType()) !== false) {
      // fix semicolon duplication issue for ReactNative FormData implementation
      const [type, ...tokens] = contentType ? contentType.split(';').map(token => token.trim()).filter(Boolean) : [];
      headers.setContentType([type || 'multipart/form-data', ...tokens].join('; '));
    }
  }

  // Add xsrf header
  // This is only done if running in a standard browser environment.
  // Specifically not if we're in a web worker, or react-native.

  if (platform.hasStandardBrowserEnv) {
    withXSRFToken && utils$2.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));

    if (withXSRFToken || (withXSRFToken !== false && isURLSameOrigin(newConfig.url))) {
      // Add xsrf header
      const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);

      if (xsrfValue) {
        headers.set(xsrfHeaderName, xsrfValue);
      }
    }
  }

  return newConfig;
};

const isXHRAdapterSupported = typeof XMLHttpRequest !== 'undefined';

var xhrAdapter = isXHRAdapterSupported && function (config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    const _config = resolveConfig(config);
    let requestData = _config.data;
    const requestHeaders = AxiosHeaders$1.from(_config.headers).normalize();
    let {responseType, onUploadProgress, onDownloadProgress} = _config;
    let onCanceled;
    let uploadThrottled, downloadThrottled;
    let flushUpload, flushDownload;

    function done() {
      flushUpload && flushUpload(); // flush events
      flushDownload && flushDownload(); // flush events

      _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);

      _config.signal && _config.signal.removeEventListener('abort', onCanceled);
    }

    let request = new XMLHttpRequest();

    request.open(_config.method.toUpperCase(), _config.url, true);

    // Set the request timeout in MS
    request.timeout = _config.timeout;

    function onloadend() {
      if (!request) {
        return;
      }
      // Prepare the response
      const responseHeaders = AxiosHeaders$1.from(
        'getAllResponseHeaders' in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === 'text' || responseType === 'json' ?
        request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      };

      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);

      // Clean up request
      request = null;
    }

    if ('onloadend' in request) {
      // Use onloadend if available
      request.onloadend = onloadend;
    } else {
      // Listen for ready state to emulate onloadend
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }

        // The request errored out and we didn't get a response, this will be
        // handled by onerror instead
        // With one exception: request that using file: protocol, most browsers
        // will return status as 0 even though it's a successful request
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
          return;
        }
        // readystate handler is calling before onerror or ontimeout handlers,
        // so we should call onloadend on the next 'tick'
        setTimeout(onloadend);
      };
    }

    // Handle browser request cancellation (as opposed to a manual cancellation)
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(new AxiosError('Request aborted', AxiosError.ECONNABORTED, config, request));

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(new AxiosError('Network Error', AxiosError.ERR_NETWORK, config, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = _config.timeout ? 'timeout of ' + _config.timeout + 'ms exceeded' : 'timeout exceeded';
      const transitional = _config.transitional || transitionalDefaults;
      if (_config.timeoutErrorMessage) {
        timeoutErrorMessage = _config.timeoutErrorMessage;
      }
      reject(new AxiosError(
        timeoutErrorMessage,
        transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
        config,
        request));

      // Clean up request
      request = null;
    };

    // Remove Content-Type if data is undefined
    requestData === undefined && requestHeaders.setContentType(null);

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils$2.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }

    // Add withCredentials to request if needed
    if (!utils$2.isUndefined(_config.withCredentials)) {
      request.withCredentials = !!_config.withCredentials;
    }

    // Add responseType to request if needed
    if (responseType && responseType !== 'json') {
      request.responseType = _config.responseType;
    }

    // Handle progress if needed
    if (onDownloadProgress) {
      ([downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true));
      request.addEventListener('progress', downloadThrottled);
    }

    // Not all browsers support upload events
    if (onUploadProgress && request.upload) {
      ([uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress));

      request.upload.addEventListener('progress', uploadThrottled);

      request.upload.addEventListener('loadend', flushUpload);
    }

    if (_config.cancelToken || _config.signal) {
      // Handle cancellation
      // eslint-disable-next-line func-names
      onCanceled = cancel => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);
        request.abort();
        request = null;
      };

      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
      if (_config.signal) {
        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener('abort', onCanceled);
      }
    }

    const protocol = parseProtocol(_config.url);

    if (protocol && platform.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError('Unsupported protocol ' + protocol + ':', AxiosError.ERR_BAD_REQUEST, config));
      return;
    }


    // Send the request
    request.send(requestData || null);
  });
};

const composeSignals = (signals, timeout) => {
  const {length} = (signals = signals ? signals.filter(Boolean) : []);

  if (timeout || length) {
    let controller = new AbortController();

    let aborted;

    const onabort = function (reason) {
      if (!aborted) {
        aborted = true;
        unsubscribe();
        const err = reason instanceof Error ? reason : this.reason;
        controller.abort(err instanceof AxiosError ? err : new CanceledError(err instanceof Error ? err.message : err));
      }
    };

    let timer = timeout && setTimeout(() => {
      timer = null;
      onabort(new AxiosError(`timeout ${timeout} of ms exceeded`, AxiosError.ETIMEDOUT));
    }, timeout);

    const unsubscribe = () => {
      if (signals) {
        timer && clearTimeout(timer);
        timer = null;
        signals.forEach(signal => {
          signal.unsubscribe ? signal.unsubscribe(onabort) : signal.removeEventListener('abort', onabort);
        });
        signals = null;
      }
    };

    signals.forEach((signal) => signal.addEventListener('abort', onabort));

    const {signal} = controller;

    signal.unsubscribe = () => utils$2.asap(unsubscribe);

    return signal;
  }
};

var composeSignals$1 = composeSignals;

const streamChunk = function* (chunk, chunkSize) {
  let len = chunk.byteLength;

  if (!chunkSize || len < chunkSize) {
    yield chunk;
    return;
  }

  let pos = 0;
  let end;

  while (pos < len) {
    end = pos + chunkSize;
    yield chunk.slice(pos, end);
    pos = end;
  }
};

const readBytes = async function* (iterable, chunkSize) {
  for await (const chunk of readStream(iterable)) {
    yield* streamChunk(chunk, chunkSize);
  }
};

const readStream = async function* (stream) {
  if (stream[Symbol.asyncIterator]) {
    yield* stream;
    return;
  }

  const reader = stream.getReader();
  try {
    for (;;) {
      const {done, value} = await reader.read();
      if (done) {
        break;
      }
      yield value;
    }
  } finally {
    await reader.cancel();
  }
};

const trackStream = (stream, chunkSize, onProgress, onFinish) => {
  const iterator = readBytes(stream, chunkSize);

  let bytes = 0;
  let done;
  let _onFinish = (e) => {
    if (!done) {
      done = true;
      onFinish && onFinish(e);
    }
  };

  return new ReadableStream({
    async pull(controller) {
      try {
        const {done, value} = await iterator.next();

        if (done) {
         _onFinish();
          controller.close();
          return;
        }

        let len = value.byteLength;
        if (onProgress) {
          let loadedBytes = bytes += len;
          onProgress(loadedBytes);
        }
        controller.enqueue(new Uint8Array(value));
      } catch (err) {
        _onFinish(err);
        throw err;
      }
    },
    cancel(reason) {
      _onFinish(reason);
      return iterator.return();
    }
  }, {
    highWaterMark: 2
  })
};

const isFetchSupported = typeof fetch === 'function' && typeof Request === 'function' && typeof Response === 'function';
const isReadableStreamSupported = isFetchSupported && typeof ReadableStream === 'function';

// used only inside the fetch adapter
const encodeText = isFetchSupported && (typeof TextEncoder === 'function' ?
    ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) :
    async (str) => new Uint8Array(await new Response(str).arrayBuffer())
);

const test = (fn, ...args) => {
  try {
    return !!fn(...args);
  } catch (e) {
    return false
  }
};

const supportsRequestStream = isReadableStreamSupported && test(() => {
  let duplexAccessed = false;

  const hasContentType = new Request(platform.origin, {
    body: new ReadableStream(),
    method: 'POST',
    get duplex() {
      duplexAccessed = true;
      return 'half';
    },
  }).headers.has('Content-Type');

  return duplexAccessed && !hasContentType;
});

const DEFAULT_CHUNK_SIZE = 64 * 1024;

const supportsResponseStream = isReadableStreamSupported &&
  test(() => utils$2.isReadableStream(new Response('').body));


const resolvers = {
  stream: supportsResponseStream && ((res) => res.body)
};

isFetchSupported && (((res) => {
  ['text', 'arrayBuffer', 'blob', 'formData', 'stream'].forEach(type => {
    !resolvers[type] && (resolvers[type] = utils$2.isFunction(res[type]) ? (res) => res[type]() :
      (_, config) => {
        throw new AxiosError(`Response type '${type}' is not supported`, AxiosError.ERR_NOT_SUPPORT, config);
      });
  });
})(new Response));

const getBodyLength = async (body) => {
  if (body == null) {
    return 0;
  }

  if(utils$2.isBlob(body)) {
    return body.size;
  }

  if(utils$2.isSpecCompliantForm(body)) {
    const _request = new Request(platform.origin, {
      method: 'POST',
      body,
    });
    return (await _request.arrayBuffer()).byteLength;
  }

  if(utils$2.isArrayBufferView(body) || utils$2.isArrayBuffer(body)) {
    return body.byteLength;
  }

  if(utils$2.isURLSearchParams(body)) {
    body = body + '';
  }

  if(utils$2.isString(body)) {
    return (await encodeText(body)).byteLength;
  }
};

const resolveBodyLength = async (headers, body) => {
  const length = utils$2.toFiniteNumber(headers.getContentLength());

  return length == null ? getBodyLength(body) : length;
};

var fetchAdapter = isFetchSupported && (async (config) => {
  let {
    url,
    method,
    data,
    signal,
    cancelToken,
    timeout,
    onDownloadProgress,
    onUploadProgress,
    responseType,
    headers,
    withCredentials = 'same-origin',
    fetchOptions
  } = resolveConfig(config);

  responseType = responseType ? (responseType + '').toLowerCase() : 'text';

  let composedSignal = composeSignals$1([signal, cancelToken && cancelToken.toAbortSignal()], timeout);

  let request;

  const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
      composedSignal.unsubscribe();
  });

  let requestContentLength;

  try {
    if (
      onUploadProgress && supportsRequestStream && method !== 'get' && method !== 'head' &&
      (requestContentLength = await resolveBodyLength(headers, data)) !== 0
    ) {
      let _request = new Request(url, {
        method: 'POST',
        body: data,
        duplex: "half"
      });

      let contentTypeHeader;

      if (utils$2.isFormData(data) && (contentTypeHeader = _request.headers.get('content-type'))) {
        headers.setContentType(contentTypeHeader);
      }

      if (_request.body) {
        const [onProgress, flush] = progressEventDecorator(
          requestContentLength,
          progressEventReducer(asyncDecorator(onUploadProgress))
        );

        data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
      }
    }

    if (!utils$2.isString(withCredentials)) {
      withCredentials = withCredentials ? 'include' : 'omit';
    }

    // Cloudflare Workers throws when credentials are defined
    // see https://github.com/cloudflare/workerd/issues/902
    const isCredentialsSupported = "credentials" in Request.prototype;
    request = new Request(url, {
      ...fetchOptions,
      signal: composedSignal,
      method: method.toUpperCase(),
      headers: headers.normalize().toJSON(),
      body: data,
      duplex: "half",
      credentials: isCredentialsSupported ? withCredentials : undefined
    });

    let response = await fetch(request);

    const isStreamResponse = supportsResponseStream && (responseType === 'stream' || responseType === 'response');

    if (supportsResponseStream && (onDownloadProgress || (isStreamResponse && unsubscribe))) {
      const options = {};

      ['status', 'statusText', 'headers'].forEach(prop => {
        options[prop] = response[prop];
      });

      const responseContentLength = utils$2.toFiniteNumber(response.headers.get('content-length'));

      const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
        responseContentLength,
        progressEventReducer(asyncDecorator(onDownloadProgress), true)
      ) || [];

      response = new Response(
        trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
          flush && flush();
          unsubscribe && unsubscribe();
        }),
        options
      );
    }

    responseType = responseType || 'text';

    let responseData = await resolvers[utils$2.findKey(resolvers, responseType) || 'text'](response, config);

    !isStreamResponse && unsubscribe && unsubscribe();

    return await new Promise((resolve, reject) => {
      settle(resolve, reject, {
        data: responseData,
        headers: AxiosHeaders$1.from(response.headers),
        status: response.status,
        statusText: response.statusText,
        config,
        request
      });
    })
  } catch (err) {
    unsubscribe && unsubscribe();

    if (err && err.name === 'TypeError' && /fetch/i.test(err.message)) {
      throw Object.assign(
        new AxiosError('Network Error', AxiosError.ERR_NETWORK, config, request),
        {
          cause: err.cause || err
        }
      )
    }

    throw AxiosError.from(err, err && err.code, config, request);
  }
});

const knownAdapters = {
  http: httpAdapter,
  xhr: xhrAdapter,
  fetch: fetchAdapter
};

utils$2.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, 'name', {value});
    } catch (e) {
      // eslint-disable-next-line no-empty
    }
    Object.defineProperty(fn, 'adapterName', {value});
  }
});

const renderReason = (reason) => `- ${reason}`;

const isResolvedHandle = (adapter) => utils$2.isFunction(adapter) || adapter === null || adapter === false;

var adapters = {
  getAdapter: (adapters) => {
    adapters = utils$2.isArray(adapters) ? adapters : [adapters];

    const {length} = adapters;
    let nameOrAdapter;
    let adapter;

    const rejectedReasons = {};

    for (let i = 0; i < length; i++) {
      nameOrAdapter = adapters[i];
      let id;

      adapter = nameOrAdapter;

      if (!isResolvedHandle(nameOrAdapter)) {
        adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];

        if (adapter === undefined) {
          throw new AxiosError(`Unknown adapter '${id}'`);
        }
      }

      if (adapter) {
        break;
      }

      rejectedReasons[id || '#' + i] = adapter;
    }

    if (!adapter) {

      const reasons = Object.entries(rejectedReasons)
        .map(([id, state]) => `adapter ${id} ` +
          (state === false ? 'is not supported by the environment' : 'is not available in the build')
        );

      let s = length ?
        (reasons.length > 1 ? 'since :\n' + reasons.map(renderReason).join('\n') : ' ' + renderReason(reasons[0])) :
        'as no adapter specified';

      throw new AxiosError(
        `There is no suitable adapter to dispatch the request ` + s,
        'ERR_NOT_SUPPORT'
      );
    }

    return adapter;
  },
  adapters: knownAdapters
};

/**
 * Throws a `CanceledError` if cancellation has been requested.
 *
 * @param {Object} config The config that is to be used for the request
 *
 * @returns {void}
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }

  if (config.signal && config.signal.aborted) {
    throw new CanceledError(null, config);
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 *
 * @returns {Promise} The Promise to be fulfilled
 */
function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  config.headers = AxiosHeaders$1.from(config.headers);

  // Transform request data
  config.data = transformData.call(
    config,
    config.transformRequest
  );

  if (['post', 'put', 'patch'].indexOf(config.method) !== -1) {
    config.headers.setContentType('application/x-www-form-urlencoded', false);
  }

  const adapter = adapters.getAdapter(config.adapter || defaults$2.adapter);

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData.call(
      config,
      config.transformResponse,
      response
    );

    response.headers = AxiosHeaders$1.from(response.headers);

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          config.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
      }
    }

    return Promise.reject(reason);
  });
}

const validators$2 = {};

// eslint-disable-next-line func-names
['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach((type, i) => {
  validators$2[type] = function validator(thing) {
    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
  };
});

const deprecatedWarnings = {};

/**
 * Transitional option validator
 *
 * @param {function|boolean?} validator - set to false if the transitional option has been removed
 * @param {string?} version - deprecated version / removed since version
 * @param {string?} message - some message with additional info
 *
 * @returns {function}
 */
validators$2.transitional = function transitional(validator, version, message) {
  function formatMessage(opt, desc) {
    return '[Axios v' + VERSION + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
  }

  // eslint-disable-next-line func-names
  return (value, opt, opts) => {
    if (validator === false) {
      throw new AxiosError(
        formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')),
        AxiosError.ERR_DEPRECATED
      );
    }

    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      // eslint-disable-next-line no-console
      console.warn(
        formatMessage(
          opt,
          ' has been deprecated since v' + version + ' and will be removed in the near future'
        )
      );
    }

    return validator ? validator(value, opt, opts) : true;
  };
};

/**
 * Assert object's properties type
 *
 * @param {object} options
 * @param {object} schema
 * @param {boolean?} allowUnknown
 *
 * @returns {object}
 */

function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== 'object') {
    throw new AxiosError('options must be an object', AxiosError.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i = keys.length;
  while (i-- > 0) {
    const opt = keys[i];
    const validator = schema[opt];
    if (validator) {
      const value = options[opt];
      const result = value === undefined || validator(value, opt, options);
      if (result !== true) {
        throw new AxiosError('option ' + opt + ' must be ' + result, AxiosError.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError('Unknown option ' + opt, AxiosError.ERR_BAD_OPTION);
    }
  }
}

var validator = {
  assertOptions,
  validators: validators$2
};

const validators$1 = validator.validators;

/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 *
 * @return {Axios} A new instance of Axios
 */
class Axios {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager$1(),
      response: new InterceptorManager$1()
    };
  }

  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(configOrUrl, config) {
    try {
      return await this._request(configOrUrl, config);
    } catch (err) {
      if (err instanceof Error) {
        let dummy;

        Error.captureStackTrace ? Error.captureStackTrace(dummy = {}) : (dummy = new Error());

        // slice off the Error: ... line
        const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, '') : '';
        try {
          if (!err.stack) {
            err.stack = stack;
            // match without the 2 top stack lines
          } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ''))) {
            err.stack += '\n' + stack;
          }
        } catch (e) {
          // ignore the case where "stack" is an un-writable property
        }
      }

      throw err;
    }
  }

  _request(configOrUrl, config) {
    /*eslint no-param-reassign:0*/
    // Allow for axios('example/url'[, config]) a la fetch API
    if (typeof configOrUrl === 'string') {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }

    config = mergeConfig(this.defaults, config);

    const {transitional, paramsSerializer, headers} = config;

    if (transitional !== undefined) {
      validator.assertOptions(transitional, {
        silentJSONParsing: validators$1.transitional(validators$1.boolean),
        forcedJSONParsing: validators$1.transitional(validators$1.boolean),
        clarifyTimeoutError: validators$1.transitional(validators$1.boolean)
      }, false);
    }

    if (paramsSerializer != null) {
      if (utils$2.isFunction(paramsSerializer)) {
        config.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator.assertOptions(paramsSerializer, {
          encode: validators$1.function,
          serialize: validators$1.function
        }, true);
      }
    }

    // Set config.method
    config.method = (config.method || this.defaults.method || 'get').toLowerCase();

    // Flatten headers
    let contextHeaders = headers && utils$2.merge(
      headers.common,
      headers[config.method]
    );

    headers && utils$2.forEach(
      ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
      (method) => {
        delete headers[method];
      }
    );

    config.headers = AxiosHeaders$1.concat(contextHeaders, headers);

    // filter out skipped interceptors
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
        return;
      }

      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;

      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });

    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });

    let promise;
    let i = 0;
    let len;

    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), undefined];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;

      promise = Promise.resolve(config);

      while (i < len) {
        promise = promise.then(chain[i++], chain[i++]);
      }

      return promise;
    }

    len = requestInterceptorChain.length;

    let newConfig = config;

    i = 0;

    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }

    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }

    i = 0;
    len = responseInterceptorChain.length;

    while (i < len) {
      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }

    return promise;
  }

  getUri(config) {
    config = mergeConfig(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
}

// Provide aliases for supported request methods
utils$2.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method,
      url,
      data: (config || {}).data
    }));
  };
});

utils$2.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/

  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        headers: isForm ? {
          'Content-Type': 'multipart/form-data'
        } : {},
        url,
        data
      }));
    };
  }

  Axios.prototype[method] = generateHTTPMethod();

  Axios.prototype[method + 'Form'] = generateHTTPMethod(true);
});

var Axios$1 = Axios;

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @param {Function} executor The executor function.
 *
 * @returns {CancelToken}
 */
class CancelToken {
  constructor(executor) {
    if (typeof executor !== 'function') {
      throw new TypeError('executor must be a function.');
    }

    let resolvePromise;

    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });

    const token = this;

    // eslint-disable-next-line func-names
    this.promise.then(cancel => {
      if (!token._listeners) return;

      let i = token._listeners.length;

      while (i-- > 0) {
        token._listeners[i](cancel);
      }
      token._listeners = null;
    });

    // eslint-disable-next-line func-names
    this.promise.then = onfulfilled => {
      let _resolve;
      // eslint-disable-next-line func-names
      const promise = new Promise(resolve => {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);

      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };

      return promise;
    };

    executor(function cancel(message, config, request) {
      if (token.reason) {
        // Cancellation has already been requested
        return;
      }

      token.reason = new CanceledError(message, config, request);
      resolvePromise(token.reason);
    });
  }

  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }

  /**
   * Subscribe to the cancel signal
   */

  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }

    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }

  /**
   * Unsubscribe from the cancel signal
   */

  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  }

  toAbortSignal() {
    const controller = new AbortController();

    const abort = (err) => {
      controller.abort(err);
    };

    this.subscribe(abort);

    controller.signal.unsubscribe = () => this.unsubscribe(abort);

    return controller.signal;
  }

  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token,
      cancel
    };
  }
}

var CancelToken$1 = CancelToken;

/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 *
 * @returns {Function}
 */
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}

/**
 * Determines whether the payload is an error thrown by Axios
 *
 * @param {*} payload The value to test
 *
 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
 */
function isAxiosError(payload) {
  return utils$2.isObject(payload) && (payload.isAxiosError === true);
}

const HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511,
};

Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});

var HttpStatusCode$1 = HttpStatusCode;

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 *
 * @returns {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  const context = new Axios$1(defaultConfig);
  const instance = bind(Axios$1.prototype.request, context);

  // Copy axios.prototype to instance
  utils$2.extend(instance, Axios$1.prototype, context, {allOwnKeys: true});

  // Copy context to instance
  utils$2.extend(instance, context, null, {allOwnKeys: true});

  // Factory for creating new instances
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };

  return instance;
}

// Create the default instance to be exported
const axios = createInstance(defaults$2);

// Expose Axios class to allow class inheritance
axios.Axios = Axios$1;

// Expose Cancel & CancelToken
axios.CanceledError = CanceledError;
axios.CancelToken = CancelToken$1;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData;

// Expose AxiosError class
axios.AxiosError = AxiosError;

// alias for CanceledError for backward compatibility
axios.Cancel = axios.CanceledError;

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};

axios.spread = spread;

// Expose isAxiosError
axios.isAxiosError = isAxiosError;

// Expose mergeConfig
axios.mergeConfig = mergeConfig;

axios.AxiosHeaders = AxiosHeaders$1;

axios.formToJSON = thing => formDataToJSON(utils$2.isHTMLForm(thing) ? new FormData(thing) : thing);

axios.getAdapter = adapters.getAdapter;

axios.HttpStatusCode = HttpStatusCode$1;

axios.default = axios;

// this module should only have a default export
var axios$1 = axios;

var RequestMethod;
(function (RequestMethod) {
    RequestMethod[RequestMethod["Get"] = 0] = "Get";
    RequestMethod[RequestMethod["Post"] = 1] = "Post";
})(RequestMethod || (RequestMethod = {}));
let Request$1 = class Request {
    constructor(url) {
        this.method = RequestMethod.Post;
        this.body = "{}";
        this.contentType = "application/json; charset=UTF-8";
        this.authRequired = true;
        this.upgradeRequired = false;
        this.checkRequestStatus = null;
        this.headers = {};
        this.url = url;
    }
    getUrl() {
        return this.url;
    }
    getMethod() {
        return this.method;
    }
    setMethod(method) {
        this.method = method;
        return this;
    }
    getHeaders() {
        return this.headers;
    }
    setHeaders(headers) {
        this.headers = headers;
        return this;
    }
    getBody() {
        return this.body;
    }
    setBody(body) {
        if (typeof body === "object") {
            body = JSON.stringify(body);
        }
        this.body = body;
        return this;
    }
    isAuthRequired() {
        return this.authRequired;
    }
    setAuthRequired(authRequired) {
        this.authRequired = authRequired;
        return this;
    }
    isUpgradeRequired() {
        return this.upgradeRequired;
    }
    setUpgradeRequired(upgradeRequired) {
        this.upgradeRequired = upgradeRequired;
        return this;
    }
    getContentType() {
        return this.contentType;
    }
    setContentType(type) {
        this.contentType = type;
        return this;
    }
    getCheckRequestStatus() {
        return this.checkRequestStatus;
    }
    setCheckRequestStatus(checkStatus) {
        this.checkRequestStatus = checkStatus;
        return this;
    }
};

class RequestResult {
    constructor(status) {
        this.status = status;
    }
    setResponse(response) {
        this.response = response;
        return this;
    }
    setMessage(message) {
        this.message = message;
        return this;
    }
    getResult() {
        const result = {
            status: this.status,
        };
        if (this.response) {
            result.response = this.response;
        }
        if (this.message) {
            result.message = this.message;
        }
        return result;
    }
}

class RequestError extends Error {
    constructor(...args) {
        super(...args);
        Error.captureStackTrace(this, RequestError);
    }
    getResponse() {
        return this.response;
    }
    setResponse(response) {
        this.response = response;
        return this;
    }
    getRequest() {
        return this.request;
    }
    setRequest(request) {
        this.request = request;
        return this;
    }
}

var CommandResponseStatus;
(function (CommandResponseStatus) {
    CommandResponseStatus["success"] = "success";
    CommandResponseStatus["failure"] = "failure";
    CommandResponseStatus["inProgress"] = "inProgress";
})(CommandResponseStatus || (CommandResponseStatus = {}));
var AlertRequestAction;
(function (AlertRequestAction) {
    AlertRequestAction["Honk"] = "Honk";
    AlertRequestAction["Flash"] = "Flash";
})(AlertRequestAction || (AlertRequestAction = {}));
var AlertRequestOverride;
(function (AlertRequestOverride) {
    AlertRequestOverride["DoorOpen"] = "DoorOpen";
    AlertRequestOverride["IgnitionOn"] = "IgnitionOn";
})(AlertRequestOverride || (AlertRequestOverride = {}));
var DiagnosticRequestItem;
(function (DiagnosticRequestItem) {
    DiagnosticRequestItem["AmbientAirTemperature"] = "AMBIENT AIR TEMPERATURE";
    DiagnosticRequestItem["EngineCoolantTemp"] = "ENGINE COOLANT TEMP";
    DiagnosticRequestItem["EngineRpm"] = "ENGINE RPM";
    DiagnosticRequestItem["EvBatteryLevel"] = "EV BATTERY LEVEL";
    DiagnosticRequestItem["EvChargeState"] = "EV CHARGE STATE";
    DiagnosticRequestItem["EvEstimatedChargeEnd"] = "EV ESTIMATED CHARGE END";
    DiagnosticRequestItem["EvPlugState"] = "EV PLUG STATE";
    DiagnosticRequestItem["EvPlugVoltage"] = "EV PLUG VOLTAGE";
    DiagnosticRequestItem["EvScheduledChargeStart"] = "EV SCHEDULED CHARGE START";
    DiagnosticRequestItem["FuelTankInfo"] = "FUEL TANK INFO";
    DiagnosticRequestItem["GetChargeMode"] = "GET CHARGE MODE";
    DiagnosticRequestItem["GetCommuteSchedule"] = "GET COMMUTE SCHEDULE";
    DiagnosticRequestItem["HandsFreeCalling"] = "HANDS FREE CALLING";
    DiagnosticRequestItem["HotspotConfig"] = "HOTSPOT CONFIG";
    DiagnosticRequestItem["HotspotStatus"] = "HOTSPOT STATUS";
    DiagnosticRequestItem["IntermVoltBattVolt"] = "INTERM VOLT BATT VOLT";
    DiagnosticRequestItem["LastTripDistance"] = "LAST TRIP DISTANCE";
    DiagnosticRequestItem["LastTripFuelEconomy"] = "LAST TRIP FUEL ECONOMY";
    DiagnosticRequestItem["LifetimeEvOdometer"] = "LIFETIME EV ODOMETER";
    DiagnosticRequestItem["LifetimeFuelEcon"] = "LIFETIME FUEL ECON";
    DiagnosticRequestItem["LifetimeFuelUsed"] = "LIFETIME FUEL USED";
    DiagnosticRequestItem["Odometer"] = "ODOMETER";
    DiagnosticRequestItem["OilLife"] = "OIL LIFE";
    DiagnosticRequestItem["TirePressure"] = "TIRE PRESSURE";
    DiagnosticRequestItem["VehicleRange"] = "VEHICLE RANGE";
})(DiagnosticRequestItem || (DiagnosticRequestItem = {}));
var ChargingProfileChargeMode;
(function (ChargingProfileChargeMode) {
    ChargingProfileChargeMode["DefaultImmediate"] = "DEFAULT_IMMEDIATE";
    ChargingProfileChargeMode["Immediate"] = "IMMEDIATE";
    ChargingProfileChargeMode["DepartureBased"] = "DEPARTURE_BASED";
    ChargingProfileChargeMode["RateBased"] = "RATE_BASED";
    ChargingProfileChargeMode["PhevAfterMidnight"] = "PHEV_AFTER_MIDNIGHT";
})(ChargingProfileChargeMode || (ChargingProfileChargeMode = {}));
var ChargingProfileRateType;
(function (ChargingProfileRateType) {
    ChargingProfileRateType["Offpeak"] = "OFFPEAK";
    ChargingProfileRateType["Midpeak"] = "MIDPEAK";
    ChargingProfileRateType["Peak"] = "PEAK";
})(ChargingProfileRateType || (ChargingProfileRateType = {}));
var ChargeOverrideMode;
(function (ChargeOverrideMode) {
    ChargeOverrideMode["ChargeNow"] = "CHARGE_NOW";
    ChargeOverrideMode["CancelOverride"] = "CANCEL_OVERRIDE";
})(ChargeOverrideMode || (ChargeOverrideMode = {}));

var appId = "OMB_CVY_iOS_6Z0";
var appSecret = "tCujQXR8nvPhewodWMPrUNExBK4dmCmBAfMb";
var optionalClientScope = "";
var requiredClientScope = "onstar gmoc user_trailer user priv";
var serviceUrl = "https://na-mobile-api.gm.com";
var userAgent = "myChevrolet/118 CFNetwork/1408.0.4 Darwin/22.5.0";
var onStarAppConfig = {
	appId: appId,
	appSecret: appSecret,
	optionalClientScope: optionalClientScope,
	requiredClientScope: requiredClientScope,
	serviceUrl: serviceUrl,
	userAgent: userAgent
};

var cookie$1 = {};

var memstore = {};

var pathMatch = {};

var hasRequiredPathMatch;

function requirePathMatch () {
	if (hasRequiredPathMatch) return pathMatch;
	hasRequiredPathMatch = 1;
	Object.defineProperty(pathMatch, "__esModule", { value: true });
	pathMatch.pathMatch = pathMatch$1;
	/**
	 * Answers "does the request-path path-match a given cookie-path?" as per {@link https://www.rfc-editor.org/rfc/rfc6265.html#section-5.1.4 | RFC6265 Section 5.1.4}.
	 * This is essentially a prefix-match where cookiePath is a prefix of reqPath.
	 *
	 * @remarks
	 * A request-path path-matches a given cookie-path if at least one of
	 * the following conditions holds:
	 *
	 * - The cookie-path and the request-path are identical.
	 * - The cookie-path is a prefix of the request-path, and the last character of the cookie-path is %x2F ("/").
	 * - The cookie-path is a prefix of the request-path, and the first character of the request-path that is not included in the cookie-path is a %x2F ("/") character.
	 *
	 * @param reqPath - the path of the request
	 * @param cookiePath - the path of the cookie
	 * @public
	 */
	function pathMatch$1(reqPath, cookiePath) {
	    // "o  The cookie-path and the request-path are identical."
	    if (cookiePath === reqPath) {
	        return true;
	    }
	    const idx = reqPath.indexOf(cookiePath);
	    if (idx === 0) {
	        // "o  The cookie-path is a prefix of the request-path, and the last
	        // character of the cookie-path is %x2F ("/")."
	        if (cookiePath[cookiePath.length - 1] === '/') {
	            return true;
	        }
	        // " o  The cookie-path is a prefix of the request-path, and the first
	        // character of the request-path that is not included in the cookie- path
	        // is a %x2F ("/") character."
	        if (new RegExp(`^${cookiePath}`).test(reqPath) &&
	            reqPath[cookiePath.length] === '/') {
	            return true;
	        }
	    }
	    return false;
	}
	return pathMatch;
}

var permuteDomain = {};

var getPublicSuffix$1 = {};

/**
 * Check if `vhost` is a valid suffix of `hostname` (top-domain)
 *
 * It means that `vhost` needs to be a suffix of `hostname` and we then need to
 * make sure that: either they are equal, or the character preceding `vhost` in
 * `hostname` is a '.' (it should not be a partial label).
 *
 * * hostname = 'not.evil.com' and vhost = 'vil.com'      => not ok
 * * hostname = 'not.evil.com' and vhost = 'evil.com'     => ok
 * * hostname = 'not.evil.com' and vhost = 'not.evil.com' => ok
 */
function shareSameDomainSuffix(hostname, vhost) {
    if (hostname.endsWith(vhost)) {
        return (hostname.length === vhost.length ||
            hostname[hostname.length - vhost.length - 1] === '.');
    }
    return false;
}
/**
 * Given a hostname and its public suffix, extract the general domain.
 */
function extractDomainWithSuffix(hostname, publicSuffix) {
    // Locate the index of the last '.' in the part of the `hostname` preceding
    // the public suffix.
    //
    // examples:
    //   1. not.evil.co.uk  => evil.co.uk
    //         ^    ^
    //         |    | start of public suffix
    //         | index of the last dot
    //
    //   2. example.co.uk   => example.co.uk
    //     ^       ^
    //     |       | start of public suffix
    //     |
    //     | (-1) no dot found before the public suffix
    const publicSuffixIndex = hostname.length - publicSuffix.length - 2;
    const lastDotBeforeSuffixIndex = hostname.lastIndexOf('.', publicSuffixIndex);
    // No '.' found, then `hostname` is the general domain (no sub-domain)
    if (lastDotBeforeSuffixIndex === -1) {
        return hostname;
    }
    // Extract the part between the last '.'
    return hostname.slice(lastDotBeforeSuffixIndex + 1);
}
/**
 * Detects the domain based on rules and upon and a host string
 */
function getDomain$1(suffix, hostname, options) {
    // Check if `hostname` ends with a member of `validHosts`.
    if (options.validHosts !== null) {
        const validHosts = options.validHosts;
        for (const vhost of validHosts) {
            if ( /*@__INLINE__*/shareSameDomainSuffix(hostname, vhost)) {
                return vhost;
            }
        }
    }
    let numberOfLeadingDots = 0;
    if (hostname.startsWith('.')) {
        while (numberOfLeadingDots < hostname.length &&
            hostname[numberOfLeadingDots] === '.') {
            numberOfLeadingDots += 1;
        }
    }
    // If `hostname` is a valid public suffix, then there is no domain to return.
    // Since we already know that `getPublicSuffix` returns a suffix of `hostname`
    // there is no need to perform a string comparison and we only compare the
    // size.
    if (suffix.length === hostname.length - numberOfLeadingDots) {
        return null;
    }
    // To extract the general domain, we start by identifying the public suffix
    // (if any), then consider the domain to be the public suffix with one added
    // level of depth. (e.g.: if hostname is `not.evil.co.uk` and public suffix:
    // `co.uk`, then we take one more level: `evil`, giving the final result:
    // `evil.co.uk`).
    return /*@__INLINE__*/ extractDomainWithSuffix(hostname, suffix);
}

/**
 * Return the part of domain without suffix.
 *
 * Example: for domain 'foo.com', the result would be 'foo'.
 */
function getDomainWithoutSuffix$1(domain, suffix) {
    // Note: here `domain` and `suffix` cannot have the same length because in
    // this case we set `domain` to `null` instead. It is thus safe to assume
    // that `suffix` is shorter than `domain`.
    return domain.slice(0, -suffix.length - 1);
}

/**
 * @param url - URL we want to extract a hostname from.
 * @param urlIsValidHostname - hint from caller; true if `url` is already a valid hostname.
 */
function extractHostname(url, urlIsValidHostname) {
    let start = 0;
    let end = url.length;
    let hasUpper = false;
    // If url is not already a valid hostname, then try to extract hostname.
    if (!urlIsValidHostname) {
        // Special handling of data URLs
        if (url.startsWith('data:')) {
            return null;
        }
        // Trim leading spaces
        while (start < url.length && url.charCodeAt(start) <= 32) {
            start += 1;
        }
        // Trim trailing spaces
        while (end > start + 1 && url.charCodeAt(end - 1) <= 32) {
            end -= 1;
        }
        // Skip scheme.
        if (url.charCodeAt(start) === 47 /* '/' */ &&
            url.charCodeAt(start + 1) === 47 /* '/' */) {
            start += 2;
        }
        else {
            const indexOfProtocol = url.indexOf(':/', start);
            if (indexOfProtocol !== -1) {
                // Implement fast-path for common protocols. We expect most protocols
                // should be one of these 4 and thus we will not need to perform the
                // more expansive validity check most of the time.
                const protocolSize = indexOfProtocol - start;
                const c0 = url.charCodeAt(start);
                const c1 = url.charCodeAt(start + 1);
                const c2 = url.charCodeAt(start + 2);
                const c3 = url.charCodeAt(start + 3);
                const c4 = url.charCodeAt(start + 4);
                if (protocolSize === 5 &&
                    c0 === 104 /* 'h' */ &&
                    c1 === 116 /* 't' */ &&
                    c2 === 116 /* 't' */ &&
                    c3 === 112 /* 'p' */ &&
                    c4 === 115 /* 's' */) ;
                else if (protocolSize === 4 &&
                    c0 === 104 /* 'h' */ &&
                    c1 === 116 /* 't' */ &&
                    c2 === 116 /* 't' */ &&
                    c3 === 112 /* 'p' */) ;
                else if (protocolSize === 3 &&
                    c0 === 119 /* 'w' */ &&
                    c1 === 115 /* 's' */ &&
                    c2 === 115 /* 's' */) ;
                else if (protocolSize === 2 &&
                    c0 === 119 /* 'w' */ &&
                    c1 === 115 /* 's' */) ;
                else {
                    // Check that scheme is valid
                    for (let i = start; i < indexOfProtocol; i += 1) {
                        const lowerCaseCode = url.charCodeAt(i) | 32;
                        if (!(((lowerCaseCode >= 97 && lowerCaseCode <= 122) || // [a, z]
                            (lowerCaseCode >= 48 && lowerCaseCode <= 57) || // [0, 9]
                            lowerCaseCode === 46 || // '.'
                            lowerCaseCode === 45 || // '-'
                            lowerCaseCode === 43) // '+'
                        )) {
                            return null;
                        }
                    }
                }
                // Skip 0, 1 or more '/' after ':/'
                start = indexOfProtocol + 2;
                while (url.charCodeAt(start) === 47 /* '/' */) {
                    start += 1;
                }
            }
        }
        // Detect first occurrence of '/', '?' or '#'. We also keep track of the
        // last occurrence of '@', ']' or ':' to speed-up subsequent parsing of
        // (respectively), identifier, ipv6 or port.
        let indexOfIdentifier = -1;
        let indexOfClosingBracket = -1;
        let indexOfPort = -1;
        for (let i = start; i < end; i += 1) {
            const code = url.charCodeAt(i);
            if (code === 35 || // '#'
                code === 47 || // '/'
                code === 63 // '?'
            ) {
                end = i;
                break;
            }
            else if (code === 64) {
                // '@'
                indexOfIdentifier = i;
            }
            else if (code === 93) {
                // ']'
                indexOfClosingBracket = i;
            }
            else if (code === 58) {
                // ':'
                indexOfPort = i;
            }
            else if (code >= 65 && code <= 90) {
                hasUpper = true;
            }
        }
        // Detect identifier: '@'
        if (indexOfIdentifier !== -1 &&
            indexOfIdentifier > start &&
            indexOfIdentifier < end) {
            start = indexOfIdentifier + 1;
        }
        // Handle ipv6 addresses
        if (url.charCodeAt(start) === 91 /* '[' */) {
            if (indexOfClosingBracket !== -1) {
                return url.slice(start + 1, indexOfClosingBracket).toLowerCase();
            }
            return null;
        }
        else if (indexOfPort !== -1 && indexOfPort > start && indexOfPort < end) {
            // Detect port: ':'
            end = indexOfPort;
        }
    }
    // Trim trailing dots
    while (end > start + 1 && url.charCodeAt(end - 1) === 46 /* '.' */) {
        end -= 1;
    }
    const hostname = start !== 0 || end !== url.length ? url.slice(start, end) : url;
    if (hasUpper) {
        return hostname.toLowerCase();
    }
    return hostname;
}

/**
 * Check if a hostname is an IP. You should be aware that this only works
 * because `hostname` is already garanteed to be a valid hostname!
 */
function isProbablyIpv4(hostname) {
    // Cannot be shorted than 1.1.1.1
    if (hostname.length < 7) {
        return false;
    }
    // Cannot be longer than: 255.255.255.255
    if (hostname.length > 15) {
        return false;
    }
    let numberOfDots = 0;
    for (let i = 0; i < hostname.length; i += 1) {
        const code = hostname.charCodeAt(i);
        if (code === 46 /* '.' */) {
            numberOfDots += 1;
        }
        else if (code < 48 /* '0' */ || code > 57 /* '9' */) {
            return false;
        }
    }
    return (numberOfDots === 3 &&
        hostname.charCodeAt(0) !== 46 /* '.' */ &&
        hostname.charCodeAt(hostname.length - 1) !== 46 /* '.' */);
}
/**
 * Similar to isProbablyIpv4.
 */
function isProbablyIpv6(hostname) {
    if (hostname.length < 3) {
        return false;
    }
    let start = hostname.startsWith('[') ? 1 : 0;
    let end = hostname.length;
    if (hostname[end - 1] === ']') {
        end -= 1;
    }
    // We only consider the maximum size of a normal IPV6. Note that this will
    // fail on so-called "IPv4 mapped IPv6 addresses" but this is a corner-case
    // and a proper validation library should be used for these.
    if (end - start > 39) {
        return false;
    }
    let hasColon = false;
    for (; start < end; start += 1) {
        const code = hostname.charCodeAt(start);
        if (code === 58 /* ':' */) {
            hasColon = true;
        }
        else if (!(((code >= 48 && code <= 57) || // 0-9
            (code >= 97 && code <= 102) || // a-f
            (code >= 65 && code <= 90)) // A-F
        )) {
            return false;
        }
    }
    return hasColon;
}
/**
 * Check if `hostname` is *probably* a valid ip addr (either ipv6 or ipv4).
 * This *will not* work on any string. We need `hostname` to be a valid
 * hostname.
 */
function isIp(hostname) {
    return isProbablyIpv6(hostname) || isProbablyIpv4(hostname);
}

/**
 * Implements fast shallow verification of hostnames. This does not perform a
 * struct check on the content of labels (classes of Unicode characters, etc.)
 * but instead check that the structure is valid (number of labels, length of
 * labels, etc.).
 *
 * If you need stricter validation, consider using an external library.
 */
function isValidAscii(code) {
    return ((code >= 97 && code <= 122) || (code >= 48 && code <= 57) || code > 127);
}
/**
 * Check if a hostname string is valid. It's usually a preliminary check before
 * trying to use getDomain or anything else.
 *
 * Beware: it does not check if the TLD exists.
 */
function isValidHostname (hostname) {
    if (hostname.length > 255) {
        return false;
    }
    if (hostname.length === 0) {
        return false;
    }
    if (
    /*@__INLINE__*/ !isValidAscii(hostname.charCodeAt(0)) &&
        hostname.charCodeAt(0) !== 46 && // '.' (dot)
        hostname.charCodeAt(0) !== 95 // '_' (underscore)
    ) {
        return false;
    }
    // Validate hostname according to RFC
    let lastDotIndex = -1;
    let lastCharCode = -1;
    const len = hostname.length;
    for (let i = 0; i < len; i += 1) {
        const code = hostname.charCodeAt(i);
        if (code === 46 /* '.' */) {
            if (
            // Check that previous label is < 63 bytes long (64 = 63 + '.')
            i - lastDotIndex > 64 ||
                // Check that previous character was not already a '.'
                lastCharCode === 46 ||
                // Check that the previous label does not end with a '-' (dash)
                lastCharCode === 45 ||
                // Check that the previous label does not end with a '_' (underscore)
                lastCharCode === 95) {
                return false;
            }
            lastDotIndex = i;
        }
        else if (!( /*@__INLINE__*/(isValidAscii(code) || code === 45 || code === 95))) {
            // Check if there is a forbidden character in the label
            return false;
        }
        lastCharCode = code;
    }
    return (
    // Check that last label is shorter than 63 chars
    len - lastDotIndex - 1 <= 63 &&
        // Check that the last character is an allowed trailing label character.
        // Since we already checked that the char is a valid hostname character,
        // we only need to check that it's different from '-'.
        lastCharCode !== 45);
}

function setDefaultsImpl({ allowIcannDomains = true, allowPrivateDomains = false, detectIp = true, extractHostname = true, mixedInputs = true, validHosts = null, validateHostname = true, }) {
    return {
        allowIcannDomains,
        allowPrivateDomains,
        detectIp,
        extractHostname,
        mixedInputs,
        validHosts,
        validateHostname,
    };
}
const DEFAULT_OPTIONS = /*@__INLINE__*/ setDefaultsImpl({});
function setDefaults(options) {
    if (options === undefined) {
        return DEFAULT_OPTIONS;
    }
    return /*@__INLINE__*/ setDefaultsImpl(options);
}

/**
 * Returns the subdomain of a hostname string
 */
function getSubdomain$1(hostname, domain) {
    // If `hostname` and `domain` are the same, then there is no sub-domain
    if (domain.length === hostname.length) {
        return '';
    }
    return hostname.slice(0, -domain.length - 1);
}

/**
 * Implement a factory allowing to plug different implementations of suffix
 * lookup (e.g.: using a trie or the packed hashes datastructures). This is used
 * and exposed in `tldts.ts` and `tldts-experimental.ts` bundle entrypoints.
 */
function getEmptyResult() {
    return {
        domain: null,
        domainWithoutSuffix: null,
        hostname: null,
        isIcann: null,
        isIp: null,
        isPrivate: null,
        publicSuffix: null,
        subdomain: null,
    };
}
function resetResult(result) {
    result.domain = null;
    result.domainWithoutSuffix = null;
    result.hostname = null;
    result.isIcann = null;
    result.isIp = null;
    result.isPrivate = null;
    result.publicSuffix = null;
    result.subdomain = null;
}
function parseImpl(url, step, suffixLookup, partialOptions, result) {
    const options = /*@__INLINE__*/ setDefaults(partialOptions);
    // Very fast approximate check to make sure `url` is a string. This is needed
    // because the library will not necessarily be used in a typed setup and
    // values of arbitrary types might be given as argument.
    if (typeof url !== 'string') {
        return result;
    }
    // Extract hostname from `url` only if needed. This can be made optional
    // using `options.extractHostname`. This option will typically be used
    // whenever we are sure the inputs to `parse` are already hostnames and not
    // arbitrary URLs.
    //
    // `mixedInput` allows to specify if we expect a mix of URLs and hostnames
    // as input. If only hostnames are expected then `extractHostname` can be
    // set to `false` to speed-up parsing. If only URLs are expected then
    // `mixedInputs` can be set to `false`. The `mixedInputs` is only a hint
    // and will not change the behavior of the library.
    if (!options.extractHostname) {
        result.hostname = url;
    }
    else if (options.mixedInputs) {
        result.hostname = extractHostname(url, isValidHostname(url));
    }
    else {
        result.hostname = extractHostname(url, false);
    }
    if (step === 0 /* FLAG.HOSTNAME */ || result.hostname === null) {
        return result;
    }
    // Check if `hostname` is a valid ip address
    if (options.detectIp) {
        result.isIp = isIp(result.hostname);
        if (result.isIp) {
            return result;
        }
    }
    // Perform optional hostname validation. If hostname is not valid, no need to
    // go further as there will be no valid domain or sub-domain.
    if (options.validateHostname &&
        options.extractHostname &&
        !isValidHostname(result.hostname)) {
        result.hostname = null;
        return result;
    }
    // Extract public suffix
    suffixLookup(result.hostname, options, result);
    if (step === 2 /* FLAG.PUBLIC_SUFFIX */ || result.publicSuffix === null) {
        return result;
    }
    // Extract domain
    result.domain = getDomain$1(result.publicSuffix, result.hostname, options);
    if (step === 3 /* FLAG.DOMAIN */ || result.domain === null) {
        return result;
    }
    // Extract subdomain
    result.subdomain = getSubdomain$1(result.hostname, result.domain);
    if (step === 4 /* FLAG.SUB_DOMAIN */) {
        return result;
    }
    // Extract domain without suffix
    result.domainWithoutSuffix = getDomainWithoutSuffix$1(result.domain, result.publicSuffix);
    return result;
}

function fastPathLookup (hostname, options, out) {
    // Fast path for very popular suffixes; this allows to by-pass lookup
    // completely as well as any extra allocation or string manipulation.
    if (!options.allowPrivateDomains && hostname.length > 3) {
        const last = hostname.length - 1;
        const c3 = hostname.charCodeAt(last);
        const c2 = hostname.charCodeAt(last - 1);
        const c1 = hostname.charCodeAt(last - 2);
        const c0 = hostname.charCodeAt(last - 3);
        if (c3 === 109 /* 'm' */ &&
            c2 === 111 /* 'o' */ &&
            c1 === 99 /* 'c' */ &&
            c0 === 46 /* '.' */) {
            out.isIcann = true;
            out.isPrivate = false;
            out.publicSuffix = 'com';
            return true;
        }
        else if (c3 === 103 /* 'g' */ &&
            c2 === 114 /* 'r' */ &&
            c1 === 111 /* 'o' */ &&
            c0 === 46 /* '.' */) {
            out.isIcann = true;
            out.isPrivate = false;
            out.publicSuffix = 'org';
            return true;
        }
        else if (c3 === 117 /* 'u' */ &&
            c2 === 100 /* 'd' */ &&
            c1 === 101 /* 'e' */ &&
            c0 === 46 /* '.' */) {
            out.isIcann = true;
            out.isPrivate = false;
            out.publicSuffix = 'edu';
            return true;
        }
        else if (c3 === 118 /* 'v' */ &&
            c2 === 111 /* 'o' */ &&
            c1 === 103 /* 'g' */ &&
            c0 === 46 /* '.' */) {
            out.isIcann = true;
            out.isPrivate = false;
            out.publicSuffix = 'gov';
            return true;
        }
        else if (c3 === 116 /* 't' */ &&
            c2 === 101 /* 'e' */ &&
            c1 === 110 /* 'n' */ &&
            c0 === 46 /* '.' */) {
            out.isIcann = true;
            out.isPrivate = false;
            out.publicSuffix = 'net';
            return true;
        }
        else if (c3 === 101 /* 'e' */ &&
            c2 === 100 /* 'd' */ &&
            c1 === 46 /* '.' */) {
            out.isIcann = true;
            out.isPrivate = false;
            out.publicSuffix = 'de';
            return true;
        }
    }
    return false;
}

const exceptions = (function () {
    const _0 = [1, {}], _1 = [0, { "city": _0 }];
    const exceptions = [0, { "ck": [0, { "www": _0 }], "jp": [0, { "kawasaki": _1, "kitakyushu": _1, "kobe": _1, "nagoya": _1, "sapporo": _1, "sendai": _1, "yokohama": _1 }] }];
    return exceptions;
})();
const rules = (function () {
    const _2 = [1, {}], _3 = [2, {}], _4 = [1, { "com": _2, "edu": _2, "gov": _2, "net": _2, "org": _2 }], _5 = [0, { "*": _3 }], _6 = [0, { "relay": _3 }], _7 = [2, { "id": _3 }], _8 = [1, { "blogspot": _3 }], _9 = [1, { "gov": _2 }], _10 = [0, { "notebook": _3, "studio": _3 }], _11 = [0, { "labeling": _3, "notebook": _3, "studio": _3 }], _12 = [0, { "notebook": _3 }], _13 = [0, { "labeling": _3, "notebook": _3, "notebook-fips": _3, "studio": _3 }], _14 = [0, { "notebook": _3, "notebook-fips": _3, "studio": _3, "studio-fips": _3 }], _15 = [0, { "*": _2 }], _16 = [0, { "cloud": _3 }], _17 = [1, { "co": _3 }], _18 = [0, { "objects": _3 }], _19 = [2, { "nodes": _3 }], _20 = [0, { "my": _5 }], _21 = [0, { "s3": _3, "s3-accesspoint": _3, "s3-website": _3 }], _22 = [0, { "s3": _3, "s3-accesspoint": _3 }], _23 = [0, { "direct": _3 }], _24 = [0, { "webview-assets": _3 }], _25 = [0, { "vfs": _3, "webview-assets": _3 }], _26 = [0, { "execute-api": _3, "emrappui-prod": _3, "emrnotebooks-prod": _3, "emrstudio-prod": _3, "dualstack": _21, "s3": _3, "s3-accesspoint": _3, "s3-object-lambda": _3, "s3-website": _3, "aws-cloud9": _24, "cloud9": _25 }], _27 = [0, { "execute-api": _3, "emrappui-prod": _3, "emrnotebooks-prod": _3, "emrstudio-prod": _3, "dualstack": _22, "s3": _3, "s3-accesspoint": _3, "s3-object-lambda": _3, "s3-website": _3, "aws-cloud9": _24, "cloud9": _25 }], _28 = [0, { "execute-api": _3, "emrappui-prod": _3, "emrnotebooks-prod": _3, "emrstudio-prod": _3, "dualstack": _21, "s3": _3, "s3-accesspoint": _3, "s3-object-lambda": _3, "s3-website": _3, "analytics-gateway": _3, "aws-cloud9": _24, "cloud9": _25 }], _29 = [0, { "execute-api": _3, "emrappui-prod": _3, "emrnotebooks-prod": _3, "emrstudio-prod": _3, "dualstack": _21, "s3": _3, "s3-accesspoint": _3, "s3-object-lambda": _3, "s3-website": _3 }], _30 = [0, { "s3": _3, "s3-accesspoint": _3, "s3-accesspoint-fips": _3, "s3-fips": _3, "s3-website": _3 }], _31 = [0, { "execute-api": _3, "emrappui-prod": _3, "emrnotebooks-prod": _3, "emrstudio-prod": _3, "dualstack": _30, "s3": _3, "s3-accesspoint": _3, "s3-accesspoint-fips": _3, "s3-fips": _3, "s3-object-lambda": _3, "s3-website": _3, "aws-cloud9": _24, "cloud9": _25 }], _32 = [0, { "execute-api": _3, "emrappui-prod": _3, "emrnotebooks-prod": _3, "emrstudio-prod": _3, "dualstack": _30, "s3": _3, "s3-accesspoint": _3, "s3-accesspoint-fips": _3, "s3-deprecated": _3, "s3-fips": _3, "s3-object-lambda": _3, "s3-website": _3, "analytics-gateway": _3, "aws-cloud9": _24, "cloud9": _25 }], _33 = [0, { "s3": _3, "s3-accesspoint": _3, "s3-accesspoint-fips": _3, "s3-fips": _3 }], _34 = [0, { "execute-api": _3, "emrappui-prod": _3, "emrnotebooks-prod": _3, "emrstudio-prod": _3, "dualstack": _33, "s3": _3, "s3-accesspoint": _3, "s3-accesspoint-fips": _3, "s3-fips": _3, "s3-object-lambda": _3, "s3-website": _3 }], _35 = [0, { "auth": _3 }], _36 = [0, { "auth": _3, "auth-fips": _3 }], _37 = [0, { "apps": _3 }], _38 = [0, { "paas": _3 }], _39 = [2, { "eu": _3 }], _40 = [0, { "app": _3 }], _41 = [0, { "site": _3 }], _42 = [1, { "com": _2, "edu": _2, "net": _2, "org": _2 }], _43 = [0, { "j": _3 }], _44 = [1, { "co": _2, "com": _2, "edu": _2, "gov": _2, "net": _2, "org": _2 }], _45 = [0, { "p": _3 }], _46 = [0, { "user": _3 }], _47 = [0, { "shop": _3 }], _48 = [0, { "cust": _3, "reservd": _3 }], _49 = [0, { "cust": _3 }], _50 = [1, { "gov": _2, "edu": _2, "mil": _2, "com": _2, "org": _2, "net": _2 }], _51 = [0, { "s3": _3 }], _52 = [1, { "edu": _2, "biz": _2, "net": _2, "org": _2, "gov": _2, "info": _2, "com": _2 }], _53 = [1, { "framer": _3 }], _54 = [0, { "forgot": _3 }], _55 = [0, { "cdn": _3 }], _56 = [1, { "gs": _2 }], _57 = [0, { "nes": _2 }], _58 = [1, { "k12": _2, "cc": _2, "lib": _2 }], _59 = [1, { "cc": _2, "lib": _2 }];
    const rules = [0, { "ac": [1, { "com": _2, "edu": _2, "gov": _2, "net": _2, "mil": _2, "org": _2, "drr": _3, "feedback": _3, "forms": _3 }], "ad": _2, "ae": [1, { "co": _2, "net": _2, "org": _2, "sch": _2, "ac": _2, "gov": _2, "mil": _2, "blogspot": _3 }], "aero": [1, { "airline": _2, "airport": _2, "accident-investigation": _2, "accident-prevention": _2, "aerobatic": _2, "aeroclub": _2, "aerodrome": _2, "agents": _2, "air-surveillance": _2, "air-traffic-control": _2, "aircraft": _2, "airtraffic": _2, "ambulance": _2, "association": _2, "author": _2, "ballooning": _2, "broker": _2, "caa": _2, "cargo": _2, "catering": _2, "certification": _2, "championship": _2, "charter": _2, "civilaviation": _2, "club": _2, "conference": _2, "consultant": _2, "consulting": _2, "control": _2, "council": _2, "crew": _2, "design": _2, "dgca": _2, "educator": _2, "emergency": _2, "engine": _2, "engineer": _2, "entertainment": _2, "equipment": _2, "exchange": _2, "express": _2, "federation": _2, "flight": _2, "freight": _2, "fuel": _2, "gliding": _2, "government": _2, "groundhandling": _2, "group": _2, "hanggliding": _2, "homebuilt": _2, "insurance": _2, "journal": _2, "journalist": _2, "leasing": _2, "logistics": _2, "magazine": _2, "maintenance": _2, "marketplace": _2, "media": _2, "microlight": _2, "modelling": _2, "navigation": _2, "parachuting": _2, "paragliding": _2, "passenger-association": _2, "pilot": _2, "press": _2, "production": _2, "recreation": _2, "repbody": _2, "res": _2, "research": _2, "rotorcraft": _2, "safety": _2, "scientist": _2, "services": _2, "show": _2, "skydiving": _2, "software": _2, "student": _2, "taxi": _2, "trader": _2, "trading": _2, "trainer": _2, "union": _2, "workinggroup": _2, "works": _2 }], "af": _4, "ag": [1, { "com": _2, "org": _2, "net": _2, "co": _2, "nom": _2 }], "ai": [1, { "off": _2, "com": _2, "net": _2, "org": _2, "uwu": _3, "framer": _3 }], "al": [1, { "com": _2, "edu": _2, "gov": _2, "mil": _2, "net": _2, "org": _2, "blogspot": _3 }], "am": [1, { "co": _2, "com": _2, "commune": _2, "net": _2, "org": _2, "radio": _3, "blogspot": _3 }], "ao": [1, { "ed": _2, "edu": _2, "gov": _2, "gv": _2, "og": _2, "org": _2, "co": _2, "pb": _2, "it": _2 }], "aq": _2, "ar": [1, { "bet": _2, "com": _8, "coop": _2, "edu": _2, "gob": _2, "gov": _2, "int": _2, "mil": _2, "musica": _2, "mutual": _2, "net": _2, "org": _2, "senasa": _2, "tur": _2 }], "arpa": [1, { "e164": _2, "home": _2, "in-addr": _2, "ip6": _2, "iris": _2, "uri": _2, "urn": _2 }], "as": _9, "asia": [1, { "cloudns": _3, "daemon": _3, "dix": _3 }], "at": [1, { "ac": [1, { "sth": _2 }], "co": _8, "gv": _2, "or": _2, "funkfeuer": [0, { "wien": _3 }], "futurecms": [0, { "*": _3, "ex": _5, "in": _5 }], "futurehosting": _3, "futuremailing": _3, "ortsinfo": [0, { "ex": _5, "kunden": _5 }], "biz": _3, "info": _3, "123webseite": _3, "priv": _3, "myspreadshop": _3, "12hp": _3, "2ix": _3, "4lima": _3, "lima-city": _3 }], "au": [1, { "com": [1, { "blogspot": _3, "cloudlets": [0, { "mel": _3 }], "myspreadshop": _3 }], "net": _2, "org": _2, "edu": [1, { "act": _2, "catholic": _2, "nsw": [1, { "schools": _2 }], "nt": _2, "qld": _2, "sa": _2, "tas": _2, "vic": _2, "wa": _2 }], "gov": [1, { "qld": _2, "sa": _2, "tas": _2, "vic": _2, "wa": _2 }], "asn": _2, "id": _2, "conf": _2, "oz": _2, "act": _2, "nsw": _2, "nt": _2, "qld": _2, "sa": _2, "tas": _2, "vic": _2, "wa": _2 }], "aw": [1, { "com": _2 }], "ax": _2, "az": [1, { "biz": _2, "com": _2, "edu": _2, "gov": _2, "info": _2, "int": _2, "mil": _2, "name": _2, "net": _2, "org": _2, "pp": _2, "pro": _2 }], "ba": [1, { "com": _2, "edu": _2, "gov": _2, "mil": _2, "net": _2, "org": _2, "blogspot": _3, "rs": _3 }], "bb": [1, { "biz": _2, "co": _2, "com": _2, "edu": _2, "gov": _2, "info": _2, "net": _2, "org": _2, "store": _2, "tv": _2 }], "bd": _15, "be": [1, { "ac": _2, "cloudns": _3, "webhosting": _3, "blogspot": _3, "interhostsolutions": _16, "kuleuven": [0, { "ezproxy": _3 }], "123website": _3, "myspreadshop": _3, "transurl": _5 }], "bf": _9, "bg": [1, { "0": _2, "1": _2, "2": _2, "3": _2, "4": _2, "5": _2, "6": _2, "7": _2, "8": _2, "9": _2, "a": _2, "b": _2, "c": _2, "d": _2, "e": _2, "f": _2, "g": _2, "h": _2, "i": _2, "j": _2, "k": _2, "l": _2, "m": _2, "n": _2, "o": _2, "p": _2, "q": _2, "r": _2, "s": _2, "t": _2, "u": _2, "v": _2, "w": _2, "x": _2, "y": _2, "z": _2, "blogspot": _3, "barsy": _3 }], "bh": _4, "bi": [1, { "co": _2, "com": _2, "edu": _2, "or": _2, "org": _2 }], "biz": [1, { "activetrail": _3, "cloud-ip": _3, "cloudns": _3, "jozi": _3, "dyndns": _3, "for-better": _3, "for-more": _3, "for-some": _3, "for-the": _3, "selfip": _3, "webhop": _3, "orx": _3, "mmafan": _3, "myftp": _3, "no-ip": _3, "dscloud": _3 }], "bj": [1, { "africa": _2, "agro": _2, "architectes": _2, "assur": _2, "avocats": _2, "co": _2, "com": _2, "eco": _2, "econo": _2, "edu": _2, "info": _2, "loisirs": _2, "money": _2, "net": _2, "org": _2, "ote": _2, "resto": _2, "restaurant": _2, "tourism": _2, "univ": _2, "blogspot": _3 }], "bm": _4, "bn": [1, { "com": _2, "edu": _2, "gov": _2, "net": _2, "org": _2, "co": _3 }], "bo": [1, { "com": _2, "edu": _2, "gob": _2, "int": _2, "mil": _2, "net": _2, "org": _2, "tv": _2, "web": _2, "academia": _2, "agro": _2, "arte": _2, "blog": _2, "bolivia": _2, "ciencia": _2, "cooperativa": _2, "democracia": _2, "deporte": _2, "ecologia": _2, "economia": _2, "empresa": _2, "indigena": _2, "industria": _2, "info": _2, "medicina": _2, "movimiento": _2, "musica": _2, "natural": _2, "nombre": _2, "noticias": _2, "patria": _2, "plurinacional": _2, "politica": _2, "profesional": _2, "pueblo": _2, "revista": _2, "salud": _2, "tecnologia": _2, "tksat": _2, "transporte": _2, "wiki": _2 }], "br": [1, { "9guacu": _2, "abc": _2, "adm": _2, "adv": _2, "agr": _2, "aju": _2, "am": _2, "anani": _2, "aparecida": _2, "app": _2, "arq": _2, "art": _2, "ato": _2, "b": _2, "barueri": _2, "belem": _2, "bet": _2, "bhz": _2, "bib": _2, "bio": _2, "blog": _2, "bmd": _2, "boavista": _2, "bsb": _2, "campinagrande": _2, "campinas": _2, "caxias": _2, "cim": _2, "cng": _2, "cnt": _2, "com": [1, { "blogspot": _3, "simplesite": _3 }], "contagem": _2, "coop": _2, "coz": _2, "cri": _2, "cuiaba": _2, "curitiba": _2, "def": _2, "des": _2, "det": _2, "dev": _2, "ecn": _2, "eco": _2, "edu": _2, "emp": _2, "enf": _2, "eng": _2, "esp": _2, "etc": _2, "eti": _2, "far": _2, "feira": _2, "flog": _2, "floripa": _2, "fm": _2, "fnd": _2, "fortal": _2, "fot": _2, "foz": _2, "fst": _2, "g12": _2, "geo": _2, "ggf": _2, "goiania": _2, "gov": [1, { "ac": _2, "al": _2, "am": _2, "ap": _2, "ba": _2, "ce": _2, "df": _2, "es": _2, "go": _2, "ma": _2, "mg": _2, "ms": _2, "mt": _2, "pa": _2, "pb": _2, "pe": _2, "pi": _2, "pr": _2, "rj": _2, "rn": _2, "ro": _2, "rr": _2, "rs": _2, "sc": _2, "se": _2, "sp": _2, "to": _2 }], "gru": _2, "imb": _2, "ind": _2, "inf": _2, "jab": _2, "jampa": _2, "jdf": _2, "joinville": _2, "jor": _2, "jus": _2, "leg": [1, { "ac": _3, "al": _3, "am": _3, "ap": _3, "ba": _3, "ce": _3, "df": _3, "es": _3, "go": _3, "ma": _3, "mg": _3, "ms": _3, "mt": _3, "pa": _3, "pb": _3, "pe": _3, "pi": _3, "pr": _3, "rj": _3, "rn": _3, "ro": _3, "rr": _3, "rs": _3, "sc": _3, "se": _3, "sp": _3, "to": _3 }], "leilao": _2, "lel": _2, "log": _2, "londrina": _2, "macapa": _2, "maceio": _2, "manaus": _2, "maringa": _2, "mat": _2, "med": _2, "mil": _2, "morena": _2, "mp": _2, "mus": _2, "natal": _2, "net": _2, "niteroi": _2, "nom": _15, "not": _2, "ntr": _2, "odo": _2, "ong": _2, "org": _2, "osasco": _2, "palmas": _2, "poa": _2, "ppg": _2, "pro": _2, "psc": _2, "psi": _2, "pvh": _2, "qsl": _2, "radio": _2, "rec": _2, "recife": _2, "rep": _2, "ribeirao": _2, "rio": _2, "riobranco": _2, "riopreto": _2, "salvador": _2, "sampa": _2, "santamaria": _2, "santoandre": _2, "saobernardo": _2, "saogonca": _2, "seg": _2, "sjc": _2, "slg": _2, "slz": _2, "sorocaba": _2, "srv": _2, "taxi": _2, "tc": _2, "tec": _2, "teo": _2, "the": _2, "tmp": _2, "trd": _2, "tur": _2, "tv": _2, "udi": _2, "vet": _2, "vix": _2, "vlog": _2, "wiki": _2, "zlg": _2 }], "bs": [1, { "com": _2, "net": _2, "org": _2, "edu": _2, "gov": _2, "we": _3 }], "bt": _4, "bv": _2, "bw": [1, { "co": _2, "org": _2 }], "by": [1, { "gov": _2, "mil": _2, "com": _8, "of": _2, "mediatech": _3 }], "bz": [1, { "co": _2, "com": _2, "net": _2, "org": _2, "edu": _2, "gov": _2, "za": _3, "mydns": _3, "gsj": _3 }], "ca": [1, { "ab": _2, "bc": _2, "mb": _2, "nb": _2, "nf": _2, "nl": _2, "ns": _2, "nt": _2, "nu": _2, "on": _2, "pe": _2, "qc": _2, "sk": _2, "yk": _2, "gc": _2, "barsy": _3, "awdev": _5, "co": _3, "blogspot": _3, "no-ip": _3, "myspreadshop": _3, "box": _3 }], "cat": _2, "cc": [1, { "cleverapps": _3, "cloudns": _3, "ftpaccess": _3, "game-server": _3, "myphotos": _3, "scrapping": _3, "twmail": _3, "csx": _3, "fantasyleague": _3, "spawn": [0, { "instances": _3 }] }], "cd": _9, "cf": _8, "cg": _2, "ch": [1, { "square7": _3, "cloudns": _3, "cloudscale": [0, { "cust": _3, "lpg": _18, "rma": _18 }], "blogspot": _3, "flow": [0, { "ae": [0, { "alp1": _3 }], "appengine": _3 }], "linkyard-cloud": _3, "gotdns": _3, "dnsking": _3, "123website": _3, "myspreadshop": _3, "firenet": [0, { "*": _3, "svc": _5 }], "12hp": _3, "2ix": _3, "4lima": _3, "lima-city": _3 }], "ci": [1, { "org": _2, "or": _2, "com": _2, "co": _2, "edu": _2, "ed": _2, "ac": _2, "net": _2, "go": _2, "asso": _2, "xn--aroport-bya": _2, "aroport": _2, "int": _2, "gouv": _2, "fin": _3 }], "ck": _15, "cl": [1, { "co": _2, "gob": _2, "gov": _2, "mil": _2, "cloudns": _3, "blogspot": _3 }], "cm": [1, { "co": _2, "com": _2, "gov": _2, "net": _2 }], "cn": [1, { "ac": _2, "com": [1, { "amazonaws": [0, { "cn-north-1": [0, { "execute-api": _3, "emrappui-prod": _3, "emrnotebooks-prod": _3, "emrstudio-prod": _3, "dualstack": _21, "s3": _3, "s3-accesspoint": _3, "s3-deprecated": _3, "s3-object-lambda": _3, "s3-website": _3 }], "cn-northwest-1": [0, { "execute-api": _3, "emrappui-prod": _3, "emrnotebooks-prod": _3, "emrstudio-prod": _3, "dualstack": _22, "s3": _3, "s3-accesspoint": _3, "s3-object-lambda": _3, "s3-website": _3 }], "compute": _5, "airflow": [0, { "cn-north-1": _5, "cn-northwest-1": _5 }], "eb": [0, { "cn-north-1": _3, "cn-northwest-1": _3 }], "elb": _5 }], "sagemaker": [0, { "cn-north-1": _10, "cn-northwest-1": _10 }] }], "edu": _2, "gov": _2, "net": _2, "org": _2, "mil": _2, "xn--55qx5d": _2, "": _2, "xn--io0a7i": _2, "": _2, "xn--od0alg": _2, "": _2, "ah": _2, "bj": _2, "cq": _2, "fj": _2, "gd": _2, "gs": _2, "gz": _2, "gx": _2, "ha": _2, "hb": _2, "he": _2, "hi": _2, "hl": _2, "hn": _2, "jl": _2, "js": _2, "jx": _2, "ln": _2, "nm": _2, "nx": _2, "qh": _2, "sc": _2, "sd": _2, "sh": [1, { "as": _3 }], "sn": _2, "sx": _2, "tj": _2, "xj": _2, "xz": _2, "yn": _2, "zj": _2, "hk": _2, "mo": _2, "tw": _2, "canva-apps": _3, "canvasite": _20, "myqnapcloud": _3, "quickconnect": _23 }], "co": [1, { "com": _8, "edu": _2, "gov": _2, "mil": _2, "net": _2, "nom": _2, "org": _2, "carrd": _3, "crd": _3, "otap": _5, "leadpages": _3, "lpages": _3, "mypi": _3, "n4t": _3, "xmit": _5, "firewalledreplit": _7, "repl": _7, "supabase": _3 }], "com": [1, { "a2hosted": _3, "cpserver": _3, "adobeaemcloud": [2, { "dev": _5 }], "africa": _3, "airkitapps": _3, "airkitapps-au": _3, "aivencloud": _3, "kasserver": _3, "amazonaws": [0, { "af-south-1": _26, "ap-east-1": _27, "ap-northeast-1": _28, "ap-northeast-2": _28, "ap-northeast-3": _26, "ap-south-1": _28, "ap-south-2": _29, "ap-southeast-1": _28, "ap-southeast-2": _28, "ap-southeast-3": _29, "ap-southeast-4": _29, "ap-southeast-5": [0, { "execute-api": _3, "dualstack": _21, "s3": _3, "s3-accesspoint": _3, "s3-deprecated": _3, "s3-object-lambda": _3, "s3-website": _3 }], "ca-central-1": _31, "ca-west-1": [0, { "execute-api": _3, "emrappui-prod": _3, "emrnotebooks-prod": _3, "emrstudio-prod": _3, "dualstack": _30, "s3": _3, "s3-accesspoint": _3, "s3-accesspoint-fips": _3, "s3-fips": _3, "s3-object-lambda": _3, "s3-website": _3 }], "eu-central-1": _28, "eu-central-2": _29, "eu-north-1": _27, "eu-south-1": _26, "eu-south-2": _29, "eu-west-1": [0, { "execute-api": _3, "emrappui-prod": _3, "emrnotebooks-prod": _3, "emrstudio-prod": _3, "dualstack": _21, "s3": _3, "s3-accesspoint": _3, "s3-deprecated": _3, "s3-object-lambda": _3, "s3-website": _3, "analytics-gateway": _3, "aws-cloud9": _24, "cloud9": _25 }], "eu-west-2": _27, "eu-west-3": _26, "il-central-1": [0, { "execute-api": _3, "emrappui-prod": _3, "emrnotebooks-prod": _3, "emrstudio-prod": _3, "dualstack": _21, "s3": _3, "s3-accesspoint": _3, "s3-object-lambda": _3, "s3-website": _3, "aws-cloud9": _24, "cloud9": [0, { "vfs": _3 }] }], "me-central-1": _29, "me-south-1": _27, "sa-east-1": _26, "us-east-1": [2, { "execute-api": _3, "emrappui-prod": _3, "emrnotebooks-prod": _3, "emrstudio-prod": _3, "dualstack": _30, "s3": _3, "s3-accesspoint": _3, "s3-accesspoint-fips": _3, "s3-deprecated": _3, "s3-fips": _3, "s3-object-lambda": _3, "s3-website": _3, "analytics-gateway": _3, "aws-cloud9": _24, "cloud9": _25 }], "us-east-2": _32, "us-gov-east-1": _34, "us-gov-west-1": _34, "us-west-1": _31, "us-west-2": _32, "compute": _5, "compute-1": _5, "airflow": [0, { "af-south-1": _5, "ap-east-1": _5, "ap-northeast-1": _5, "ap-northeast-2": _5, "ap-northeast-3": _5, "ap-south-1": _5, "ap-south-2": _5, "ap-southeast-1": _5, "ap-southeast-2": _5, "ap-southeast-3": _5, "ap-southeast-4": _5, "ca-central-1": _5, "ca-west-1": _5, "eu-central-1": _5, "eu-central-2": _5, "eu-north-1": _5, "eu-south-1": _5, "eu-south-2": _5, "eu-west-1": _5, "eu-west-2": _5, "eu-west-3": _5, "il-central-1": _5, "me-central-1": _5, "me-south-1": _5, "sa-east-1": _5, "us-east-1": _5, "us-east-2": _5, "us-west-1": _5, "us-west-2": _5 }], "s3": _3, "s3-1": _3, "s3-ap-east-1": _3, "s3-ap-northeast-1": _3, "s3-ap-northeast-2": _3, "s3-ap-northeast-3": _3, "s3-ap-south-1": _3, "s3-ap-southeast-1": _3, "s3-ap-southeast-2": _3, "s3-ca-central-1": _3, "s3-eu-central-1": _3, "s3-eu-north-1": _3, "s3-eu-west-1": _3, "s3-eu-west-2": _3, "s3-eu-west-3": _3, "s3-external-1": _3, "s3-fips-us-gov-east-1": _3, "s3-fips-us-gov-west-1": _3, "s3-global": [0, { "accesspoint": [0, { "mrap": _3 }] }], "s3-me-south-1": _3, "s3-sa-east-1": _3, "s3-us-east-2": _3, "s3-us-gov-east-1": _3, "s3-us-gov-west-1": _3, "s3-us-west-1": _3, "s3-us-west-2": _3, "s3-website-ap-northeast-1": _3, "s3-website-ap-southeast-1": _3, "s3-website-ap-southeast-2": _3, "s3-website-eu-west-1": _3, "s3-website-sa-east-1": _3, "s3-website-us-east-1": _3, "s3-website-us-gov-west-1": _3, "s3-website-us-west-1": _3, "s3-website-us-west-2": _3, "elb": _5 }], "amazoncognito": [0, { "af-south-1": _35, "ap-east-1": _35, "ap-northeast-1": _35, "ap-northeast-2": _35, "ap-northeast-3": _35, "ap-south-1": _35, "ap-south-2": _35, "ap-southeast-1": _35, "ap-southeast-2": _35, "ap-southeast-3": _35, "ap-southeast-4": _35, "ca-central-1": _35, "ca-west-1": _35, "eu-central-1": _35, "eu-central-2": _35, "eu-north-1": _35, "eu-south-1": _35, "eu-south-2": _35, "eu-west-1": _35, "eu-west-2": _35, "eu-west-3": _35, "il-central-1": _35, "me-central-1": _35, "me-south-1": _35, "sa-east-1": _35, "us-east-1": _36, "us-east-2": _36, "us-gov-west-1": [0, { "auth-fips": _3 }], "us-west-1": _36, "us-west-2": _36 }], "amplifyapp": _3, "awsapprunner": _5, "awsapps": _3, "elasticbeanstalk": [2, { "af-south-1": _3, "ap-east-1": _3, "ap-northeast-1": _3, "ap-northeast-2": _3, "ap-northeast-3": _3, "ap-south-1": _3, "ap-southeast-1": _3, "ap-southeast-2": _3, "ap-southeast-3": _3, "ca-central-1": _3, "eu-central-1": _3, "eu-north-1": _3, "eu-south-1": _3, "eu-west-1": _3, "eu-west-2": _3, "eu-west-3": _3, "il-central-1": _3, "me-south-1": _3, "sa-east-1": _3, "us-east-1": _3, "us-east-2": _3, "us-gov-east-1": _3, "us-gov-west-1": _3, "us-west-1": _3, "us-west-2": _3 }], "awsglobalaccelerator": _3, "siiites": _3, "appspacehosted": _3, "appspaceusercontent": _3, "on-aptible": _3, "myasustor": _3, "balena-devices": _3, "boutir": _3, "bplaced": _3, "cafjs": _3, "canva-apps": _3, "cdn77-storage": _3, "br": _3, "cn": _3, "de": _3, "eu": _3, "jpn": _3, "mex": _3, "ru": _3, "sa": _3, "uk": _3, "us": _3, "za": _3, "clever-cloud": [0, { "services": _5 }], "dnsabr": _3, "ip-ddns": _3, "jdevcloud": _3, "wpdevcloud": _3, "cf-ipfs": _3, "cloudflare-ipfs": _3, "trycloudflare": _3, "co": _3, "builtwithdark": _3, "datadetect": [0, { "demo": _3, "instance": _3 }], "dattolocal": _3, "dattorelay": _3, "dattoweb": _3, "mydatto": _3, "digitaloceanspaces": _5, "discordsays": _3, "discordsez": _3, "drayddns": _3, "dreamhosters": _3, "durumis": _3, "mydrobo": _3, "blogdns": _3, "cechire": _3, "dnsalias": _3, "dnsdojo": _3, "doesntexist": _3, "dontexist": _3, "doomdns": _3, "dyn-o-saur": _3, "dynalias": _3, "dyndns-at-home": _3, "dyndns-at-work": _3, "dyndns-blog": _3, "dyndns-free": _3, "dyndns-home": _3, "dyndns-ip": _3, "dyndns-mail": _3, "dyndns-office": _3, "dyndns-pics": _3, "dyndns-remote": _3, "dyndns-server": _3, "dyndns-web": _3, "dyndns-wiki": _3, "dyndns-work": _3, "est-a-la-maison": _3, "est-a-la-masion": _3, "est-le-patron": _3, "est-mon-blogueur": _3, "from-ak": _3, "from-al": _3, "from-ar": _3, "from-ca": _3, "from-ct": _3, "from-dc": _3, "from-de": _3, "from-fl": _3, "from-ga": _3, "from-hi": _3, "from-ia": _3, "from-id": _3, "from-il": _3, "from-in": _3, "from-ks": _3, "from-ky": _3, "from-ma": _3, "from-md": _3, "from-mi": _3, "from-mn": _3, "from-mo": _3, "from-ms": _3, "from-mt": _3, "from-nc": _3, "from-nd": _3, "from-ne": _3, "from-nh": _3, "from-nj": _3, "from-nm": _3, "from-nv": _3, "from-oh": _3, "from-ok": _3, "from-or": _3, "from-pa": _3, "from-pr": _3, "from-ri": _3, "from-sc": _3, "from-sd": _3, "from-tn": _3, "from-tx": _3, "from-ut": _3, "from-va": _3, "from-vt": _3, "from-wa": _3, "from-wi": _3, "from-wv": _3, "from-wy": _3, "getmyip": _3, "gotdns": _3, "hobby-site": _3, "homelinux": _3, "homeunix": _3, "iamallama": _3, "is-a-anarchist": _3, "is-a-blogger": _3, "is-a-bookkeeper": _3, "is-a-bulls-fan": _3, "is-a-caterer": _3, "is-a-chef": _3, "is-a-conservative": _3, "is-a-cpa": _3, "is-a-cubicle-slave": _3, "is-a-democrat": _3, "is-a-designer": _3, "is-a-doctor": _3, "is-a-financialadvisor": _3, "is-a-geek": _3, "is-a-green": _3, "is-a-guru": _3, "is-a-hard-worker": _3, "is-a-hunter": _3, "is-a-landscaper": _3, "is-a-lawyer": _3, "is-a-liberal": _3, "is-a-libertarian": _3, "is-a-llama": _3, "is-a-musician": _3, "is-a-nascarfan": _3, "is-a-nurse": _3, "is-a-painter": _3, "is-a-personaltrainer": _3, "is-a-photographer": _3, "is-a-player": _3, "is-a-republican": _3, "is-a-rockstar": _3, "is-a-socialist": _3, "is-a-student": _3, "is-a-teacher": _3, "is-a-techie": _3, "is-a-therapist": _3, "is-an-accountant": _3, "is-an-actor": _3, "is-an-actress": _3, "is-an-anarchist": _3, "is-an-artist": _3, "is-an-engineer": _3, "is-an-entertainer": _3, "is-certified": _3, "is-gone": _3, "is-into-anime": _3, "is-into-cars": _3, "is-into-cartoons": _3, "is-into-games": _3, "is-leet": _3, "is-not-certified": _3, "is-slick": _3, "is-uberleet": _3, "is-with-theband": _3, "isa-geek": _3, "isa-hockeynut": _3, "issmarterthanyou": _3, "likes-pie": _3, "likescandy": _3, "neat-url": _3, "saves-the-whales": _3, "selfip": _3, "sells-for-less": _3, "sells-for-u": _3, "servebbs": _3, "simple-url": _3, "space-to-rent": _3, "teaches-yoga": _3, "writesthisblog": _3, "ddnsfree": _3, "ddnsgeek": _3, "giize": _3, "gleeze": _3, "kozow": _3, "loseyourip": _3, "ooguy": _3, "theworkpc": _3, "mytuleap": _3, "tuleap-partners": _3, "encoreapi": _3, "evennode": [0, { "eu-1": _3, "eu-2": _3, "eu-3": _3, "eu-4": _3, "us-1": _3, "us-2": _3, "us-3": _3, "us-4": _3 }], "onfabrica": _3, "fastly-edge": _3, "fastly-terrarium": _3, "fastvps-server": _3, "mydobiss": _3, "firebaseapp": _3, "fldrv": _3, "forgeblocks": _3, "framercanvas": _3, "freebox-os": _3, "freeboxos": _3, "freemyip": _3, "aliases121": _3, "gentapps": _3, "gentlentapis": _3, "githubusercontent": _3, "0emm": _5, "appspot": [2, { "r": _5 }], "blogspot": _3, "codespot": _3, "googleapis": _3, "googlecode": _3, "pagespeedmobilizer": _3, "withgoogle": _3, "withyoutube": _3, "grayjayleagues": _3, "hatenablog": _3, "hatenadiary": _3, "herokuapp": _3, "herokussl": _3, "gr": _3, "smushcdn": _3, "wphostedmail": _3, "wpmucdn": _3, "pixolino": _3, "apps-1and1": _3, "live-website": _3, "dopaas": _3, "hosted-by-previder": _38, "hosteur": [0, { "rag-cloud": _3, "rag-cloud-ch": _3 }], "ik-server": [0, { "jcloud": _3, "jcloud-ver-jpc": _3 }], "jelastic": [0, { "demo": _3 }], "massivegrid": _38, "wafaicloud": [0, { "jed": _3, "ryd": _3 }], "webadorsite": _3, "joyent": [0, { "cns": _5 }], "lpusercontent": _3, "linode": [0, { "members": _3, "nodebalancer": _5 }], "linodeobjects": _5, "linodeusercontent": [0, { "ip": _3 }], "barsycenter": _3, "barsyonline": _3, "modelscape": _3, "mwcloudnonprod": _3, "polyspace": _3, "mazeplay": _3, "miniserver": _3, "atmeta": _3, "fbsbx": _37, "meteorapp": _39, "routingthecloud": _3, "mydbserver": _3, "hostedpi": _3, "mythic-beasts": [0, { "caracal": _3, "customer": _3, "fentiger": _3, "lynx": _3, "ocelot": _3, "oncilla": _3, "onza": _3, "sphinx": _3, "vs": _3, "x": _3, "yali": _3 }], "nospamproxy": _16, "4u": _3, "nfshost": _3, "3utilities": _3, "blogsyte": _3, "ciscofreak": _3, "damnserver": _3, "ddnsking": _3, "ditchyourip": _3, "dnsiskinky": _3, "dynns": _3, "geekgalaxy": _3, "health-carereform": _3, "homesecuritymac": _3, "homesecuritypc": _3, "myactivedirectory": _3, "mysecuritycamera": _3, "myvnc": _3, "net-freaks": _3, "onthewifi": _3, "point2this": _3, "quicksytes": _3, "securitytactics": _3, "servebeer": _3, "servecounterstrike": _3, "serveexchange": _3, "serveftp": _3, "servegame": _3, "servehalflife": _3, "servehttp": _3, "servehumour": _3, "serveirc": _3, "servemp3": _3, "servep2p": _3, "servepics": _3, "servequake": _3, "servesarcasm": _3, "stufftoread": _3, "unusualperson": _3, "workisboring": _3, "001www": _3, "myiphost": _3, "observableusercontent": [0, { "static": _3 }], "simplesite": _3, "orsites": _3, "operaunite": _3, "customer-oci": [0, { "*": _3, "oci": _5, "ocp": _5, "ocs": _5 }], "oraclecloudapps": _5, "oraclegovcloudapps": _5, "authgear-staging": _3, "authgearapps": _3, "skygearapp": _3, "outsystemscloud": _3, "ownprovider": _3, "pgfog": _3, "pagexl": _3, "gotpantheon": _3, "paywhirl": _5, "upsunapp": _3, "platter-app": _3, "postman-echo": _3, "prgmr": [0, { "xen": _3 }], "pythonanywhere": _39, "qa2": _3, "alpha-myqnapcloud": _3, "dev-myqnapcloud": _3, "mycloudnas": _3, "mynascloud": _3, "myqnapcloud": _3, "qualifioapp": _3, "ladesk": _3, "qbuser": _3, "quipelements": _5, "rackmaze": _3, "readthedocs-hosted": _3, "rhcloud": _3, "onrender": _3, "render": _40, "180r": _3, "dojin": _3, "sakuratan": _3, "sakuraweb": _3, "x0": _3, "code": [0, { "builder": _5, "dev-builder": _5, "stg-builder": _5 }], "salesforce": [0, { "platform": [0, { "code-builder-stg": [0, { "test": [0, { "001": _5 }] }] }] }], "logoip": _3, "scrysec": _3, "firewall-gateway": _3, "myshopblocks": _3, "myshopify": _3, "shopitsite": _3, "1kapp": _3, "appchizi": _3, "applinzi": _3, "sinaapp": _3, "vipsinaapp": _3, "streamlitapp": _3, "try-snowplow": _3, "playstation-cloud": _3, "myspreadshop": _3, "w-corp-staticblitz": _3, "w-credentialless-staticblitz": _3, "w-staticblitz": _3, "stackhero-network": _3, "stdlib": [0, { "api": _3 }], "strapiapp": [2, { "media": _3 }], "streak-link": _3, "streaklinks": _3, "streakusercontent": _3, "temp-dns": _3, "dsmynas": _3, "familyds": _3, "mytabit": _3, "taveusercontent": _3, "tb-hosting": _41, "reservd": _3, "thingdustdata": _3, "townnews-staging": _3, "typeform": [0, { "pro": _3 }], "hk": _3, "it": _3, "vultrobjects": _5, "wafflecell": _3, "hotelwithflight": _3, "reserve-online": _3, "cprapid": _3, "pleskns": _3, "remotewd": _3, "wiardweb": [0, { "pages": _3 }], "wixsite": _3, "wixstudio": _3, "messwithdns": _3, "woltlab-demo": _3, "wpenginepowered": [2, { "js": _3 }], "xnbay": [2, { "u2": _3, "u2-local": _3 }], "yolasite": _3 }], "coop": _2, "cr": [1, { "ac": _2, "co": _2, "ed": _2, "fi": _2, "go": _2, "or": _2, "sa": _2 }], "cu": [1, { "com": _2, "edu": _2, "gob": _2, "inf": _2, "nat": _2, "net": _2, "org": _2 }], "cv": [1, { "com": _2, "edu": _2, "int": _2, "nome": _2, "org": _2, "blogspot": _3 }], "cw": _42, "cx": [1, { "gov": _2, "cloudns": _3, "ath": _3, "info": _3, "assessments": _3, "calculators": _3, "funnels": _3, "paynow": _3, "quizzes": _3, "researched": _3, "tests": _3 }], "cy": [1, { "ac": _2, "biz": _2, "com": [1, { "blogspot": _3, "scaleforce": _43 }], "ekloges": _2, "gov": _2, "ltd": _2, "mil": _2, "net": _2, "org": _2, "press": _2, "pro": _2, "tm": _2 }], "cz": [1, { "contentproxy9": [0, { "rsc": _3 }], "realm": _3, "e4": _3, "blogspot": _3, "co": _3, "metacentrum": [0, { "cloud": _5, "custom": _3 }], "muni": [0, { "cloud": [0, { "flt": _3, "usr": _3 }] }] }], "de": [1, { "bplaced": _3, "square7": _3, "com": _3, "cosidns": [0, { "dyn": _3 }], "dnsupdater": _3, "dynamisches-dns": _3, "internet-dns": _3, "l-o-g-i-n": _3, "ddnss": [2, { "dyn": _3, "dyndns": _3 }], "dyn-ip24": _3, "dyndns1": _3, "home-webserver": [2, { "dyn": _3 }], "myhome-server": _3, "dnshome": _3, "fuettertdasnetz": _3, "isteingeek": _3, "istmein": _3, "lebtimnetz": _3, "leitungsen": _3, "traeumtgerade": _3, "frusky": _5, "goip": _3, "blogspot": _3, "xn--gnstigbestellen-zvb": _3, "gnstigbestellen": _3, "xn--gnstigliefern-wob": _3, "gnstigliefern": _3, "hs-heilbronn": [0, { "it": [0, { "pages": _3, "pages-research": _3 }] }], "dyn-berlin": _3, "in-berlin": _3, "in-brb": _3, "in-butter": _3, "in-dsl": _3, "in-vpn": _3, "iservschule": _3, "mein-iserv": _3, "schulplattform": _3, "schulserver": _3, "test-iserv": _3, "keymachine": _3, "git-repos": _3, "lcube-server": _3, "svn-repos": _3, "barsy": _3, "webspaceconfig": _3, "123webseite": _3, "logoip": _3, "firewall-gateway": _3, "my-gateway": _3, "my-router": _3, "spdns": _3, "speedpartner": [0, { "customer": _3 }], "myspreadshop": _3, "taifun-dns": _3, "12hp": _3, "2ix": _3, "4lima": _3, "lima-city": _3, "dd-dns": _3, "dray-dns": _3, "draydns": _3, "dyn-vpn": _3, "dynvpn": _3, "mein-vigor": _3, "my-vigor": _3, "my-wan": _3, "syno-ds": _3, "synology-diskstation": _3, "synology-ds": _3, "uberspace": _5, "virtual-user": _3, "virtualuser": _3, "community-pro": _3, "diskussionsbereich": _3 }], "dj": _2, "dk": [1, { "biz": _3, "co": _3, "firm": _3, "reg": _3, "store": _3, "blogspot": _3, "123hjemmeside": _3, "myspreadshop": _3 }], "dm": _44, "do": [1, { "art": _2, "com": _2, "edu": _2, "gob": _2, "gov": _2, "mil": _2, "net": _2, "org": _2, "sld": _2, "web": _2 }], "dz": [1, { "art": _2, "asso": _2, "com": _2, "edu": _2, "gov": _2, "org": _2, "net": _2, "pol": _2, "soc": _2, "tm": _2 }], "ec": [1, { "com": _2, "info": _2, "net": _2, "fin": _2, "k12": _2, "med": _2, "pro": _2, "org": _2, "edu": _2, "gov": _2, "gob": _2, "mil": _2, "base": _3, "official": _3 }], "edu": [1, { "rit": [0, { "git-pages": _3 }] }], "ee": [1, { "edu": _2, "gov": _2, "riik": _2, "lib": _2, "med": _2, "com": _8, "pri": _2, "aip": _2, "org": _2, "fie": _2 }], "eg": [1, { "com": _8, "edu": _2, "eun": _2, "gov": _2, "mil": _2, "name": _2, "net": _2, "org": _2, "sci": _2 }], "er": _15, "es": [1, { "com": _8, "nom": _2, "org": _2, "gob": _2, "edu": _2, "123miweb": _3, "myspreadshop": _3 }], "et": [1, { "com": _2, "gov": _2, "org": _2, "edu": _2, "biz": _2, "name": _2, "info": _2, "net": _2 }], "eu": [1, { "airkitapps": _3, "cloudns": _3, "dogado": [0, { "jelastic": _3 }], "barsy": _3, "spdns": _3, "transurl": _5, "diskstation": _3 }], "fi": [1, { "aland": _2, "dy": _3, "blogspot": _3, "xn--hkkinen-5wa": _3, "hkkinen": _3, "iki": _3, "cloudplatform": [0, { "fi": _3 }], "datacenter": [0, { "demo": _3, "paas": _3 }], "kapsi": _3, "123kotisivu": _3, "myspreadshop": _3 }], "fj": [1, { "ac": _2, "biz": _2, "com": _2, "gov": _2, "info": _2, "mil": _2, "name": _2, "net": _2, "org": _2, "pro": _2 }], "fk": _15, "fm": [1, { "com": _2, "edu": _2, "net": _2, "org": _2, "radio": _3, "user": _5 }], "fo": _2, "fr": [1, { "asso": _2, "com": _2, "gouv": _2, "nom": _2, "prd": _2, "tm": _2, "avoues": _2, "cci": _2, "greta": _2, "huissier-justice": _2, "en-root": _3, "fbx-os": _3, "fbxos": _3, "freebox-os": _3, "freeboxos": _3, "blogspot": _3, "goupile": _3, "123siteweb": _3, "on-web": _3, "chirurgiens-dentistes-en-france": _3, "dedibox": _3, "aeroport": _3, "avocat": _3, "chambagri": _3, "chirurgiens-dentistes": _3, "experts-comptables": _3, "medecin": _3, "notaires": _3, "pharmacien": _3, "port": _3, "veterinaire": _3, "myspreadshop": _3, "ynh": _3 }], "ga": _2, "gb": _2, "gd": [1, { "edu": _2, "gov": _2 }], "ge": [1, { "com": _2, "edu": _2, "gov": _2, "org": _2, "mil": _2, "net": _2, "pvt": _2 }], "gf": _2, "gg": [1, { "co": _2, "net": _2, "org": _2, "kaas": _3, "stackit": _3, "panel": [2, { "daemon": _3 }] }], "gh": [1, { "com": _2, "edu": _2, "gov": _2, "org": _2, "mil": _2 }], "gi": [1, { "com": _2, "ltd": _2, "gov": _2, "mod": _2, "edu": _2, "org": _2 }], "gl": [1, { "co": _2, "com": _2, "edu": _2, "net": _2, "org": _2, "biz": _3 }], "gm": _2, "gn": [1, { "ac": _2, "com": _2, "edu": _2, "gov": _2, "org": _2, "net": _2 }], "gov": _2, "gp": [1, { "com": _2, "net": _2, "mobi": _2, "edu": _2, "org": _2, "asso": _2 }], "gq": _2, "gr": [1, { "com": _2, "edu": _2, "net": _2, "org": _2, "gov": _2, "blogspot": _3, "barsy": _3, "simplesite": _3 }], "gs": _2, "gt": [1, { "com": _2, "edu": _2, "gob": _2, "ind": _2, "mil": _2, "net": _2, "org": _2 }], "gu": [1, { "com": _2, "edu": _2, "gov": _2, "guam": _2, "info": _2, "net": _2, "org": _2, "web": _2 }], "gw": _2, "gy": _44, "hk": [1, { "com": _2, "edu": _2, "gov": _2, "idv": _2, "net": _2, "org": _2, "xn--55qx5d": _2, "": _2, "xn--wcvs22d": _2, "": _2, "xn--lcvr32d": _2, "": _2, "xn--mxtq1m": _2, "": _2, "xn--gmqw5a": _2, "": _2, "xn--ciqpn": _2, "": _2, "xn--gmq050i": _2, "": _2, "xn--zf0avx": _2, "": _2, "xn--io0a7i": _2, "": _2, "xn--mk0axi": _2, "": _2, "xn--od0alg": _2, "": _2, "xn--od0aq3b": _2, "": _2, "xn--tn0ag": _2, "": _2, "xn--uc0atv": _2, "": _2, "xn--uc0ay4a": _2, "": _2, "blogspot": _3, "secaas": _3, "inc": _3, "ltd": _3 }], "hm": _2, "hn": [1, { "com": _2, "edu": _2, "org": _2, "net": _2, "mil": _2, "gob": _2 }], "hr": [1, { "iz": _2, "from": _2, "name": _2, "com": _2, "brendly": _47, "blogspot": _3, "free": _3 }], "ht": [1, { "com": _2, "shop": _2, "firm": _2, "info": _2, "adult": _2, "net": _2, "pro": _2, "org": _2, "med": _2, "art": _2, "coop": _2, "pol": _2, "asso": _2, "edu": _2, "rel": _2, "gouv": _2, "perso": _2, "rt": _3 }], "hu": [1, { "2000": _2, "co": _2, "info": _2, "org": _2, "priv": _2, "sport": _2, "tm": _2, "agrar": _2, "bolt": _2, "casino": _2, "city": _2, "erotica": _2, "erotika": _2, "film": _2, "forum": _2, "games": _2, "hotel": _2, "ingatlan": _2, "jogasz": _2, "konyvelo": _2, "lakas": _2, "media": _2, "news": _2, "reklam": _2, "sex": _2, "shop": _2, "suli": _2, "szex": _2, "tozsde": _2, "utazas": _2, "video": _2, "blogspot": _3 }], "id": [1, { "ac": _2, "biz": _2, "co": _8, "desa": _2, "go": _2, "mil": _2, "my": [1, { "rss": _3 }], "net": _2, "or": _2, "ponpes": _2, "sch": _2, "web": _2 }], "ie": [1, { "gov": _2, "blogspot": _3, "myspreadshop": _3 }], "il": [1, { "ac": _2, "co": [1, { "blogspot": _3, "ravpage": _3, "mytabit": _3, "tabitorder": _3 }], "gov": _2, "idf": _2, "k12": _2, "muni": _2, "net": _2, "org": _2 }], "xn--4dbrk0ce": [1, { "xn--4dbgdty6c": _2, "xn--5dbhl8d": _2, "xn--8dbq2a": _2, "xn--hebda8b": _2 }], "": [1, { "": _2, "": _2, "": _2, "": _2 }], "im": [1, { "ac": _2, "co": [1, { "ltd": _2, "plc": _2 }], "com": _2, "net": _2, "org": _2, "tt": _2, "tv": _2 }], "in": [1, { "5g": _2, "6g": _2, "ac": _2, "ai": _2, "am": _2, "bihar": _2, "biz": _2, "business": _2, "ca": _2, "cn": _2, "co": _2, "com": _2, "coop": _2, "cs": _2, "delhi": _2, "dr": _2, "edu": _2, "er": _2, "firm": _2, "gen": _2, "gov": _2, "gujarat": _2, "ind": _2, "info": _2, "int": _2, "internet": _2, "io": _2, "me": _2, "mil": _2, "net": _2, "nic": _2, "org": _2, "pg": _2, "post": _2, "pro": _2, "res": _2, "travel": _2, "tv": _2, "uk": _2, "up": _2, "us": _2, "cloudns": _3, "blogspot": _3, "barsy": _3, "web": _3, "supabase": _3 }], "info": [1, { "cloudns": _3, "dynamic-dns": _3, "barrel-of-knowledge": _3, "barrell-of-knowledge": _3, "dyndns": _3, "for-our": _3, "groks-the": _3, "groks-this": _3, "here-for-more": _3, "knowsitall": _3, "selfip": _3, "webhop": _3, "barsy": _3, "mayfirst": _3, "mittwald": _3, "mittwaldserver": _3, "typo3server": _3, "dvrcam": _3, "ilovecollege": _3, "no-ip": _3, "forumz": _3, "nsupdate": _3, "dnsupdate": _3, "v-info": _3 }], "int": [1, { "eu": _2 }], "io": [1, { "2038": _3, "co": _2, "com": _2, "edu": _2, "gov": _2, "mil": _2, "net": _2, "nom": _2, "org": _2, "on-acorn": _5, "apigee": _3, "b-data": _3, "beagleboard": _3, "bitbucket": _3, "bluebite": _3, "boxfuse": _3, "brave": [0, { "s": _5 }], "browsersafetymark": _3, "bigv": [0, { "uk0": _3 }], "cleverapps": _3, "dappnode": [0, { "dyndns": _3 }], "darklang": _3, "definima": _3, "dedyn": _3, "drud": _3, "fh-muenster": _3, "shw": _3, "forgerock": [0, { "id": _3 }], "github": _3, "gitlab": _3, "lolipop": _3, "hasura-app": _3, "hostyhosting": _3, "hypernode": _3, "moonscale": _5, "beebyte": _38, "beebyteapp": [0, { "sekd1": _3 }], "jele": _3, "webthings": _3, "loginline": _3, "barsy": _3, "azurecontainer": _5, "ngrok": [2, { "ap": _3, "au": _3, "eu": _3, "in": _3, "jp": _3, "sa": _3, "us": _3 }], "nodeart": [0, { "stage": _3 }], "pantheonsite": _3, "pstmn": [2, { "mock": _3 }], "protonet": _3, "qcx": [2, { "sys": _5 }], "qoto": _3, "vaporcloud": _3, "myrdbx": _3, "rb-hosting": _41, "on-k3s": _5, "on-rio": _5, "readthedocs": _3, "resindevice": _3, "resinstaging": [0, { "devices": _3 }], "hzc": _3, "sandcats": _3, "scrypted": [0, { "client": _3 }], "shiftedit": _3, "mo-siemens": _3, "lair": _37, "stolos": _5, "spacekit": _3, "musician": _3, "utwente": _3, "edugit": _3, "telebit": _3, "thingdust": [0, { "dev": _48, "disrec": _48, "prod": _49, "testing": _48 }], "tickets": _3, "upli": _3, "webflow": _3, "webflowtest": _3, "editorx": _3, "wixstudio": _3, "basicserver": _3, "virtualserver": _3 }], "iq": _50, "ir": [1, { "ac": _2, "co": _2, "gov": _2, "id": _2, "net": _2, "org": _2, "sch": _2, "xn--mgba3a4f16a": _2, "": _2, "xn--mgba3a4fra": _2, "": _2, "arvanedge": _3 }], "is": _8, "it": [1, { "gov": _2, "edu": _2, "abr": _2, "abruzzo": _2, "aosta-valley": _2, "aostavalley": _2, "bas": _2, "basilicata": _2, "cal": _2, "calabria": _2, "cam": _2, "campania": _2, "emilia-romagna": _2, "emiliaromagna": _2, "emr": _2, "friuli-v-giulia": _2, "friuli-ve-giulia": _2, "friuli-vegiulia": _2, "friuli-venezia-giulia": _2, "friuli-veneziagiulia": _2, "friuli-vgiulia": _2, "friuliv-giulia": _2, "friulive-giulia": _2, "friulivegiulia": _2, "friulivenezia-giulia": _2, "friuliveneziagiulia": _2, "friulivgiulia": _2, "fvg": _2, "laz": _2, "lazio": _2, "lig": _2, "liguria": _2, "lom": _2, "lombardia": _2, "lombardy": _2, "lucania": _2, "mar": _2, "marche": _2, "mol": _2, "molise": _2, "piedmont": _2, "piemonte": _2, "pmn": _2, "pug": _2, "puglia": _2, "sar": _2, "sardegna": _2, "sardinia": _2, "sic": _2, "sicilia": _2, "sicily": _2, "taa": _2, "tos": _2, "toscana": _2, "trentin-sud-tirol": _2, "xn--trentin-sd-tirol-rzb": _2, "trentin-sd-tirol": _2, "trentin-sudtirol": _2, "xn--trentin-sdtirol-7vb": _2, "trentin-sdtirol": _2, "trentin-sued-tirol": _2, "trentin-suedtirol": _2, "trentino-a-adige": _2, "trentino-aadige": _2, "trentino-alto-adige": _2, "trentino-altoadige": _2, "trentino-s-tirol": _2, "trentino-stirol": _2, "trentino-sud-tirol": _2, "xn--trentino-sd-tirol-c3b": _2, "trentino-sd-tirol": _2, "trentino-sudtirol": _2, "xn--trentino-sdtirol-szb": _2, "trentino-sdtirol": _2, "trentino-sued-tirol": _2, "trentino-suedtirol": _2, "trentino": _2, "trentinoa-adige": _2, "trentinoaadige": _2, "trentinoalto-adige": _2, "trentinoaltoadige": _2, "trentinos-tirol": _2, "trentinostirol": _2, "trentinosud-tirol": _2, "xn--trentinosd-tirol-rzb": _2, "trentinosd-tirol": _2, "trentinosudtirol": _2, "xn--trentinosdtirol-7vb": _2, "trentinosdtirol": _2, "trentinosued-tirol": _2, "trentinosuedtirol": _2, "trentinsud-tirol": _2, "xn--trentinsd-tirol-6vb": _2, "trentinsd-tirol": _2, "trentinsudtirol": _2, "xn--trentinsdtirol-nsb": _2, "trentinsdtirol": _2, "trentinsued-tirol": _2, "trentinsuedtirol": _2, "tuscany": _2, "umb": _2, "umbria": _2, "val-d-aosta": _2, "val-daosta": _2, "vald-aosta": _2, "valdaosta": _2, "valle-aosta": _2, "valle-d-aosta": _2, "valle-daosta": _2, "valleaosta": _2, "valled-aosta": _2, "valledaosta": _2, "vallee-aoste": _2, "xn--valle-aoste-ebb": _2, "valle-aoste": _2, "vallee-d-aoste": _2, "xn--valle-d-aoste-ehb": _2, "valle-d-aoste": _2, "valleeaoste": _2, "xn--valleaoste-e7a": _2, "valleaoste": _2, "valleedaoste": _2, "xn--valledaoste-ebb": _2, "valledaoste": _2, "vao": _2, "vda": _2, "ven": _2, "veneto": _2, "ag": _2, "agrigento": _2, "al": _2, "alessandria": _2, "alto-adige": _2, "altoadige": _2, "an": _2, "ancona": _2, "andria-barletta-trani": _2, "andria-trani-barletta": _2, "andriabarlettatrani": _2, "andriatranibarletta": _2, "ao": _2, "aosta": _2, "aoste": _2, "ap": _2, "aq": _2, "aquila": _2, "ar": _2, "arezzo": _2, "ascoli-piceno": _2, "ascolipiceno": _2, "asti": _2, "at": _2, "av": _2, "avellino": _2, "ba": _2, "balsan-sudtirol": _2, "xn--balsan-sdtirol-nsb": _2, "balsan-sdtirol": _2, "balsan-suedtirol": _2, "balsan": _2, "bari": _2, "barletta-trani-andria": _2, "barlettatraniandria": _2, "belluno": _2, "benevento": _2, "bergamo": _2, "bg": _2, "bi": _2, "biella": _2, "bl": _2, "bn": _2, "bo": _2, "bologna": _2, "bolzano-altoadige": _2, "bolzano": _2, "bozen-sudtirol": _2, "xn--bozen-sdtirol-2ob": _2, "bozen-sdtirol": _2, "bozen-suedtirol": _2, "bozen": _2, "br": _2, "brescia": _2, "brindisi": _2, "bs": _2, "bt": _2, "bulsan-sudtirol": _2, "xn--bulsan-sdtirol-nsb": _2, "bulsan-sdtirol": _2, "bulsan-suedtirol": _2, "bulsan": _2, "bz": _2, "ca": _2, "cagliari": _2, "caltanissetta": _2, "campidano-medio": _2, "campidanomedio": _2, "campobasso": _2, "carbonia-iglesias": _2, "carboniaiglesias": _2, "carrara-massa": _2, "carraramassa": _2, "caserta": _2, "catania": _2, "catanzaro": _2, "cb": _2, "ce": _2, "cesena-forli": _2, "xn--cesena-forl-mcb": _2, "cesena-forl": _2, "cesenaforli": _2, "xn--cesenaforl-i8a": _2, "cesenaforl": _2, "ch": _2, "chieti": _2, "ci": _2, "cl": _2, "cn": _2, "co": _2, "como": _2, "cosenza": _2, "cr": _2, "cremona": _2, "crotone": _2, "cs": _2, "ct": _2, "cuneo": _2, "cz": _2, "dell-ogliastra": _2, "dellogliastra": _2, "en": _2, "enna": _2, "fc": _2, "fe": _2, "fermo": _2, "ferrara": _2, "fg": _2, "fi": _2, "firenze": _2, "florence": _2, "fm": _2, "foggia": _2, "forli-cesena": _2, "xn--forl-cesena-fcb": _2, "forl-cesena": _2, "forlicesena": _2, "xn--forlcesena-c8a": _2, "forlcesena": _2, "fr": _2, "frosinone": _2, "ge": _2, "genoa": _2, "genova": _2, "go": _2, "gorizia": _2, "gr": _2, "grosseto": _2, "iglesias-carbonia": _2, "iglesiascarbonia": _2, "im": _2, "imperia": _2, "is": _2, "isernia": _2, "kr": _2, "la-spezia": _2, "laquila": _2, "laspezia": _2, "latina": _2, "lc": _2, "le": _2, "lecce": _2, "lecco": _2, "li": _2, "livorno": _2, "lo": _2, "lodi": _2, "lt": _2, "lu": _2, "lucca": _2, "macerata": _2, "mantova": _2, "massa-carrara": _2, "massacarrara": _2, "matera": _2, "mb": _2, "mc": _2, "me": _2, "medio-campidano": _2, "mediocampidano": _2, "messina": _2, "mi": _2, "milan": _2, "milano": _2, "mn": _2, "mo": _2, "modena": _2, "monza-brianza": _2, "monza-e-della-brianza": _2, "monza": _2, "monzabrianza": _2, "monzaebrianza": _2, "monzaedellabrianza": _2, "ms": _2, "mt": _2, "na": _2, "naples": _2, "napoli": _2, "no": _2, "novara": _2, "nu": _2, "nuoro": _2, "og": _2, "ogliastra": _2, "olbia-tempio": _2, "olbiatempio": _2, "or": _2, "oristano": _2, "ot": _2, "pa": _2, "padova": _2, "padua": _2, "palermo": _2, "parma": _2, "pavia": _2, "pc": _2, "pd": _2, "pe": _2, "perugia": _2, "pesaro-urbino": _2, "pesarourbino": _2, "pescara": _2, "pg": _2, "pi": _2, "piacenza": _2, "pisa": _2, "pistoia": _2, "pn": _2, "po": _2, "pordenone": _2, "potenza": _2, "pr": _2, "prato": _2, "pt": _2, "pu": _2, "pv": _2, "pz": _2, "ra": _2, "ragusa": _2, "ravenna": _2, "rc": _2, "re": _2, "reggio-calabria": _2, "reggio-emilia": _2, "reggiocalabria": _2, "reggioemilia": _2, "rg": _2, "ri": _2, "rieti": _2, "rimini": _2, "rm": _2, "rn": _2, "ro": _2, "roma": _2, "rome": _2, "rovigo": _2, "sa": _2, "salerno": _2, "sassari": _2, "savona": _2, "si": _2, "siena": _2, "siracusa": _2, "so": _2, "sondrio": _2, "sp": _2, "sr": _2, "ss": _2, "suedtirol": _2, "xn--sdtirol-n2a": _2, "sdtirol": _2, "sv": _2, "ta": _2, "taranto": _2, "te": _2, "tempio-olbia": _2, "tempioolbia": _2, "teramo": _2, "terni": _2, "tn": _2, "to": _2, "torino": _2, "tp": _2, "tr": _2, "trani-andria-barletta": _2, "trani-barletta-andria": _2, "traniandriabarletta": _2, "tranibarlettaandria": _2, "trapani": _2, "trento": _2, "treviso": _2, "trieste": _2, "ts": _2, "turin": _2, "tv": _2, "ud": _2, "udine": _2, "urbino-pesaro": _2, "urbinopesaro": _2, "va": _2, "varese": _2, "vb": _2, "vc": _2, "ve": _2, "venezia": _2, "venice": _2, "verbania": _2, "vercelli": _2, "verona": _2, "vi": _2, "vibo-valentia": _2, "vibovalentia": _2, "vicenza": _2, "viterbo": _2, "vr": _2, "vs": _2, "vt": _2, "vv": _2, "12chars": _3, "blogspot": _3, "ibxos": _3, "iliadboxos": _3, "neen": [0, { "jc": _3 }], "123homepage": _3, "16-b": _3, "32-b": _3, "64-b": _3, "myspreadshop": _3, "syncloud": _3 }], "je": [1, { "co": _2, "net": _2, "org": _2, "of": _3 }], "jm": _15, "jo": [1, { "agri": _2, "ai": _2, "com": _2, "edu": _2, "eng": _2, "fm": _2, "gov": _2, "mil": _2, "net": _2, "org": _2, "per": _2, "phd": _2, "sch": _2, "tv": _2 }], "jobs": _2, "jp": [1, { "ac": _2, "ad": _2, "co": _2, "ed": _2, "go": _2, "gr": _2, "lg": _2, "ne": [1, { "aseinet": _46, "gehirn": _3, "ivory": _3, "mail-box": _3, "mints": _3, "mokuren": _3, "opal": _3, "sakura": _3, "sumomo": _3, "topaz": _3 }], "or": _2, "aichi": [1, { "aisai": _2, "ama": _2, "anjo": _2, "asuke": _2, "chiryu": _2, "chita": _2, "fuso": _2, "gamagori": _2, "handa": _2, "hazu": _2, "hekinan": _2, "higashiura": _2, "ichinomiya": _2, "inazawa": _2, "inuyama": _2, "isshiki": _2, "iwakura": _2, "kanie": _2, "kariya": _2, "kasugai": _2, "kira": _2, "kiyosu": _2, "komaki": _2, "konan": _2, "kota": _2, "mihama": _2, "miyoshi": _2, "nishio": _2, "nisshin": _2, "obu": _2, "oguchi": _2, "oharu": _2, "okazaki": _2, "owariasahi": _2, "seto": _2, "shikatsu": _2, "shinshiro": _2, "shitara": _2, "tahara": _2, "takahama": _2, "tobishima": _2, "toei": _2, "togo": _2, "tokai": _2, "tokoname": _2, "toyoake": _2, "toyohashi": _2, "toyokawa": _2, "toyone": _2, "toyota": _2, "tsushima": _2, "yatomi": _2 }], "akita": [1, { "akita": _2, "daisen": _2, "fujisato": _2, "gojome": _2, "hachirogata": _2, "happou": _2, "higashinaruse": _2, "honjo": _2, "honjyo": _2, "ikawa": _2, "kamikoani": _2, "kamioka": _2, "katagami": _2, "kazuno": _2, "kitaakita": _2, "kosaka": _2, "kyowa": _2, "misato": _2, "mitane": _2, "moriyoshi": _2, "nikaho": _2, "noshiro": _2, "odate": _2, "oga": _2, "ogata": _2, "semboku": _2, "yokote": _2, "yurihonjo": _2 }], "aomori": [1, { "aomori": _2, "gonohe": _2, "hachinohe": _2, "hashikami": _2, "hiranai": _2, "hirosaki": _2, "itayanagi": _2, "kuroishi": _2, "misawa": _2, "mutsu": _2, "nakadomari": _2, "noheji": _2, "oirase": _2, "owani": _2, "rokunohe": _2, "sannohe": _2, "shichinohe": _2, "shingo": _2, "takko": _2, "towada": _2, "tsugaru": _2, "tsuruta": _2 }], "chiba": [1, { "abiko": _2, "asahi": _2, "chonan": _2, "chosei": _2, "choshi": _2, "chuo": _2, "funabashi": _2, "futtsu": _2, "hanamigawa": _2, "ichihara": _2, "ichikawa": _2, "ichinomiya": _2, "inzai": _2, "isumi": _2, "kamagaya": _2, "kamogawa": _2, "kashiwa": _2, "katori": _2, "katsuura": _2, "kimitsu": _2, "kisarazu": _2, "kozaki": _2, "kujukuri": _2, "kyonan": _2, "matsudo": _2, "midori": _2, "mihama": _2, "minamiboso": _2, "mobara": _2, "mutsuzawa": _2, "nagara": _2, "nagareyama": _2, "narashino": _2, "narita": _2, "noda": _2, "oamishirasato": _2, "omigawa": _2, "onjuku": _2, "otaki": _2, "sakae": _2, "sakura": _2, "shimofusa": _2, "shirako": _2, "shiroi": _2, "shisui": _2, "sodegaura": _2, "sosa": _2, "tako": _2, "tateyama": _2, "togane": _2, "tohnosho": _2, "tomisato": _2, "urayasu": _2, "yachimata": _2, "yachiyo": _2, "yokaichiba": _2, "yokoshibahikari": _2, "yotsukaido": _2 }], "ehime": [1, { "ainan": _2, "honai": _2, "ikata": _2, "imabari": _2, "iyo": _2, "kamijima": _2, "kihoku": _2, "kumakogen": _2, "masaki": _2, "matsuno": _2, "matsuyama": _2, "namikata": _2, "niihama": _2, "ozu": _2, "saijo": _2, "seiyo": _2, "shikokuchuo": _2, "tobe": _2, "toon": _2, "uchiko": _2, "uwajima": _2, "yawatahama": _2 }], "fukui": [1, { "echizen": _2, "eiheiji": _2, "fukui": _2, "ikeda": _2, "katsuyama": _2, "mihama": _2, "minamiechizen": _2, "obama": _2, "ohi": _2, "ono": _2, "sabae": _2, "sakai": _2, "takahama": _2, "tsuruga": _2, "wakasa": _2 }], "fukuoka": [1, { "ashiya": _2, "buzen": _2, "chikugo": _2, "chikuho": _2, "chikujo": _2, "chikushino": _2, "chikuzen": _2, "chuo": _2, "dazaifu": _2, "fukuchi": _2, "hakata": _2, "higashi": _2, "hirokawa": _2, "hisayama": _2, "iizuka": _2, "inatsuki": _2, "kaho": _2, "kasuga": _2, "kasuya": _2, "kawara": _2, "keisen": _2, "koga": _2, "kurate": _2, "kurogi": _2, "kurume": _2, "minami": _2, "miyako": _2, "miyama": _2, "miyawaka": _2, "mizumaki": _2, "munakata": _2, "nakagawa": _2, "nakama": _2, "nishi": _2, "nogata": _2, "ogori": _2, "okagaki": _2, "okawa": _2, "oki": _2, "omuta": _2, "onga": _2, "onojo": _2, "oto": _2, "saigawa": _2, "sasaguri": _2, "shingu": _2, "shinyoshitomi": _2, "shonai": _2, "soeda": _2, "sue": _2, "tachiarai": _2, "tagawa": _2, "takata": _2, "toho": _2, "toyotsu": _2, "tsuiki": _2, "ukiha": _2, "umi": _2, "usui": _2, "yamada": _2, "yame": _2, "yanagawa": _2, "yukuhashi": _2 }], "fukushima": [1, { "aizubange": _2, "aizumisato": _2, "aizuwakamatsu": _2, "asakawa": _2, "bandai": _2, "date": _2, "fukushima": _2, "furudono": _2, "futaba": _2, "hanawa": _2, "higashi": _2, "hirata": _2, "hirono": _2, "iitate": _2, "inawashiro": _2, "ishikawa": _2, "iwaki": _2, "izumizaki": _2, "kagamiishi": _2, "kaneyama": _2, "kawamata": _2, "kitakata": _2, "kitashiobara": _2, "koori": _2, "koriyama": _2, "kunimi": _2, "miharu": _2, "mishima": _2, "namie": _2, "nango": _2, "nishiaizu": _2, "nishigo": _2, "okuma": _2, "omotego": _2, "ono": _2, "otama": _2, "samegawa": _2, "shimogo": _2, "shirakawa": _2, "showa": _2, "soma": _2, "sukagawa": _2, "taishin": _2, "tamakawa": _2, "tanagura": _2, "tenei": _2, "yabuki": _2, "yamato": _2, "yamatsuri": _2, "yanaizu": _2, "yugawa": _2 }], "gifu": [1, { "anpachi": _2, "ena": _2, "gifu": _2, "ginan": _2, "godo": _2, "gujo": _2, "hashima": _2, "hichiso": _2, "hida": _2, "higashishirakawa": _2, "ibigawa": _2, "ikeda": _2, "kakamigahara": _2, "kani": _2, "kasahara": _2, "kasamatsu": _2, "kawaue": _2, "kitagata": _2, "mino": _2, "minokamo": _2, "mitake": _2, "mizunami": _2, "motosu": _2, "nakatsugawa": _2, "ogaki": _2, "sakahogi": _2, "seki": _2, "sekigahara": _2, "shirakawa": _2, "tajimi": _2, "takayama": _2, "tarui": _2, "toki": _2, "tomika": _2, "wanouchi": _2, "yamagata": _2, "yaotsu": _2, "yoro": _2 }], "gunma": [1, { "annaka": _2, "chiyoda": _2, "fujioka": _2, "higashiagatsuma": _2, "isesaki": _2, "itakura": _2, "kanna": _2, "kanra": _2, "katashina": _2, "kawaba": _2, "kiryu": _2, "kusatsu": _2, "maebashi": _2, "meiwa": _2, "midori": _2, "minakami": _2, "naganohara": _2, "nakanojo": _2, "nanmoku": _2, "numata": _2, "oizumi": _2, "ora": _2, "ota": _2, "shibukawa": _2, "shimonita": _2, "shinto": _2, "showa": _2, "takasaki": _2, "takayama": _2, "tamamura": _2, "tatebayashi": _2, "tomioka": _2, "tsukiyono": _2, "tsumagoi": _2, "ueno": _2, "yoshioka": _2 }], "hiroshima": [1, { "asaminami": _2, "daiwa": _2, "etajima": _2, "fuchu": _2, "fukuyama": _2, "hatsukaichi": _2, "higashihiroshima": _2, "hongo": _2, "jinsekikogen": _2, "kaita": _2, "kui": _2, "kumano": _2, "kure": _2, "mihara": _2, "miyoshi": _2, "naka": _2, "onomichi": _2, "osakikamijima": _2, "otake": _2, "saka": _2, "sera": _2, "seranishi": _2, "shinichi": _2, "shobara": _2, "takehara": _2 }], "hokkaido": [1, { "abashiri": _2, "abira": _2, "aibetsu": _2, "akabira": _2, "akkeshi": _2, "asahikawa": _2, "ashibetsu": _2, "ashoro": _2, "assabu": _2, "atsuma": _2, "bibai": _2, "biei": _2, "bifuka": _2, "bihoro": _2, "biratori": _2, "chippubetsu": _2, "chitose": _2, "date": _2, "ebetsu": _2, "embetsu": _2, "eniwa": _2, "erimo": _2, "esan": _2, "esashi": _2, "fukagawa": _2, "fukushima": _2, "furano": _2, "furubira": _2, "haboro": _2, "hakodate": _2, "hamatonbetsu": _2, "hidaka": _2, "higashikagura": _2, "higashikawa": _2, "hiroo": _2, "hokuryu": _2, "hokuto": _2, "honbetsu": _2, "horokanai": _2, "horonobe": _2, "ikeda": _2, "imakane": _2, "ishikari": _2, "iwamizawa": _2, "iwanai": _2, "kamifurano": _2, "kamikawa": _2, "kamishihoro": _2, "kamisunagawa": _2, "kamoenai": _2, "kayabe": _2, "kembuchi": _2, "kikonai": _2, "kimobetsu": _2, "kitahiroshima": _2, "kitami": _2, "kiyosato": _2, "koshimizu": _2, "kunneppu": _2, "kuriyama": _2, "kuromatsunai": _2, "kushiro": _2, "kutchan": _2, "kyowa": _2, "mashike": _2, "matsumae": _2, "mikasa": _2, "minamifurano": _2, "mombetsu": _2, "moseushi": _2, "mukawa": _2, "muroran": _2, "naie": _2, "nakagawa": _2, "nakasatsunai": _2, "nakatombetsu": _2, "nanae": _2, "nanporo": _2, "nayoro": _2, "nemuro": _2, "niikappu": _2, "niki": _2, "nishiokoppe": _2, "noboribetsu": _2, "numata": _2, "obihiro": _2, "obira": _2, "oketo": _2, "okoppe": _2, "otaru": _2, "otobe": _2, "otofuke": _2, "otoineppu": _2, "oumu": _2, "ozora": _2, "pippu": _2, "rankoshi": _2, "rebun": _2, "rikubetsu": _2, "rishiri": _2, "rishirifuji": _2, "saroma": _2, "sarufutsu": _2, "shakotan": _2, "shari": _2, "shibecha": _2, "shibetsu": _2, "shikabe": _2, "shikaoi": _2, "shimamaki": _2, "shimizu": _2, "shimokawa": _2, "shinshinotsu": _2, "shintoku": _2, "shiranuka": _2, "shiraoi": _2, "shiriuchi": _2, "sobetsu": _2, "sunagawa": _2, "taiki": _2, "takasu": _2, "takikawa": _2, "takinoue": _2, "teshikaga": _2, "tobetsu": _2, "tohma": _2, "tomakomai": _2, "tomari": _2, "toya": _2, "toyako": _2, "toyotomi": _2, "toyoura": _2, "tsubetsu": _2, "tsukigata": _2, "urakawa": _2, "urausu": _2, "uryu": _2, "utashinai": _2, "wakkanai": _2, "wassamu": _2, "yakumo": _2, "yoichi": _2 }], "hyogo": [1, { "aioi": _2, "akashi": _2, "ako": _2, "amagasaki": _2, "aogaki": _2, "asago": _2, "ashiya": _2, "awaji": _2, "fukusaki": _2, "goshiki": _2, "harima": _2, "himeji": _2, "ichikawa": _2, "inagawa": _2, "itami": _2, "kakogawa": _2, "kamigori": _2, "kamikawa": _2, "kasai": _2, "kasuga": _2, "kawanishi": _2, "miki": _2, "minamiawaji": _2, "nishinomiya": _2, "nishiwaki": _2, "ono": _2, "sanda": _2, "sannan": _2, "sasayama": _2, "sayo": _2, "shingu": _2, "shinonsen": _2, "shiso": _2, "sumoto": _2, "taishi": _2, "taka": _2, "takarazuka": _2, "takasago": _2, "takino": _2, "tamba": _2, "tatsuno": _2, "toyooka": _2, "yabu": _2, "yashiro": _2, "yoka": _2, "yokawa": _2 }], "ibaraki": [1, { "ami": _2, "asahi": _2, "bando": _2, "chikusei": _2, "daigo": _2, "fujishiro": _2, "hitachi": _2, "hitachinaka": _2, "hitachiomiya": _2, "hitachiota": _2, "ibaraki": _2, "ina": _2, "inashiki": _2, "itako": _2, "iwama": _2, "joso": _2, "kamisu": _2, "kasama": _2, "kashima": _2, "kasumigaura": _2, "koga": _2, "miho": _2, "mito": _2, "moriya": _2, "naka": _2, "namegata": _2, "oarai": _2, "ogawa": _2, "omitama": _2, "ryugasaki": _2, "sakai": _2, "sakuragawa": _2, "shimodate": _2, "shimotsuma": _2, "shirosato": _2, "sowa": _2, "suifu": _2, "takahagi": _2, "tamatsukuri": _2, "tokai": _2, "tomobe": _2, "tone": _2, "toride": _2, "tsuchiura": _2, "tsukuba": _2, "uchihara": _2, "ushiku": _2, "yachiyo": _2, "yamagata": _2, "yawara": _2, "yuki": _2 }], "ishikawa": [1, { "anamizu": _2, "hakui": _2, "hakusan": _2, "kaga": _2, "kahoku": _2, "kanazawa": _2, "kawakita": _2, "komatsu": _2, "nakanoto": _2, "nanao": _2, "nomi": _2, "nonoichi": _2, "noto": _2, "shika": _2, "suzu": _2, "tsubata": _2, "tsurugi": _2, "uchinada": _2, "wajima": _2 }], "iwate": [1, { "fudai": _2, "fujisawa": _2, "hanamaki": _2, "hiraizumi": _2, "hirono": _2, "ichinohe": _2, "ichinoseki": _2, "iwaizumi": _2, "iwate": _2, "joboji": _2, "kamaishi": _2, "kanegasaki": _2, "karumai": _2, "kawai": _2, "kitakami": _2, "kuji": _2, "kunohe": _2, "kuzumaki": _2, "miyako": _2, "mizusawa": _2, "morioka": _2, "ninohe": _2, "noda": _2, "ofunato": _2, "oshu": _2, "otsuchi": _2, "rikuzentakata": _2, "shiwa": _2, "shizukuishi": _2, "sumita": _2, "tanohata": _2, "tono": _2, "yahaba": _2, "yamada": _2 }], "kagawa": [1, { "ayagawa": _2, "higashikagawa": _2, "kanonji": _2, "kotohira": _2, "manno": _2, "marugame": _2, "mitoyo": _2, "naoshima": _2, "sanuki": _2, "tadotsu": _2, "takamatsu": _2, "tonosho": _2, "uchinomi": _2, "utazu": _2, "zentsuji": _2 }], "kagoshima": [1, { "akune": _2, "amami": _2, "hioki": _2, "isa": _2, "isen": _2, "izumi": _2, "kagoshima": _2, "kanoya": _2, "kawanabe": _2, "kinko": _2, "kouyama": _2, "makurazaki": _2, "matsumoto": _2, "minamitane": _2, "nakatane": _2, "nishinoomote": _2, "satsumasendai": _2, "soo": _2, "tarumizu": _2, "yusui": _2 }], "kanagawa": [1, { "aikawa": _2, "atsugi": _2, "ayase": _2, "chigasaki": _2, "ebina": _2, "fujisawa": _2, "hadano": _2, "hakone": _2, "hiratsuka": _2, "isehara": _2, "kaisei": _2, "kamakura": _2, "kiyokawa": _2, "matsuda": _2, "minamiashigara": _2, "miura": _2, "nakai": _2, "ninomiya": _2, "odawara": _2, "oi": _2, "oiso": _2, "sagamihara": _2, "samukawa": _2, "tsukui": _2, "yamakita": _2, "yamato": _2, "yokosuka": _2, "yugawara": _2, "zama": _2, "zushi": _2 }], "kochi": [1, { "aki": _2, "geisei": _2, "hidaka": _2, "higashitsuno": _2, "ino": _2, "kagami": _2, "kami": _2, "kitagawa": _2, "kochi": _2, "mihara": _2, "motoyama": _2, "muroto": _2, "nahari": _2, "nakamura": _2, "nankoku": _2, "nishitosa": _2, "niyodogawa": _2, "ochi": _2, "okawa": _2, "otoyo": _2, "otsuki": _2, "sakawa": _2, "sukumo": _2, "susaki": _2, "tosa": _2, "tosashimizu": _2, "toyo": _2, "tsuno": _2, "umaji": _2, "yasuda": _2, "yusuhara": _2 }], "kumamoto": [1, { "amakusa": _2, "arao": _2, "aso": _2, "choyo": _2, "gyokuto": _2, "kamiamakusa": _2, "kikuchi": _2, "kumamoto": _2, "mashiki": _2, "mifune": _2, "minamata": _2, "minamioguni": _2, "nagasu": _2, "nishihara": _2, "oguni": _2, "ozu": _2, "sumoto": _2, "takamori": _2, "uki": _2, "uto": _2, "yamaga": _2, "yamato": _2, "yatsushiro": _2 }], "kyoto": [1, { "ayabe": _2, "fukuchiyama": _2, "higashiyama": _2, "ide": _2, "ine": _2, "joyo": _2, "kameoka": _2, "kamo": _2, "kita": _2, "kizu": _2, "kumiyama": _2, "kyotamba": _2, "kyotanabe": _2, "kyotango": _2, "maizuru": _2, "minami": _2, "minamiyamashiro": _2, "miyazu": _2, "muko": _2, "nagaokakyo": _2, "nakagyo": _2, "nantan": _2, "oyamazaki": _2, "sakyo": _2, "seika": _2, "tanabe": _2, "uji": _2, "ujitawara": _2, "wazuka": _2, "yamashina": _2, "yawata": _2 }], "mie": [1, { "asahi": _2, "inabe": _2, "ise": _2, "kameyama": _2, "kawagoe": _2, "kiho": _2, "kisosaki": _2, "kiwa": _2, "komono": _2, "kumano": _2, "kuwana": _2, "matsusaka": _2, "meiwa": _2, "mihama": _2, "minamiise": _2, "misugi": _2, "miyama": _2, "nabari": _2, "shima": _2, "suzuka": _2, "tado": _2, "taiki": _2, "taki": _2, "tamaki": _2, "toba": _2, "tsu": _2, "udono": _2, "ureshino": _2, "watarai": _2, "yokkaichi": _2 }], "miyagi": [1, { "furukawa": _2, "higashimatsushima": _2, "ishinomaki": _2, "iwanuma": _2, "kakuda": _2, "kami": _2, "kawasaki": _2, "marumori": _2, "matsushima": _2, "minamisanriku": _2, "misato": _2, "murata": _2, "natori": _2, "ogawara": _2, "ohira": _2, "onagawa": _2, "osaki": _2, "rifu": _2, "semine": _2, "shibata": _2, "shichikashuku": _2, "shikama": _2, "shiogama": _2, "shiroishi": _2, "tagajo": _2, "taiwa": _2, "tome": _2, "tomiya": _2, "wakuya": _2, "watari": _2, "yamamoto": _2, "zao": _2 }], "miyazaki": [1, { "aya": _2, "ebino": _2, "gokase": _2, "hyuga": _2, "kadogawa": _2, "kawaminami": _2, "kijo": _2, "kitagawa": _2, "kitakata": _2, "kitaura": _2, "kobayashi": _2, "kunitomi": _2, "kushima": _2, "mimata": _2, "miyakonojo": _2, "miyazaki": _2, "morotsuka": _2, "nichinan": _2, "nishimera": _2, "nobeoka": _2, "saito": _2, "shiiba": _2, "shintomi": _2, "takaharu": _2, "takanabe": _2, "takazaki": _2, "tsuno": _2 }], "nagano": [1, { "achi": _2, "agematsu": _2, "anan": _2, "aoki": _2, "asahi": _2, "azumino": _2, "chikuhoku": _2, "chikuma": _2, "chino": _2, "fujimi": _2, "hakuba": _2, "hara": _2, "hiraya": _2, "iida": _2, "iijima": _2, "iiyama": _2, "iizuna": _2, "ikeda": _2, "ikusaka": _2, "ina": _2, "karuizawa": _2, "kawakami": _2, "kiso": _2, "kisofukushima": _2, "kitaaiki": _2, "komagane": _2, "komoro": _2, "matsukawa": _2, "matsumoto": _2, "miasa": _2, "minamiaiki": _2, "minamimaki": _2, "minamiminowa": _2, "minowa": _2, "miyada": _2, "miyota": _2, "mochizuki": _2, "nagano": _2, "nagawa": _2, "nagiso": _2, "nakagawa": _2, "nakano": _2, "nozawaonsen": _2, "obuse": _2, "ogawa": _2, "okaya": _2, "omachi": _2, "omi": _2, "ookuwa": _2, "ooshika": _2, "otaki": _2, "otari": _2, "sakae": _2, "sakaki": _2, "saku": _2, "sakuho": _2, "shimosuwa": _2, "shinanomachi": _2, "shiojiri": _2, "suwa": _2, "suzaka": _2, "takagi": _2, "takamori": _2, "takayama": _2, "tateshina": _2, "tatsuno": _2, "togakushi": _2, "togura": _2, "tomi": _2, "ueda": _2, "wada": _2, "yamagata": _2, "yamanouchi": _2, "yasaka": _2, "yasuoka": _2 }], "nagasaki": [1, { "chijiwa": _2, "futsu": _2, "goto": _2, "hasami": _2, "hirado": _2, "iki": _2, "isahaya": _2, "kawatana": _2, "kuchinotsu": _2, "matsuura": _2, "nagasaki": _2, "obama": _2, "omura": _2, "oseto": _2, "saikai": _2, "sasebo": _2, "seihi": _2, "shimabara": _2, "shinkamigoto": _2, "togitsu": _2, "tsushima": _2, "unzen": _2 }], "nara": [1, { "ando": _2, "gose": _2, "heguri": _2, "higashiyoshino": _2, "ikaruga": _2, "ikoma": _2, "kamikitayama": _2, "kanmaki": _2, "kashiba": _2, "kashihara": _2, "katsuragi": _2, "kawai": _2, "kawakami": _2, "kawanishi": _2, "koryo": _2, "kurotaki": _2, "mitsue": _2, "miyake": _2, "nara": _2, "nosegawa": _2, "oji": _2, "ouda": _2, "oyodo": _2, "sakurai": _2, "sango": _2, "shimoichi": _2, "shimokitayama": _2, "shinjo": _2, "soni": _2, "takatori": _2, "tawaramoto": _2, "tenkawa": _2, "tenri": _2, "uda": _2, "yamatokoriyama": _2, "yamatotakada": _2, "yamazoe": _2, "yoshino": _2 }], "niigata": [1, { "aga": _2, "agano": _2, "gosen": _2, "itoigawa": _2, "izumozaki": _2, "joetsu": _2, "kamo": _2, "kariwa": _2, "kashiwazaki": _2, "minamiuonuma": _2, "mitsuke": _2, "muika": _2, "murakami": _2, "myoko": _2, "nagaoka": _2, "niigata": _2, "ojiya": _2, "omi": _2, "sado": _2, "sanjo": _2, "seiro": _2, "seirou": _2, "sekikawa": _2, "shibata": _2, "tagami": _2, "tainai": _2, "tochio": _2, "tokamachi": _2, "tsubame": _2, "tsunan": _2, "uonuma": _2, "yahiko": _2, "yoita": _2, "yuzawa": _2 }], "oita": [1, { "beppu": _2, "bungoono": _2, "bungotakada": _2, "hasama": _2, "hiji": _2, "himeshima": _2, "hita": _2, "kamitsue": _2, "kokonoe": _2, "kuju": _2, "kunisaki": _2, "kusu": _2, "oita": _2, "saiki": _2, "taketa": _2, "tsukumi": _2, "usa": _2, "usuki": _2, "yufu": _2 }], "okayama": [1, { "akaiwa": _2, "asakuchi": _2, "bizen": _2, "hayashima": _2, "ibara": _2, "kagamino": _2, "kasaoka": _2, "kibichuo": _2, "kumenan": _2, "kurashiki": _2, "maniwa": _2, "misaki": _2, "nagi": _2, "niimi": _2, "nishiawakura": _2, "okayama": _2, "satosho": _2, "setouchi": _2, "shinjo": _2, "shoo": _2, "soja": _2, "takahashi": _2, "tamano": _2, "tsuyama": _2, "wake": _2, "yakage": _2 }], "okinawa": [1, { "aguni": _2, "ginowan": _2, "ginoza": _2, "gushikami": _2, "haebaru": _2, "higashi": _2, "hirara": _2, "iheya": _2, "ishigaki": _2, "ishikawa": _2, "itoman": _2, "izena": _2, "kadena": _2, "kin": _2, "kitadaito": _2, "kitanakagusuku": _2, "kumejima": _2, "kunigami": _2, "minamidaito": _2, "motobu": _2, "nago": _2, "naha": _2, "nakagusuku": _2, "nakijin": _2, "nanjo": _2, "nishihara": _2, "ogimi": _2, "okinawa": _2, "onna": _2, "shimoji": _2, "taketomi": _2, "tarama": _2, "tokashiki": _2, "tomigusuku": _2, "tonaki": _2, "urasoe": _2, "uruma": _2, "yaese": _2, "yomitan": _2, "yonabaru": _2, "yonaguni": _2, "zamami": _2 }], "osaka": [1, { "abeno": _2, "chihayaakasaka": _2, "chuo": _2, "daito": _2, "fujiidera": _2, "habikino": _2, "hannan": _2, "higashiosaka": _2, "higashisumiyoshi": _2, "higashiyodogawa": _2, "hirakata": _2, "ibaraki": _2, "ikeda": _2, "izumi": _2, "izumiotsu": _2, "izumisano": _2, "kadoma": _2, "kaizuka": _2, "kanan": _2, "kashiwara": _2, "katano": _2, "kawachinagano": _2, "kishiwada": _2, "kita": _2, "kumatori": _2, "matsubara": _2, "minato": _2, "minoh": _2, "misaki": _2, "moriguchi": _2, "neyagawa": _2, "nishi": _2, "nose": _2, "osakasayama": _2, "sakai": _2, "sayama": _2, "sennan": _2, "settsu": _2, "shijonawate": _2, "shimamoto": _2, "suita": _2, "tadaoka": _2, "taishi": _2, "tajiri": _2, "takaishi": _2, "takatsuki": _2, "tondabayashi": _2, "toyonaka": _2, "toyono": _2, "yao": _2 }], "saga": [1, { "ariake": _2, "arita": _2, "fukudomi": _2, "genkai": _2, "hamatama": _2, "hizen": _2, "imari": _2, "kamimine": _2, "kanzaki": _2, "karatsu": _2, "kashima": _2, "kitagata": _2, "kitahata": _2, "kiyama": _2, "kouhoku": _2, "kyuragi": _2, "nishiarita": _2, "ogi": _2, "omachi": _2, "ouchi": _2, "saga": _2, "shiroishi": _2, "taku": _2, "tara": _2, "tosu": _2, "yoshinogari": _2 }], "saitama": [1, { "arakawa": _2, "asaka": _2, "chichibu": _2, "fujimi": _2, "fujimino": _2, "fukaya": _2, "hanno": _2, "hanyu": _2, "hasuda": _2, "hatogaya": _2, "hatoyama": _2, "hidaka": _2, "higashichichibu": _2, "higashimatsuyama": _2, "honjo": _2, "ina": _2, "iruma": _2, "iwatsuki": _2, "kamiizumi": _2, "kamikawa": _2, "kamisato": _2, "kasukabe": _2, "kawagoe": _2, "kawaguchi": _2, "kawajima": _2, "kazo": _2, "kitamoto": _2, "koshigaya": _2, "kounosu": _2, "kuki": _2, "kumagaya": _2, "matsubushi": _2, "minano": _2, "misato": _2, "miyashiro": _2, "miyoshi": _2, "moroyama": _2, "nagatoro": _2, "namegawa": _2, "niiza": _2, "ogano": _2, "ogawa": _2, "ogose": _2, "okegawa": _2, "omiya": _2, "otaki": _2, "ranzan": _2, "ryokami": _2, "saitama": _2, "sakado": _2, "satte": _2, "sayama": _2, "shiki": _2, "shiraoka": _2, "soka": _2, "sugito": _2, "toda": _2, "tokigawa": _2, "tokorozawa": _2, "tsurugashima": _2, "urawa": _2, "warabi": _2, "yashio": _2, "yokoze": _2, "yono": _2, "yorii": _2, "yoshida": _2, "yoshikawa": _2, "yoshimi": _2 }], "shiga": [1, { "aisho": _2, "gamo": _2, "higashiomi": _2, "hikone": _2, "koka": _2, "konan": _2, "kosei": _2, "koto": _2, "kusatsu": _2, "maibara": _2, "moriyama": _2, "nagahama": _2, "nishiazai": _2, "notogawa": _2, "omihachiman": _2, "otsu": _2, "ritto": _2, "ryuoh": _2, "takashima": _2, "takatsuki": _2, "torahime": _2, "toyosato": _2, "yasu": _2 }], "shimane": [1, { "akagi": _2, "ama": _2, "gotsu": _2, "hamada": _2, "higashiizumo": _2, "hikawa": _2, "hikimi": _2, "izumo": _2, "kakinoki": _2, "masuda": _2, "matsue": _2, "misato": _2, "nishinoshima": _2, "ohda": _2, "okinoshima": _2, "okuizumo": _2, "shimane": _2, "tamayu": _2, "tsuwano": _2, "unnan": _2, "yakumo": _2, "yasugi": _2, "yatsuka": _2 }], "shizuoka": [1, { "arai": _2, "atami": _2, "fuji": _2, "fujieda": _2, "fujikawa": _2, "fujinomiya": _2, "fukuroi": _2, "gotemba": _2, "haibara": _2, "hamamatsu": _2, "higashiizu": _2, "ito": _2, "iwata": _2, "izu": _2, "izunokuni": _2, "kakegawa": _2, "kannami": _2, "kawanehon": _2, "kawazu": _2, "kikugawa": _2, "kosai": _2, "makinohara": _2, "matsuzaki": _2, "minamiizu": _2, "mishima": _2, "morimachi": _2, "nishiizu": _2, "numazu": _2, "omaezaki": _2, "shimada": _2, "shimizu": _2, "shimoda": _2, "shizuoka": _2, "susono": _2, "yaizu": _2, "yoshida": _2 }], "tochigi": [1, { "ashikaga": _2, "bato": _2, "haga": _2, "ichikai": _2, "iwafune": _2, "kaminokawa": _2, "kanuma": _2, "karasuyama": _2, "kuroiso": _2, "mashiko": _2, "mibu": _2, "moka": _2, "motegi": _2, "nasu": _2, "nasushiobara": _2, "nikko": _2, "nishikata": _2, "nogi": _2, "ohira": _2, "ohtawara": _2, "oyama": _2, "sakura": _2, "sano": _2, "shimotsuke": _2, "shioya": _2, "takanezawa": _2, "tochigi": _2, "tsuga": _2, "ujiie": _2, "utsunomiya": _2, "yaita": _2 }], "tokushima": [1, { "aizumi": _2, "anan": _2, "ichiba": _2, "itano": _2, "kainan": _2, "komatsushima": _2, "matsushige": _2, "mima": _2, "minami": _2, "miyoshi": _2, "mugi": _2, "nakagawa": _2, "naruto": _2, "sanagochi": _2, "shishikui": _2, "tokushima": _2, "wajiki": _2 }], "tokyo": [1, { "adachi": _2, "akiruno": _2, "akishima": _2, "aogashima": _2, "arakawa": _2, "bunkyo": _2, "chiyoda": _2, "chofu": _2, "chuo": _2, "edogawa": _2, "fuchu": _2, "fussa": _2, "hachijo": _2, "hachioji": _2, "hamura": _2, "higashikurume": _2, "higashimurayama": _2, "higashiyamato": _2, "hino": _2, "hinode": _2, "hinohara": _2, "inagi": _2, "itabashi": _2, "katsushika": _2, "kita": _2, "kiyose": _2, "kodaira": _2, "koganei": _2, "kokubunji": _2, "komae": _2, "koto": _2, "kouzushima": _2, "kunitachi": _2, "machida": _2, "meguro": _2, "minato": _2, "mitaka": _2, "mizuho": _2, "musashimurayama": _2, "musashino": _2, "nakano": _2, "nerima": _2, "ogasawara": _2, "okutama": _2, "ome": _2, "oshima": _2, "ota": _2, "setagaya": _2, "shibuya": _2, "shinagawa": _2, "shinjuku": _2, "suginami": _2, "sumida": _2, "tachikawa": _2, "taito": _2, "tama": _2, "toshima": _2 }], "tottori": [1, { "chizu": _2, "hino": _2, "kawahara": _2, "koge": _2, "kotoura": _2, "misasa": _2, "nanbu": _2, "nichinan": _2, "sakaiminato": _2, "tottori": _2, "wakasa": _2, "yazu": _2, "yonago": _2 }], "toyama": [1, { "asahi": _2, "fuchu": _2, "fukumitsu": _2, "funahashi": _2, "himi": _2, "imizu": _2, "inami": _2, "johana": _2, "kamiichi": _2, "kurobe": _2, "nakaniikawa": _2, "namerikawa": _2, "nanto": _2, "nyuzen": _2, "oyabe": _2, "taira": _2, "takaoka": _2, "tateyama": _2, "toga": _2, "tonami": _2, "toyama": _2, "unazuki": _2, "uozu": _2, "yamada": _2 }], "wakayama": [1, { "arida": _2, "aridagawa": _2, "gobo": _2, "hashimoto": _2, "hidaka": _2, "hirogawa": _2, "inami": _2, "iwade": _2, "kainan": _2, "kamitonda": _2, "katsuragi": _2, "kimino": _2, "kinokawa": _2, "kitayama": _2, "koya": _2, "koza": _2, "kozagawa": _2, "kudoyama": _2, "kushimoto": _2, "mihama": _2, "misato": _2, "nachikatsuura": _2, "shingu": _2, "shirahama": _2, "taiji": _2, "tanabe": _2, "wakayama": _2, "yuasa": _2, "yura": _2 }], "yamagata": [1, { "asahi": _2, "funagata": _2, "higashine": _2, "iide": _2, "kahoku": _2, "kaminoyama": _2, "kaneyama": _2, "kawanishi": _2, "mamurogawa": _2, "mikawa": _2, "murayama": _2, "nagai": _2, "nakayama": _2, "nanyo": _2, "nishikawa": _2, "obanazawa": _2, "oe": _2, "oguni": _2, "ohkura": _2, "oishida": _2, "sagae": _2, "sakata": _2, "sakegawa": _2, "shinjo": _2, "shirataka": _2, "shonai": _2, "takahata": _2, "tendo": _2, "tozawa": _2, "tsuruoka": _2, "yamagata": _2, "yamanobe": _2, "yonezawa": _2, "yuza": _2 }], "yamaguchi": [1, { "abu": _2, "hagi": _2, "hikari": _2, "hofu": _2, "iwakuni": _2, "kudamatsu": _2, "mitou": _2, "nagato": _2, "oshima": _2, "shimonoseki": _2, "shunan": _2, "tabuse": _2, "tokuyama": _2, "toyota": _2, "ube": _2, "yuu": _2 }], "yamanashi": [1, { "chuo": _2, "doshi": _2, "fuefuki": _2, "fujikawa": _2, "fujikawaguchiko": _2, "fujiyoshida": _2, "hayakawa": _2, "hokuto": _2, "ichikawamisato": _2, "kai": _2, "kofu": _2, "koshu": _2, "kosuge": _2, "minami-alps": _2, "minobu": _2, "nakamichi": _2, "nanbu": _2, "narusawa": _2, "nirasaki": _2, "nishikatsura": _2, "oshino": _2, "otsuki": _2, "showa": _2, "tabayama": _2, "tsuru": _2, "uenohara": _2, "yamanakako": _2, "yamanashi": _2 }], "xn--4pvxs": _2, "": _2, "xn--vgu402c": _2, "": _2, "xn--c3s14m": _2, "": _2, "xn--f6qx53a": _2, "": _2, "xn--8pvr4u": _2, "": _2, "xn--uist22h": _2, "": _2, "xn--djrs72d6uy": _2, "": _2, "xn--mkru45i": _2, "": _2, "xn--0trq7p7nn": _2, "": _2, "xn--8ltr62k": _2, "": _2, "xn--2m4a15e": _2, "": _2, "xn--efvn9s": _2, "": _2, "xn--32vp30h": _2, "": _2, "xn--4it797k": _2, "": _2, "xn--1lqs71d": _2, "": _2, "xn--5rtp49c": _2, "": _2, "xn--5js045d": _2, "": _2, "xn--ehqz56n": _2, "": _2, "xn--1lqs03n": _2, "": _2, "xn--qqqt11m": _2, "": _2, "xn--kbrq7o": _2, "": _2, "xn--pssu33l": _2, "": _2, "xn--ntsq17g": _2, "": _2, "xn--uisz3g": _2, "": _2, "xn--6btw5a": _2, "": _2, "xn--1ctwo": _2, "": _2, "xn--6orx2r": _2, "": _2, "xn--rht61e": _2, "": _2, "xn--rht27z": _2, "": _2, "xn--djty4k": _2, "": _2, "xn--nit225k": _2, "": _2, "xn--rht3d": _2, "": _2, "xn--klty5x": _2, "": _2, "xn--kltx9a": _2, "": _2, "xn--kltp7d": _2, "": _2, "xn--uuwu58a": _2, "": _2, "xn--zbx025d": _2, "": _2, "xn--ntso0iqx3a": _2, "": _2, "xn--elqq16h": _2, "": _2, "xn--4it168d": _2, "": _2, "xn--klt787d": _2, "": _2, "xn--rny31h": _2, "": _2, "xn--7t0a264c": _2, "": _2, "xn--5rtq34k": _2, "": _2, "xn--k7yn95e": _2, "": _2, "xn--tor131o": _2, "": _2, "xn--d5qv7z876c": _2, "": _2, "kawasaki": _15, "kitakyushu": _15, "kobe": _15, "nagoya": _15, "sapporo": _15, "sendai": _15, "yokohama": _15, "buyshop": _3, "fashionstore": _3, "handcrafted": _3, "kawaiishop": _3, "supersale": _3, "theshop": _3, "0am": _3, "0g0": _3, "0j0": _3, "0t0": _3, "mydns": _3, "pgw": _3, "wjg": _3, "usercontent": _3, "angry": _3, "babyblue": _3, "babymilk": _3, "backdrop": _3, "bambina": _3, "bitter": _3, "blush": _3, "boo": _3, "boy": _3, "boyfriend": _3, "but": _3, "candypop": _3, "capoo": _3, "catfood": _3, "cheap": _3, "chicappa": _3, "chillout": _3, "chips": _3, "chowder": _3, "chu": _3, "ciao": _3, "cocotte": _3, "coolblog": _3, "cranky": _3, "cutegirl": _3, "daa": _3, "deca": _3, "deci": _3, "digick": _3, "egoism": _3, "fakefur": _3, "fem": _3, "flier": _3, "floppy": _3, "fool": _3, "frenchkiss": _3, "girlfriend": _3, "girly": _3, "gloomy": _3, "gonna": _3, "greater": _3, "hacca": _3, "heavy": _3, "her": _3, "hiho": _3, "hippy": _3, "holy": _3, "hungry": _3, "icurus": _3, "itigo": _3, "jellybean": _3, "kikirara": _3, "kill": _3, "kilo": _3, "kuron": _3, "littlestar": _3, "lolipopmc": _3, "lolitapunk": _3, "lomo": _3, "lovepop": _3, "lovesick": _3, "main": _3, "mods": _3, "mond": _3, "mongolian": _3, "moo": _3, "namaste": _3, "nikita": _3, "nobushi": _3, "noor": _3, "oops": _3, "parallel": _3, "parasite": _3, "pecori": _3, "peewee": _3, "penne": _3, "pepper": _3, "perma": _3, "pigboat": _3, "pinoko": _3, "punyu": _3, "pupu": _3, "pussycat": _3, "pya": _3, "raindrop": _3, "readymade": _3, "sadist": _3, "schoolbus": _3, "secret": _3, "staba": _3, "stripper": _3, "sub": _3, "sunnyday": _3, "thick": _3, "tonkotsu": _3, "under": _3, "upper": _3, "velvet": _3, "verse": _3, "versus": _3, "vivian": _3, "watson": _3, "weblike": _3, "whitesnow": _3, "zombie": _3, "blogspot": _3, "hateblo": _3, "hatenablog": _3, "hatenadiary": _3, "2-d": _3, "bona": _3, "crap": _3, "daynight": _3, "eek": _3, "flop": _3, "halfmoon": _3, "jeez": _3, "matrix": _3, "mimoza": _3, "netgamers": _3, "nyanta": _3, "o0o0": _3, "rdy": _3, "rgr": _3, "rulez": _3, "sakurastorage": [0, { "isk01": _51, "isk02": _51 }], "saloon": _3, "sblo": _3, "skr": _3, "tank": _3, "uh-oh": _3, "undo": _3, "webaccel": [0, { "rs": _3, "user": _3 }], "websozai": _3, "xii": _3 }], "ke": [1, { "ac": _2, "co": _8, "go": _2, "info": _2, "me": _2, "mobi": _2, "ne": _2, "or": _2, "sc": _2 }], "kg": [1, { "org": _2, "net": _2, "com": _2, "edu": _2, "gov": _2, "mil": _2, "us": _3 }], "kh": _15, "ki": _52, "km": [1, { "org": _2, "nom": _2, "gov": _2, "prd": _2, "tm": _2, "edu": _2, "mil": _2, "ass": _2, "com": _2, "coop": _2, "asso": _2, "presse": _2, "medecin": _2, "notaires": _2, "pharmaciens": _2, "veterinaire": _2, "gouv": _2 }], "kn": [1, { "net": _2, "org": _2, "edu": _2, "gov": _2 }], "kp": [1, { "com": _2, "edu": _2, "gov": _2, "org": _2, "rep": _2, "tra": _2 }], "kr": [1, { "ac": _2, "co": _2, "es": _2, "go": _2, "hs": _2, "kg": _2, "mil": _2, "ms": _2, "ne": _2, "or": _2, "pe": _2, "re": _2, "sc": _2, "busan": _2, "chungbuk": _2, "chungnam": _2, "daegu": _2, "daejeon": _2, "gangwon": _2, "gwangju": _2, "gyeongbuk": _2, "gyeonggi": _2, "gyeongnam": _2, "incheon": _2, "jeju": _2, "jeonbuk": _2, "jeonnam": _2, "seoul": _2, "ulsan": _2, "blogspot": _3 }], "kw": [1, { "com": _2, "edu": _2, "emb": _2, "gov": _2, "ind": _2, "net": _2, "org": _2 }], "ky": _42, "kz": [1, { "org": _2, "edu": _2, "net": _2, "gov": _2, "mil": _2, "com": _2, "jcloud": _3 }], "la": [1, { "int": _2, "net": _2, "info": _2, "edu": _2, "gov": _2, "per": _2, "com": _2, "org": _2, "bnr": _3 }], "lb": _4, "lc": [1, { "com": _2, "net": _2, "co": _2, "org": _2, "edu": _2, "gov": _2, "oy": _3 }], "li": [1, { "blogspot": _3, "caa": _3 }], "lk": [1, { "gov": _2, "sch": _2, "net": _2, "int": _2, "com": _2, "org": _2, "edu": _2, "ngo": _2, "soc": _2, "web": _2, "ltd": _2, "assn": _2, "grp": _2, "hotel": _2, "ac": _2 }], "lr": _4, "ls": [1, { "ac": _2, "biz": _2, "co": _2, "edu": _2, "gov": _2, "info": _2, "net": _2, "org": _2, "sc": _2 }], "lt": [1, { "gov": _2, "blogspot": _3 }], "lu": [1, { "blogspot": _3, "123website": _3 }], "lv": [1, { "com": _2, "edu": _2, "gov": _2, "org": _2, "mil": _2, "id": _2, "net": _2, "asn": _2, "conf": _2 }], "ly": [1, { "com": _2, "net": _2, "gov": _2, "plc": _2, "edu": _2, "sch": _2, "med": _2, "org": _2, "id": _2 }], "ma": [1, { "co": _2, "net": _2, "gov": _2, "org": _2, "ac": _2, "press": _2 }], "mc": [1, { "tm": _2, "asso": _2 }], "md": [1, { "blogspot": _3, "ir": _3 }], "me": [1, { "co": _2, "net": _2, "org": _2, "edu": _2, "ac": _2, "gov": _2, "its": _2, "priv": _2, "c66": _3, "craft": _3, "edgestack": _3, "filegear": _3, "glitch": _3, "filegear-sg": _3, "lohmus": _3, "barsy": _3, "mcdir": _3, "mcpe": _3, "brasilia": _3, "ddns": _3, "dnsfor": _3, "hopto": _3, "loginto": _3, "noip": _3, "webhop": _3, "soundcast": _3, "tcp4": _3, "vp4": _3, "diskstation": _3, "dscloud": _3, "i234": _3, "myds": _3, "synology": _3, "transip": _41, "yombo": _3, "nohost": _3 }], "mg": [1, { "co": _2, "com": _2, "edu": _2, "gov": _2, "mil": _2, "nom": _2, "org": _2, "prd": _2 }], "mh": _2, "mil": _2, "mk": [1, { "com": _2, "org": _2, "net": _2, "edu": _2, "gov": _2, "inf": _2, "name": _2, "blogspot": _3 }], "ml": [1, { "com": _2, "edu": _2, "gouv": _2, "gov": _2, "net": _2, "org": _2, "presse": _2 }], "mm": _15, "mn": [1, { "gov": _2, "edu": _2, "org": _2, "nyc": _3 }], "mo": _4, "mobi": [1, { "barsy": _3, "dscloud": _3 }], "mp": [1, { "ju": _3 }], "mq": _2, "mr": _9, "ms": [1, { "com": _2, "edu": _2, "gov": _2, "net": _2, "org": _2, "lab": _3, "minisite": _3 }], "mt": [1, { "com": _8, "edu": _2, "net": _2, "org": _2 }], "mu": [1, { "com": _2, "net": _2, "org": _2, "gov": _2, "ac": _2, "co": _2, "or": _2 }], "museum": _2, "mv": [1, { "aero": _2, "biz": _2, "com": _2, "coop": _2, "edu": _2, "gov": _2, "info": _2, "int": _2, "mil": _2, "museum": _2, "name": _2, "net": _2, "org": _2, "pro": _2 }], "mw": [1, { "ac": _2, "biz": _2, "co": _2, "com": _2, "coop": _2, "edu": _2, "gov": _2, "int": _2, "net": _2, "org": _2 }], "mx": [1, { "com": _2, "org": _2, "gob": _2, "edu": _2, "net": _2, "blogspot": _3 }], "my": [1, { "biz": _2, "com": _2, "edu": _2, "gov": _2, "mil": _2, "name": _2, "net": _2, "org": _2, "blogspot": _3 }], "mz": [1, { "ac": _2, "adv": _2, "co": _2, "edu": _2, "gov": _2, "mil": _2, "net": _2, "org": _2 }], "na": [1, { "alt": _2, "co": _2, "com": _2, "gov": _2, "net": _2, "org": _2 }], "name": [1, { "her": _54, "his": _54 }], "nc": [1, { "asso": _2, "nom": _2 }], "ne": _2, "net": [1, { "adobeaemcloud": _3, "adobeio-static": _3, "adobeioruntime": _3, "akadns": _3, "akamai": _3, "akamai-staging": _3, "akamaiedge": _3, "akamaiedge-staging": _3, "akamaihd": _3, "akamaihd-staging": _3, "akamaiorigin": _3, "akamaiorigin-staging": _3, "akamaized": _3, "akamaized-staging": _3, "edgekey": _3, "edgekey-staging": _3, "edgesuite": _3, "edgesuite-staging": _3, "alwaysdata": _3, "myamaze": _3, "cloudfront": _3, "appudo": _3, "atlassian-dev": [0, { "prod": _55 }], "myfritz": _3, "onavstack": _3, "shopselect": _3, "blackbaudcdn": _3, "boomla": _3, "bplaced": _3, "square7": _3, "cdn77": [0, { "r": _3 }], "cdn77-ssl": _3, "gb": _3, "hu": _3, "jp": _3, "se": _3, "uk": _3, "clickrising": _3, "ddns-ip": _3, "dns-cloud": _3, "dns-dynamic": _3, "cloudaccess": _3, "cloudflare": [2, { "cdn": _3 }], "cloudflareanycast": _55, "cloudflarecn": _55, "cloudflareglobal": _55, "ctfcloud": _3, "feste-ip": _3, "knx-server": _3, "static-access": _3, "cryptonomic": _5, "dattolocal": _3, "mydatto": _3, "debian": _3, "definima": _3, "at-band-camp": _3, "blogdns": _3, "broke-it": _3, "buyshouses": _3, "dnsalias": _3, "dnsdojo": _3, "does-it": _3, "dontexist": _3, "dynalias": _3, "dynathome": _3, "endofinternet": _3, "from-az": _3, "from-co": _3, "from-la": _3, "from-ny": _3, "gets-it": _3, "ham-radio-op": _3, "homeftp": _3, "homeip": _3, "homelinux": _3, "homeunix": _3, "in-the-band": _3, "is-a-chef": _3, "is-a-geek": _3, "isa-geek": _3, "kicks-ass": _3, "office-on-the": _3, "podzone": _3, "scrapper-site": _3, "selfip": _3, "sells-it": _3, "servebbs": _3, "serveftp": _3, "thruhere": _3, "webhop": _3, "casacam": _3, "dynu": _3, "dynv6": _3, "twmail": _3, "ru": _3, "channelsdvr": [2, { "u": _3 }], "fastly": [0, { "freetls": _3, "map": _3, "prod": [0, { "a": _3, "global": _3 }], "ssl": [0, { "a": _3, "b": _3, "global": _3 }] }], "fastlylb": [2, { "map": _3 }], "edgeapp": _3, "keyword-on": _3, "live-on": _3, "server-on": _3, "cdn-edges": _3, "localcert": _3, "localhostcert": _3, "heteml": _3, "cloudfunctions": _3, "grafana-dev": _3, "iobb": _3, "moonscale": _3, "in-dsl": _3, "in-vpn": _3, "apps-1and1": _3, "ipifony": _3, "cloudjiffy": [2, { "fra1-de": _3, "west1-us": _3 }], "elastx": [0, { "jls-sto1": _3, "jls-sto2": _3, "jls-sto3": _3 }], "massivegrid": [0, { "paas": [0, { "fr-1": _3, "lon-1": _3, "lon-2": _3, "ny-1": _3, "ny-2": _3, "sg-1": _3 }] }], "saveincloud": [0, { "jelastic": _3, "nordeste-idc": _3 }], "scaleforce": _43, "kinghost": _3, "uni5": _3, "krellian": _3, "ggff": _3, "barsy": _3, "memset": _3, "azure-api": _3, "azure-mobile": _3, "azureedge": _3, "azurefd": _3, "azurestaticapps": [2, { "1": _3, "2": _3, "3": _3, "4": _3, "5": _3, "6": _3, "7": _3, "centralus": _3, "eastasia": _3, "eastus2": _3, "westeurope": _3, "westus2": _3 }], "azurewebsites": _3, "cloudapp": _3, "trafficmanager": _3, "windows": [0, { "core": [0, { "blob": _3 }], "servicebus": _3 }], "mynetname": [0, { "sn": _3 }], "routingthecloud": _3, "bounceme": _3, "ddns": _3, "eating-organic": _3, "mydissent": _3, "myeffect": _3, "mymediapc": _3, "mypsx": _3, "mysecuritycamera": _3, "nhlfan": _3, "no-ip": _3, "pgafan": _3, "privatizehealthinsurance": _3, "redirectme": _3, "serveblog": _3, "serveminecraft": _3, "sytes": _3, "dnsup": _3, "hicam": _3, "now-dns": _3, "ownip": _3, "vpndns": _3, "cloudycluster": _3, "ovh": [0, { "hosting": _5, "webpaas": _5 }], "rackmaze": _3, "myradweb": _3, "in": _3, "squares": _3, "schokokeks": _3, "firewall-gateway": _3, "seidat": _3, "senseering": _3, "siteleaf": _3, "mafelo": _3, "myspreadshop": _3, "vps-host": [2, { "jelastic": [0, { "atl": _3, "njs": _3, "ric": _3 }] }], "srcf": [0, { "soc": _3, "user": _3 }], "supabase": _3, "dsmynas": _3, "familyds": _3, "ts": [2, { "c": _5 }], "torproject": [2, { "pages": _3 }], "vusercontent": _3, "reserve-online": _3, "community-pro": _3, "meinforum": _3, "yandexcloud": [2, { "storage": _3, "website": _3 }], "za": _3 }], "nf": [1, { "com": _2, "net": _2, "per": _2, "rec": _2, "web": _2, "arts": _2, "firm": _2, "info": _2, "other": _2, "store": _2 }], "ng": [1, { "com": _8, "edu": _2, "gov": _2, "i": _2, "mil": _2, "mobi": _2, "name": _2, "net": _2, "org": _2, "sch": _2, "biz": [2, { "co": _3, "dl": _3, "go": _3, "lg": _3, "on": _3 }], "col": _3, "firm": _3, "gen": _3, "ltd": _3, "ngo": _3, "plc": _3 }], "ni": [1, { "ac": _2, "biz": _2, "co": _2, "com": _2, "edu": _2, "gob": _2, "in": _2, "info": _2, "int": _2, "mil": _2, "net": _2, "nom": _2, "org": _2, "web": _2 }], "nl": [1, { "co": _3, "hosting-cluster": _3, "blogspot": _3, "gov": _3, "khplay": _3, "123website": _3, "myspreadshop": _3, "transurl": _5, "cistron": _3, "demon": _3 }], "no": [1, { "fhs": _2, "vgs": _2, "fylkesbibl": _2, "folkebibl": _2, "museum": _2, "idrett": _2, "priv": _2, "mil": _2, "stat": _2, "dep": _2, "kommune": _2, "herad": _2, "aa": _56, "ah": _56, "bu": _56, "fm": _56, "hl": _56, "hm": _56, "jan-mayen": _56, "mr": _56, "nl": _56, "nt": _56, "of": _56, "ol": _56, "oslo": _56, "rl": _56, "sf": _56, "st": _56, "svalbard": _56, "tm": _56, "tr": _56, "va": _56, "vf": _56, "akrehamn": _2, "xn--krehamn-dxa": _2, "krehamn": _2, "algard": _2, "xn--lgrd-poac": _2, "lgrd": _2, "arna": _2, "brumunddal": _2, "bryne": _2, "bronnoysund": _2, "xn--brnnysund-m8ac": _2, "brnnysund": _2, "drobak": _2, "xn--drbak-wua": _2, "drbak": _2, "egersund": _2, "fetsund": _2, "floro": _2, "xn--flor-jra": _2, "flor": _2, "fredrikstad": _2, "hokksund": _2, "honefoss": _2, "xn--hnefoss-q1a": _2, "hnefoss": _2, "jessheim": _2, "jorpeland": _2, "xn--jrpeland-54a": _2, "jrpeland": _2, "kirkenes": _2, "kopervik": _2, "krokstadelva": _2, "langevag": _2, "xn--langevg-jxa": _2, "langevg": _2, "leirvik": _2, "mjondalen": _2, "xn--mjndalen-64a": _2, "mjndalen": _2, "mo-i-rana": _2, "mosjoen": _2, "xn--mosjen-eya": _2, "mosjen": _2, "nesoddtangen": _2, "orkanger": _2, "osoyro": _2, "xn--osyro-wua": _2, "osyro": _2, "raholt": _2, "xn--rholt-mra": _2, "rholt": _2, "sandnessjoen": _2, "xn--sandnessjen-ogb": _2, "sandnessjen": _2, "skedsmokorset": _2, "slattum": _2, "spjelkavik": _2, "stathelle": _2, "stavern": _2, "stjordalshalsen": _2, "xn--stjrdalshalsen-sqb": _2, "stjrdalshalsen": _2, "tananger": _2, "tranby": _2, "vossevangen": _2, "afjord": _2, "xn--fjord-lra": _2, "fjord": _2, "agdenes": _2, "al": _2, "xn--l-1fa": _2, "l": _2, "alesund": _2, "xn--lesund-hua": _2, "lesund": _2, "alstahaug": _2, "alta": _2, "xn--lt-liac": _2, "lt": _2, "alaheadju": _2, "xn--laheadju-7ya": _2, "laheadju": _2, "alvdal": _2, "amli": _2, "xn--mli-tla": _2, "mli": _2, "amot": _2, "xn--mot-tla": _2, "mot": _2, "andebu": _2, "andoy": _2, "xn--andy-ira": _2, "andy": _2, "andasuolo": _2, "ardal": _2, "xn--rdal-poa": _2, "rdal": _2, "aremark": _2, "arendal": _2, "xn--s-1fa": _2, "s": _2, "aseral": _2, "xn--seral-lra": _2, "seral": _2, "asker": _2, "askim": _2, "askvoll": _2, "askoy": _2, "xn--asky-ira": _2, "asky": _2, "asnes": _2, "xn--snes-poa": _2, "snes": _2, "audnedaln": _2, "aukra": _2, "aure": _2, "aurland": _2, "aurskog-holand": _2, "xn--aurskog-hland-jnb": _2, "aurskog-hland": _2, "austevoll": _2, "austrheim": _2, "averoy": _2, "xn--avery-yua": _2, "avery": _2, "balestrand": _2, "ballangen": _2, "balat": _2, "xn--blt-elab": _2, "blt": _2, "balsfjord": _2, "bahccavuotna": _2, "xn--bhccavuotna-k7a": _2, "bhccavuotna": _2, "bamble": _2, "bardu": _2, "beardu": _2, "beiarn": _2, "bajddar": _2, "xn--bjddar-pta": _2, "bjddar": _2, "baidar": _2, "xn--bidr-5nac": _2, "bidr": _2, "berg": _2, "bergen": _2, "berlevag": _2, "xn--berlevg-jxa": _2, "berlevg": _2, "bearalvahki": _2, "xn--bearalvhki-y4a": _2, "bearalvhki": _2, "bindal": _2, "birkenes": _2, "bjarkoy": _2, "xn--bjarky-fya": _2, "bjarky": _2, "bjerkreim": _2, "bjugn": _2, "bodo": _2, "xn--bod-2na": _2, "bod": _2, "badaddja": _2, "xn--bdddj-mrabd": _2, "bdddj": _2, "budejju": _2, "bokn": _2, "bremanger": _2, "bronnoy": _2, "xn--brnny-wuac": _2, "brnny": _2, "bygland": _2, "bykle": _2, "barum": _2, "xn--brum-voa": _2, "brum": _2, "telemark": [0, { "bo": _2, "xn--b-5ga": _2, "b": _2 }], "nordland": [0, { "bo": _2, "xn--b-5ga": _2, "b": _2, "heroy": _2, "xn--hery-ira": _2, "hery": _2 }], "bievat": _2, "xn--bievt-0qa": _2, "bievt": _2, "bomlo": _2, "xn--bmlo-gra": _2, "bmlo": _2, "batsfjord": _2, "xn--btsfjord-9za": _2, "btsfjord": _2, "bahcavuotna": _2, "xn--bhcavuotna-s4a": _2, "bhcavuotna": _2, "dovre": _2, "drammen": _2, "drangedal": _2, "dyroy": _2, "xn--dyry-ira": _2, "dyry": _2, "donna": _2, "xn--dnna-gra": _2, "dnna": _2, "eid": _2, "eidfjord": _2, "eidsberg": _2, "eidskog": _2, "eidsvoll": _2, "eigersund": _2, "elverum": _2, "enebakk": _2, "engerdal": _2, "etne": _2, "etnedal": _2, "evenes": _2, "evenassi": _2, "xn--eveni-0qa01ga": _2, "eveni": _2, "evje-og-hornnes": _2, "farsund": _2, "fauske": _2, "fuossko": _2, "fuoisku": _2, "fedje": _2, "fet": _2, "finnoy": _2, "xn--finny-yua": _2, "finny": _2, "fitjar": _2, "fjaler": _2, "fjell": _2, "flakstad": _2, "flatanger": _2, "flekkefjord": _2, "flesberg": _2, "flora": _2, "fla": _2, "xn--fl-zia": _2, "fl": _2, "folldal": _2, "forsand": _2, "fosnes": _2, "frei": _2, "frogn": _2, "froland": _2, "frosta": _2, "frana": _2, "xn--frna-woa": _2, "frna": _2, "froya": _2, "xn--frya-hra": _2, "frya": _2, "fusa": _2, "fyresdal": _2, "forde": _2, "xn--frde-gra": _2, "frde": _2, "gamvik": _2, "gangaviika": _2, "xn--ggaviika-8ya47h": _2, "ggaviika": _2, "gaular": _2, "gausdal": _2, "gildeskal": _2, "xn--gildeskl-g0a": _2, "gildeskl": _2, "giske": _2, "gjemnes": _2, "gjerdrum": _2, "gjerstad": _2, "gjesdal": _2, "gjovik": _2, "xn--gjvik-wua": _2, "gjvik": _2, "gloppen": _2, "gol": _2, "gran": _2, "grane": _2, "granvin": _2, "gratangen": _2, "grimstad": _2, "grong": _2, "kraanghke": _2, "xn--kranghke-b0a": _2, "kranghke": _2, "grue": _2, "gulen": _2, "hadsel": _2, "halden": _2, "halsa": _2, "hamar": _2, "hamaroy": _2, "habmer": _2, "xn--hbmer-xqa": _2, "hbmer": _2, "hapmir": _2, "xn--hpmir-xqa": _2, "hpmir": _2, "hammerfest": _2, "hammarfeasta": _2, "xn--hmmrfeasta-s4ac": _2, "hmmrfeasta": _2, "haram": _2, "hareid": _2, "harstad": _2, "hasvik": _2, "aknoluokta": _2, "xn--koluokta-7ya57h": _2, "koluokta": _2, "hattfjelldal": _2, "aarborte": _2, "haugesund": _2, "hemne": _2, "hemnes": _2, "hemsedal": _2, "more-og-romsdal": [0, { "heroy": _2, "sande": _2 }], "xn--mre-og-romsdal-qqb": [0, { "xn--hery-ira": _2, "sande": _2 }], "mre-og-romsdal": [0, { "hery": _2, "sande": _2 }], "hitra": _2, "hjartdal": _2, "hjelmeland": _2, "hobol": _2, "xn--hobl-ira": _2, "hobl": _2, "hof": _2, "hol": _2, "hole": _2, "holmestrand": _2, "holtalen": _2, "xn--holtlen-hxa": _2, "holtlen": _2, "hornindal": _2, "horten": _2, "hurdal": _2, "hurum": _2, "hvaler": _2, "hyllestad": _2, "hagebostad": _2, "xn--hgebostad-g3a": _2, "hgebostad": _2, "hoyanger": _2, "xn--hyanger-q1a": _2, "hyanger": _2, "hoylandet": _2, "xn--hylandet-54a": _2, "hylandet": _2, "ha": _2, "xn--h-2fa": _2, "h": _2, "ibestad": _2, "inderoy": _2, "xn--indery-fya": _2, "indery": _2, "iveland": _2, "jevnaker": _2, "jondal": _2, "jolster": _2, "xn--jlster-bya": _2, "jlster": _2, "karasjok": _2, "karasjohka": _2, "xn--krjohka-hwab49j": _2, "krjohka": _2, "karlsoy": _2, "galsa": _2, "xn--gls-elac": _2, "gls": _2, "karmoy": _2, "xn--karmy-yua": _2, "karmy": _2, "kautokeino": _2, "guovdageaidnu": _2, "klepp": _2, "klabu": _2, "xn--klbu-woa": _2, "klbu": _2, "kongsberg": _2, "kongsvinger": _2, "kragero": _2, "xn--krager-gya": _2, "krager": _2, "kristiansand": _2, "kristiansund": _2, "krodsherad": _2, "xn--krdsherad-m8a": _2, "krdsherad": _2, "kvalsund": _2, "rahkkeravju": _2, "xn--rhkkervju-01af": _2, "rhkkervju": _2, "kvam": _2, "kvinesdal": _2, "kvinnherad": _2, "kviteseid": _2, "kvitsoy": _2, "xn--kvitsy-fya": _2, "kvitsy": _2, "kvafjord": _2, "xn--kvfjord-nxa": _2, "kvfjord": _2, "giehtavuoatna": _2, "kvanangen": _2, "xn--kvnangen-k0a": _2, "kvnangen": _2, "navuotna": _2, "xn--nvuotna-hwa": _2, "nvuotna": _2, "kafjord": _2, "xn--kfjord-iua": _2, "kfjord": _2, "gaivuotna": _2, "xn--givuotna-8ya": _2, "givuotna": _2, "larvik": _2, "lavangen": _2, "lavagis": _2, "loabat": _2, "xn--loabt-0qa": _2, "loabt": _2, "lebesby": _2, "davvesiida": _2, "leikanger": _2, "leirfjord": _2, "leka": _2, "leksvik": _2, "lenvik": _2, "leangaviika": _2, "xn--leagaviika-52b": _2, "leagaviika": _2, "lesja": _2, "levanger": _2, "lier": _2, "lierne": _2, "lillehammer": _2, "lillesand": _2, "lindesnes": _2, "lindas": _2, "xn--linds-pra": _2, "linds": _2, "lom": _2, "loppa": _2, "lahppi": _2, "xn--lhppi-xqa": _2, "lhppi": _2, "lund": _2, "lunner": _2, "luroy": _2, "xn--lury-ira": _2, "lury": _2, "luster": _2, "lyngdal": _2, "lyngen": _2, "ivgu": _2, "lardal": _2, "lerdal": _2, "xn--lrdal-sra": _2, "lrdal": _2, "lodingen": _2, "xn--ldingen-q1a": _2, "ldingen": _2, "lorenskog": _2, "xn--lrenskog-54a": _2, "lrenskog": _2, "loten": _2, "xn--lten-gra": _2, "lten": _2, "malvik": _2, "masoy": _2, "xn--msy-ula0h": _2, "msy": _2, "muosat": _2, "xn--muost-0qa": _2, "muost": _2, "mandal": _2, "marker": _2, "marnardal": _2, "masfjorden": _2, "meland": _2, "meldal": _2, "melhus": _2, "meloy": _2, "xn--mely-ira": _2, "mely": _2, "meraker": _2, "xn--merker-kua": _2, "merker": _2, "moareke": _2, "xn--moreke-jua": _2, "moreke": _2, "midsund": _2, "midtre-gauldal": _2, "modalen": _2, "modum": _2, "molde": _2, "moskenes": _2, "moss": _2, "mosvik": _2, "malselv": _2, "xn--mlselv-iua": _2, "mlselv": _2, "malatvuopmi": _2, "xn--mlatvuopmi-s4a": _2, "mlatvuopmi": _2, "namdalseid": _2, "aejrie": _2, "namsos": _2, "namsskogan": _2, "naamesjevuemie": _2, "xn--nmesjevuemie-tcba": _2, "nmesjevuemie": _2, "laakesvuemie": _2, "nannestad": _2, "narvik": _2, "narviika": _2, "naustdal": _2, "nedre-eiker": _2, "akershus": _57, "buskerud": _57, "nesna": _2, "nesodden": _2, "nesseby": _2, "unjarga": _2, "xn--unjrga-rta": _2, "unjrga": _2, "nesset": _2, "nissedal": _2, "nittedal": _2, "nord-aurdal": _2, "nord-fron": _2, "nord-odal": _2, "norddal": _2, "nordkapp": _2, "davvenjarga": _2, "xn--davvenjrga-y4a": _2, "davvenjrga": _2, "nordre-land": _2, "nordreisa": _2, "raisa": _2, "xn--risa-5na": _2, "risa": _2, "nore-og-uvdal": _2, "notodden": _2, "naroy": _2, "xn--nry-yla5g": _2, "nry": _2, "notteroy": _2, "xn--nttery-byae": _2, "nttery": _2, "odda": _2, "oksnes": _2, "xn--ksnes-uua": _2, "ksnes": _2, "oppdal": _2, "oppegard": _2, "xn--oppegrd-ixa": _2, "oppegrd": _2, "orkdal": _2, "orland": _2, "xn--rland-uua": _2, "rland": _2, "orskog": _2, "xn--rskog-uua": _2, "rskog": _2, "orsta": _2, "xn--rsta-fra": _2, "rsta": _2, "hedmark": [0, { "os": _2, "valer": _2, "xn--vler-qoa": _2, "vler": _2 }], "hordaland": [0, { "os": _2 }], "osen": _2, "osteroy": _2, "xn--ostery-fya": _2, "ostery": _2, "ostre-toten": _2, "xn--stre-toten-zcb": _2, "stre-toten": _2, "overhalla": _2, "ovre-eiker": _2, "xn--vre-eiker-k8a": _2, "vre-eiker": _2, "oyer": _2, "xn--yer-zna": _2, "yer": _2, "oygarden": _2, "xn--ygarden-p1a": _2, "ygarden": _2, "oystre-slidre": _2, "xn--ystre-slidre-ujb": _2, "ystre-slidre": _2, "porsanger": _2, "porsangu": _2, "xn--porsgu-sta26f": _2, "porsgu": _2, "porsgrunn": _2, "radoy": _2, "xn--rady-ira": _2, "rady": _2, "rakkestad": _2, "rana": _2, "ruovat": _2, "randaberg": _2, "rauma": _2, "rendalen": _2, "rennebu": _2, "rennesoy": _2, "xn--rennesy-v1a": _2, "rennesy": _2, "rindal": _2, "ringebu": _2, "ringerike": _2, "ringsaker": _2, "rissa": _2, "risor": _2, "xn--risr-ira": _2, "risr": _2, "roan": _2, "rollag": _2, "rygge": _2, "ralingen": _2, "xn--rlingen-mxa": _2, "rlingen": _2, "rodoy": _2, "xn--rdy-0nab": _2, "rdy": _2, "romskog": _2, "xn--rmskog-bya": _2, "rmskog": _2, "roros": _2, "xn--rros-gra": _2, "rros": _2, "rost": _2, "xn--rst-0na": _2, "rst": _2, "royken": _2, "xn--ryken-vua": _2, "ryken": _2, "royrvik": _2, "xn--ryrvik-bya": _2, "ryrvik": _2, "rade": _2, "xn--rde-ula": _2, "rde": _2, "salangen": _2, "siellak": _2, "saltdal": _2, "salat": _2, "xn--slt-elab": _2, "slt": _2, "xn--slat-5na": _2, "slat": _2, "samnanger": _2, "vestfold": [0, { "sande": _2 }], "sandefjord": _2, "sandnes": _2, "sandoy": _2, "xn--sandy-yua": _2, "sandy": _2, "sarpsborg": _2, "sauda": _2, "sauherad": _2, "sel": _2, "selbu": _2, "selje": _2, "seljord": _2, "sigdal": _2, "siljan": _2, "sirdal": _2, "skaun": _2, "skedsmo": _2, "ski": _2, "skien": _2, "skiptvet": _2, "skjervoy": _2, "xn--skjervy-v1a": _2, "skjervy": _2, "skierva": _2, "xn--skierv-uta": _2, "skierv": _2, "skjak": _2, "xn--skjk-soa": _2, "skjk": _2, "skodje": _2, "skanland": _2, "xn--sknland-fxa": _2, "sknland": _2, "skanit": _2, "xn--sknit-yqa": _2, "sknit": _2, "smola": _2, "xn--smla-hra": _2, "smla": _2, "snillfjord": _2, "snasa": _2, "xn--snsa-roa": _2, "snsa": _2, "snoasa": _2, "snaase": _2, "xn--snase-nra": _2, "snase": _2, "sogndal": _2, "sokndal": _2, "sola": _2, "solund": _2, "songdalen": _2, "sortland": _2, "spydeberg": _2, "stange": _2, "stavanger": _2, "steigen": _2, "steinkjer": _2, "stjordal": _2, "xn--stjrdal-s1a": _2, "stjrdal": _2, "stokke": _2, "stor-elvdal": _2, "stord": _2, "stordal": _2, "storfjord": _2, "omasvuotna": _2, "strand": _2, "stranda": _2, "stryn": _2, "sula": _2, "suldal": _2, "sund": _2, "sunndal": _2, "surnadal": _2, "sveio": _2, "svelvik": _2, "sykkylven": _2, "sogne": _2, "xn--sgne-gra": _2, "sgne": _2, "somna": _2, "xn--smna-gra": _2, "smna": _2, "sondre-land": _2, "xn--sndre-land-0cb": _2, "sndre-land": _2, "sor-aurdal": _2, "xn--sr-aurdal-l8a": _2, "sr-aurdal": _2, "sor-fron": _2, "xn--sr-fron-q1a": _2, "sr-fron": _2, "sor-odal": _2, "xn--sr-odal-q1a": _2, "sr-odal": _2, "sor-varanger": _2, "xn--sr-varanger-ggb": _2, "sr-varanger": _2, "matta-varjjat": _2, "xn--mtta-vrjjat-k7af": _2, "mtta-vrjjat": _2, "sorfold": _2, "xn--srfold-bya": _2, "srfold": _2, "sorreisa": _2, "xn--srreisa-q1a": _2, "srreisa": _2, "sorum": _2, "xn--srum-gra": _2, "srum": _2, "tana": _2, "deatnu": _2, "time": _2, "tingvoll": _2, "tinn": _2, "tjeldsund": _2, "dielddanuorri": _2, "tjome": _2, "xn--tjme-hra": _2, "tjme": _2, "tokke": _2, "tolga": _2, "torsken": _2, "tranoy": _2, "xn--trany-yua": _2, "trany": _2, "tromso": _2, "xn--troms-zua": _2, "troms": _2, "tromsa": _2, "romsa": _2, "trondheim": _2, "troandin": _2, "trysil": _2, "trana": _2, "xn--trna-woa": _2, "trna": _2, "trogstad": _2, "xn--trgstad-r1a": _2, "trgstad": _2, "tvedestrand": _2, "tydal": _2, "tynset": _2, "tysfjord": _2, "divtasvuodna": _2, "divttasvuotna": _2, "tysnes": _2, "tysvar": _2, "xn--tysvr-vra": _2, "tysvr": _2, "tonsberg": _2, "xn--tnsberg-q1a": _2, "tnsberg": _2, "ullensaker": _2, "ullensvang": _2, "ulvik": _2, "utsira": _2, "vadso": _2, "xn--vads-jra": _2, "vads": _2, "cahcesuolo": _2, "xn--hcesuolo-7ya35b": _2, "hcesuolo": _2, "vaksdal": _2, "valle": _2, "vang": _2, "vanylven": _2, "vardo": _2, "xn--vard-jra": _2, "vard": _2, "varggat": _2, "xn--vrggt-xqad": _2, "vrggt": _2, "vefsn": _2, "vaapste": _2, "vega": _2, "vegarshei": _2, "xn--vegrshei-c0a": _2, "vegrshei": _2, "vennesla": _2, "verdal": _2, "verran": _2, "vestby": _2, "vestnes": _2, "vestre-slidre": _2, "vestre-toten": _2, "vestvagoy": _2, "xn--vestvgy-ixa6o": _2, "vestvgy": _2, "vevelstad": _2, "vik": _2, "vikna": _2, "vindafjord": _2, "volda": _2, "voss": _2, "varoy": _2, "xn--vry-yla5g": _2, "vry": _2, "vagan": _2, "xn--vgan-qoa": _2, "vgan": _2, "voagat": _2, "vagsoy": _2, "xn--vgsy-qoa0j": _2, "vgsy": _2, "vaga": _2, "xn--vg-yiab": _2, "vg": _2, "ostfold": [0, { "valer": _2 }], "xn--stfold-9xa": [0, { "xn--vler-qoa": _2 }], "stfold": [0, { "vler": _2 }], "co": _3, "blogspot": _3, "123hjemmeside": _3, "myspreadshop": _3 }], "np": _15, "nr": _52, "nu": [1, { "merseine": _3, "mine": _3, "shacknet": _3, "enterprisecloud": _3 }], "nz": [1, { "ac": _2, "co": _8, "cri": _2, "geek": _2, "gen": _2, "govt": _2, "health": _2, "iwi": _2, "kiwi": _2, "maori": _2, "mil": _2, "xn--mori-qsa": _2, "mori": _2, "net": _2, "org": _2, "parliament": _2, "school": _2, "cloudns": _3 }], "om": [1, { "co": _2, "com": _2, "edu": _2, "gov": _2, "med": _2, "museum": _2, "net": _2, "org": _2, "pro": _2 }], "onion": _2, "org": [1, { "altervista": _3, "pimienta": _3, "poivron": _3, "potager": _3, "sweetpepper": _3, "cdn77": [0, { "c": _3, "rsc": _3 }], "cdn77-secure": [0, { "origin": [0, { "ssl": _3 }] }], "ae": _3, "cloudns": _3, "ip-dynamic": _3, "ddnss": _3, "duckdns": _3, "tunk": _3, "blogdns": _3, "blogsite": _3, "boldlygoingnowhere": _3, "dnsalias": _3, "dnsdojo": _3, "doesntexist": _3, "dontexist": _3, "doomdns": _3, "dvrdns": _3, "dynalias": _3, "dyndns": [2, { "go": _3, "home": _3 }], "endofinternet": _3, "endoftheinternet": _3, "from-me": _3, "game-host": _3, "gotdns": _3, "hobby-site": _3, "homedns": _3, "homeftp": _3, "homelinux": _3, "homeunix": _3, "is-a-bruinsfan": _3, "is-a-candidate": _3, "is-a-celticsfan": _3, "is-a-chef": _3, "is-a-geek": _3, "is-a-knight": _3, "is-a-linux-user": _3, "is-a-patsfan": _3, "is-a-soxfan": _3, "is-found": _3, "is-lost": _3, "is-saved": _3, "is-very-bad": _3, "is-very-evil": _3, "is-very-good": _3, "is-very-nice": _3, "is-very-sweet": _3, "isa-geek": _3, "kicks-ass": _3, "misconfused": _3, "podzone": _3, "readmyblog": _3, "selfip": _3, "sellsyourhome": _3, "servebbs": _3, "serveftp": _3, "servegame": _3, "stuff-4-sale": _3, "webhop": _3, "accesscam": _3, "camdvr": _3, "freeddns": _3, "mywire": _3, "webredirect": _3, "twmail": _3, "eu": [2, { "al": _3, "asso": _3, "at": _3, "au": _3, "be": _3, "bg": _3, "ca": _3, "cd": _3, "ch": _3, "cn": _3, "cy": _3, "cz": _3, "de": _3, "dk": _3, "edu": _3, "ee": _3, "es": _3, "fi": _3, "fr": _3, "gr": _3, "hr": _3, "hu": _3, "ie": _3, "il": _3, "in": _3, "int": _3, "is": _3, "it": _3, "jp": _3, "kr": _3, "lt": _3, "lu": _3, "lv": _3, "me": _3, "mk": _3, "mt": _3, "my": _3, "net": _3, "ng": _3, "nl": _3, "no": _3, "nz": _3, "pl": _3, "pt": _3, "ro": _3, "ru": _3, "se": _3, "si": _3, "sk": _3, "tr": _3, "uk": _3, "us": _3 }], "fedorainfracloud": _3, "fedorapeople": _3, "fedoraproject": [0, { "cloud": _3, "os": _40, "stg": [0, { "os": _40 }] }], "freedesktop": _3, "hatenadiary": _3, "hepforge": _3, "in-dsl": _3, "in-vpn": _3, "js": _3, "barsy": _3, "mayfirst": _3, "routingthecloud": _3, "bmoattachments": _3, "cable-modem": _3, "collegefan": _3, "couchpotatofries": _3, "hopto": _3, "mlbfan": _3, "myftp": _3, "mysecuritycamera": _3, "nflfan": _3, "no-ip": _3, "read-books": _3, "ufcfan": _3, "zapto": _3, "dynserv": _3, "now-dns": _3, "is-local": _3, "httpbin": _3, "pubtls": _3, "jpn": _3, "my-firewall": _3, "myfirewall": _3, "spdns": _3, "small-web": _3, "dsmynas": _3, "familyds": _3, "teckids": _51, "tuxfamily": _3, "diskstation": _3, "hk": _3, "us": _3, "toolforge": _3, "wmcloud": _3, "wmflabs": _3, "za": _3 }], "pa": [1, { "ac": _2, "gob": _2, "com": _2, "org": _2, "sld": _2, "edu": _2, "net": _2, "ing": _2, "abo": _2, "med": _2, "nom": _2 }], "pe": [1, { "edu": _2, "gob": _2, "nom": _2, "mil": _2, "org": _2, "com": _2, "net": _2, "blogspot": _3 }], "pf": [1, { "com": _2, "org": _2, "edu": _2 }], "pg": _15, "ph": [1, { "com": _2, "net": _2, "org": _2, "gov": _2, "edu": _2, "ngo": _2, "mil": _2, "i": _2, "cloudns": _3 }], "pk": [1, { "ac": _2, "biz": _2, "com": _2, "edu": _2, "fam": _2, "gkp": _2, "gob": _2, "gog": _2, "gok": _2, "gon": _2, "gop": _2, "gos": _2, "gov": _2, "net": _2, "org": _2, "web": _2 }], "pl": [1, { "com": _2, "net": _2, "org": _2, "agro": _2, "aid": _2, "atm": _2, "auto": _2, "biz": _2, "edu": _2, "gmina": _2, "gsm": _2, "info": _2, "mail": _2, "media": _2, "miasta": _2, "mil": _2, "nieruchomosci": _2, "nom": _2, "pc": _2, "powiat": _2, "priv": _2, "realestate": _2, "rel": _2, "sex": _2, "shop": _2, "sklep": _2, "sos": _2, "szkola": _2, "targi": _2, "tm": _2, "tourism": _2, "travel": _2, "turystyka": _2, "gov": [1, { "ap": _2, "griw": _2, "ic": _2, "is": _2, "kmpsp": _2, "konsulat": _2, "kppsp": _2, "kwp": _2, "kwpsp": _2, "mup": _2, "mw": _2, "oia": _2, "oirm": _2, "oke": _2, "oow": _2, "oschr": _2, "oum": _2, "pa": _2, "pinb": _2, "piw": _2, "po": _2, "pr": _2, "psp": _2, "psse": _2, "pup": _2, "rzgw": _2, "sa": _2, "sdn": _2, "sko": _2, "so": _2, "sr": _2, "starostwo": _2, "ug": _2, "ugim": _2, "um": _2, "umig": _2, "upow": _2, "uppo": _2, "us": _2, "uw": _2, "uzs": _2, "wif": _2, "wiih": _2, "winb": _2, "wios": _2, "witd": _2, "wiw": _2, "wkz": _2, "wsa": _2, "wskr": _2, "wsse": _2, "wuoz": _2, "wzmiuw": _2, "zp": _2, "zpisdn": _2 }], "augustow": _2, "babia-gora": _2, "bedzin": _2, "beskidy": _2, "bialowieza": _2, "bialystok": _2, "bielawa": _2, "bieszczady": _2, "boleslawiec": _2, "bydgoszcz": _2, "bytom": _2, "cieszyn": _2, "czeladz": _2, "czest": _2, "dlugoleka": _2, "elblag": _2, "elk": _2, "glogow": _2, "gniezno": _2, "gorlice": _2, "grajewo": _2, "ilawa": _2, "jaworzno": _2, "jelenia-gora": _2, "jgora": _2, "kalisz": _2, "karpacz": _2, "kartuzy": _2, "kaszuby": _2, "katowice": _2, "kazimierz-dolny": _2, "kepno": _2, "ketrzyn": _2, "klodzko": _2, "kobierzyce": _2, "kolobrzeg": _2, "konin": _2, "konskowola": _2, "kutno": _2, "lapy": _2, "lebork": _2, "legnica": _2, "lezajsk": _2, "limanowa": _2, "lomza": _2, "lowicz": _2, "lubin": _2, "lukow": _2, "malbork": _2, "malopolska": _2, "mazowsze": _2, "mazury": _2, "mielec": _2, "mielno": _2, "mragowo": _2, "naklo": _2, "nowaruda": _2, "nysa": _2, "olawa": _2, "olecko": _2, "olkusz": _2, "olsztyn": _2, "opoczno": _2, "opole": _2, "ostroda": _2, "ostroleka": _2, "ostrowiec": _2, "ostrowwlkp": _2, "pila": _2, "pisz": _2, "podhale": _2, "podlasie": _2, "polkowice": _2, "pomorskie": _2, "pomorze": _2, "prochowice": _2, "pruszkow": _2, "przeworsk": _2, "pulawy": _2, "radom": _2, "rawa-maz": _2, "rybnik": _2, "rzeszow": _2, "sanok": _2, "sejny": _2, "skoczow": _2, "slask": _2, "slupsk": _2, "sosnowiec": _2, "stalowa-wola": _2, "starachowice": _2, "stargard": _2, "suwalki": _2, "swidnica": _2, "swiebodzin": _2, "swinoujscie": _2, "szczecin": _2, "szczytno": _2, "tarnobrzeg": _2, "tgory": _2, "turek": _2, "tychy": _2, "ustka": _2, "walbrzych": _2, "warmia": _2, "warszawa": _2, "waw": _2, "wegrow": _2, "wielun": _2, "wlocl": _2, "wloclawek": _2, "wodzislaw": _2, "wolomin": _2, "wroclaw": _2, "zachpomor": _2, "zagan": _2, "zarow": _2, "zgora": _2, "zgorzelec": _2, "art": _3, "gliwice": _3, "krakow": _3, "poznan": _3, "wroc": _3, "zakopane": _3, "beep": _3, "ecommerce-shop": _3, "cfolks": _3, "dfirma": _3, "dkonto": _3, "you2": _3, "shoparena": _3, "homesklep": _3, "sdscloud": _3, "unicloud": _3, "lodz": _3, "pabianice": _3, "plock": _3, "sieradz": _3, "skierniewice": _3, "zgierz": _3, "krasnik": _3, "leczna": _3, "lubartow": _3, "lublin": _3, "poniatowa": _3, "swidnik": _3, "co": _3, "torun": _3, "simplesite": _3, "myspreadshop": _3, "gda": _3, "gdansk": _3, "gdynia": _3, "med": _3, "sopot": _3, "bielsko": _3 }], "pm": [1, { "own": _3, "name": _3 }], "pn": [1, { "gov": _2, "co": _2, "org": _2, "edu": _2, "net": _2 }], "post": _2, "pr": [1, { "com": _2, "net": _2, "org": _2, "gov": _2, "edu": _2, "isla": _2, "pro": _2, "biz": _2, "info": _2, "name": _2, "est": _2, "prof": _2, "ac": _2 }], "pro": [1, { "aaa": _2, "aca": _2, "acct": _2, "avocat": _2, "bar": _2, "cpa": _2, "eng": _2, "jur": _2, "law": _2, "med": _2, "recht": _2, "12chars": _3, "cloudns": _3, "barsy": _3, "ngrok": _3 }], "ps": [1, { "edu": _2, "gov": _2, "sec": _2, "plo": _2, "com": _2, "org": _2, "net": _2 }], "pt": [1, { "net": _2, "gov": _2, "org": _2, "edu": _2, "int": _2, "publ": _2, "com": _2, "nome": _2, "blogspot": _3, "123paginaweb": _3 }], "pw": [1, { "co": _2, "or": _2, "ed": _2, "go": _2, "belau": _2, "cloudns": _3, "x443": _3 }], "py": [1, { "com": _2, "coop": _2, "edu": _2, "gov": _2, "mil": _2, "net": _2, "org": _2 }], "qa": [1, { "com": _2, "edu": _2, "gov": _2, "mil": _2, "name": _2, "net": _2, "org": _2, "sch": _2, "blogspot": _3 }], "re": [1, { "asso": _2, "com": _2, "blogspot": _3, "can": _3 }], "ro": [1, { "arts": _2, "com": _2, "firm": _2, "info": _2, "nom": _2, "nt": _2, "org": _2, "rec": _2, "store": _2, "tm": _2, "www": _2, "co": _3, "shop": _3, "blogspot": _3, "barsy": _3 }], "rs": [1, { "ac": _2, "co": _2, "edu": _2, "gov": _2, "in": _2, "org": _2, "brendly": _47, "blogspot": _3, "ua": _3, "barsy": _3, "ox": _3 }], "ru": [1, { "ac": _3, "edu": _3, "gov": _3, "int": _3, "mil": _3, "test": _3, "eurodir": _3, "adygeya": _3, "bashkiria": _3, "bir": _3, "cbg": _3, "com": _3, "dagestan": _3, "grozny": _3, "kalmykia": _3, "kustanai": _3, "marine": _3, "mordovia": _3, "msk": _3, "mytis": _3, "nalchik": _3, "nov": _3, "pyatigorsk": _3, "spb": _3, "vladikavkaz": _3, "vladimir": _3, "blogspot": _3, "na4u": _3, "mircloud": _3, "myjino": [2, { "hosting": _5, "landing": _5, "spectrum": _5, "vps": _5 }], "cldmail": [0, { "hb": _3 }], "mcdir": [2, { "vps": _3 }], "mcpre": _3, "net": _3, "org": _3, "pp": _3, "lk3": _3, "ras": _3 }], "rw": [1, { "ac": _2, "co": _2, "coop": _2, "gov": _2, "mil": _2, "net": _2, "org": _2 }], "sa": [1, { "com": _2, "net": _2, "org": _2, "gov": _2, "med": _2, "pub": _2, "edu": _2, "sch": _2 }], "sb": _4, "sc": _4, "sd": [1, { "com": _2, "net": _2, "org": _2, "edu": _2, "med": _2, "tv": _2, "gov": _2, "info": _2 }], "se": [1, { "a": _2, "ac": _2, "b": _2, "bd": _2, "brand": _2, "c": _2, "d": _2, "e": _2, "f": _2, "fh": _2, "fhsk": _2, "fhv": _2, "g": _2, "h": _2, "i": _2, "k": _2, "komforb": _2, "kommunalforbund": _2, "komvux": _2, "l": _2, "lanbib": _2, "m": _2, "n": _2, "naturbruksgymn": _2, "o": _2, "org": _2, "p": _2, "parti": _2, "pp": _2, "press": _2, "r": _2, "s": _2, "t": _2, "tm": _2, "u": _2, "w": _2, "x": _2, "y": _2, "z": _2, "com": _3, "blogspot": _3, "conf": _3, "iopsys": _3, "123minsida": _3, "itcouldbewor": _3, "myspreadshop": _3 }], "sg": [1, { "com": _2, "net": _2, "org": _2, "gov": _2, "edu": _2, "blogspot": _3, "enscaled": _3 }], "sh": [1, { "com": _2, "net": _2, "gov": _2, "org": _2, "mil": _2, "hashbang": _3, "platform": [0, { "ent": _3, "eu": _3, "us": _3 }], "now": _3 }], "si": [1, { "f5": _3, "gitapp": _3, "gitpage": _3, "blogspot": _3 }], "sj": _2, "sk": _8, "sl": _4, "sm": _2, "sn": [1, { "art": _2, "com": _2, "edu": _2, "gouv": _2, "org": _2, "perso": _2, "univ": _2, "blogspot": _3 }], "so": [1, { "com": _2, "edu": _2, "gov": _2, "me": _2, "net": _2, "org": _2, "surveys": _3 }], "sr": _2, "ss": [1, { "biz": _2, "co": _2, "com": _2, "edu": _2, "gov": _2, "me": _2, "net": _2, "org": _2, "sch": _2 }], "st": [1, { "co": _2, "com": _2, "consulado": _2, "edu": _2, "embaixada": _2, "mil": _2, "net": _2, "org": _2, "principe": _2, "saotome": _2, "store": _2, "helioho": _3, "kirara": _3, "noho": _3 }], "su": [1, { "abkhazia": _3, "adygeya": _3, "aktyubinsk": _3, "arkhangelsk": _3, "armenia": _3, "ashgabad": _3, "azerbaijan": _3, "balashov": _3, "bashkiria": _3, "bryansk": _3, "bukhara": _3, "chimkent": _3, "dagestan": _3, "east-kazakhstan": _3, "exnet": _3, "georgia": _3, "grozny": _3, "ivanovo": _3, "jambyl": _3, "kalmykia": _3, "kaluga": _3, "karacol": _3, "karaganda": _3, "karelia": _3, "khakassia": _3, "krasnodar": _3, "kurgan": _3, "kustanai": _3, "lenug": _3, "mangyshlak": _3, "mordovia": _3, "msk": _3, "murmansk": _3, "nalchik": _3, "navoi": _3, "north-kazakhstan": _3, "nov": _3, "obninsk": _3, "penza": _3, "pokrovsk": _3, "sochi": _3, "spb": _3, "tashkent": _3, "termez": _3, "togliatti": _3, "troitsk": _3, "tselinograd": _3, "tula": _3, "tuva": _3, "vladikavkaz": _3, "vladimir": _3, "vologda": _3 }], "sv": [1, { "com": _2, "edu": _2, "gob": _2, "org": _2, "red": _2 }], "sx": _9, "sy": _50, "sz": [1, { "co": _2, "ac": _2, "org": _2 }], "tc": _2, "td": _8, "tel": _2, "tf": [1, { "sch": _3 }], "tg": _2, "th": [1, { "ac": _2, "co": _2, "go": _2, "in": _2, "mi": _2, "net": _2, "or": _2, "online": _3, "shop": _3 }], "tj": [1, { "ac": _2, "biz": _2, "co": _2, "com": _2, "edu": _2, "go": _2, "gov": _2, "int": _2, "mil": _2, "name": _2, "net": _2, "nic": _2, "org": _2, "test": _2, "web": _2 }], "tk": _2, "tl": _9, "tm": [1, { "co": _2, "com": _2, "edu": _2, "gov": _2, "mil": _2, "net": _2, "nom": _2, "org": _2 }], "tn": [1, { "com": _2, "ens": _2, "fin": _2, "gov": _2, "ind": _2, "info": _2, "intl": _2, "mincom": _2, "nat": _2, "net": _2, "org": _2, "perso": _2, "tourism": _2, "orangecloud": _3 }], "to": [1, { "611": _3, "com": _2, "gov": _2, "net": _2, "org": _2, "edu": _2, "mil": _2, "oya": _3, "x0": _3, "quickconnect": _23, "vpnplus": _3 }], "tr": [1, { "av": _2, "bbs": _2, "bel": _2, "biz": _2, "com": _8, "dr": _2, "edu": _2, "gen": _2, "gov": _2, "info": _2, "mil": _2, "k12": _2, "kep": _2, "name": _2, "net": _2, "org": _2, "pol": _2, "tel": _2, "tsk": _2, "tv": _2, "web": _2, "nc": _9 }], "tt": [1, { "biz": _2, "co": _2, "com": _2, "edu": _2, "gov": _2, "info": _2, "mil": _2, "name": _2, "net": _2, "org": _2, "pro": _2 }], "tv": [1, { "better-than": _3, "dyndns": _3, "on-the-web": _3, "worse-than": _3, "from": _3, "sakura": _3 }], "tw": [1, { "edu": _2, "gov": _2, "mil": _2, "com": [1, { "mymailer": _3 }], "net": _2, "org": _2, "idv": _2, "game": _2, "ebiz": _2, "club": _2, "xn--zf0ao64a": _2, "": _2, "xn--uc0atv": _2, "": _2, "xn--czrw28b": _2, "": _2, "url": _3, "mydns": _3, "blogspot": _3 }], "tz": [1, { "ac": _2, "co": _2, "go": _2, "hotel": _2, "info": _2, "me": _2, "mil": _2, "mobi": _2, "ne": _2, "or": _2, "sc": _2, "tv": _2 }], "ua": [1, { "com": _2, "edu": _2, "gov": _2, "in": _2, "net": _2, "org": _2, "cherkassy": _2, "cherkasy": _2, "chernigov": _2, "chernihiv": _2, "chernivtsi": _2, "chernovtsy": _2, "ck": _2, "cn": _2, "cr": _2, "crimea": _2, "cv": _2, "dn": _2, "dnepropetrovsk": _2, "dnipropetrovsk": _2, "donetsk": _2, "dp": _2, "if": _2, "ivano-frankivsk": _2, "kh": _2, "kharkiv": _2, "kharkov": _2, "kherson": _2, "khmelnitskiy": _2, "khmelnytskyi": _2, "kiev": _2, "kirovograd": _2, "km": _2, "kr": _2, "kropyvnytskyi": _2, "krym": _2, "ks": _2, "kv": _2, "kyiv": _2, "lg": _2, "lt": _2, "lugansk": _2, "luhansk": _2, "lutsk": _2, "lv": _2, "lviv": _2, "mk": _2, "mykolaiv": _2, "nikolaev": _2, "od": _2, "odesa": _2, "odessa": _2, "pl": _2, "poltava": _2, "rivne": _2, "rovno": _2, "rv": _2, "sb": _2, "sebastopol": _2, "sevastopol": _2, "sm": _2, "sumy": _2, "te": _2, "ternopil": _2, "uz": _2, "uzhgorod": _2, "uzhhorod": _2, "vinnica": _2, "vinnytsia": _2, "vn": _2, "volyn": _2, "yalta": _2, "zakarpattia": _2, "zaporizhzhe": _2, "zaporizhzhia": _2, "zhitomir": _2, "zhytomyr": _2, "zp": _2, "zt": _2, "cc": _3, "inf": _3, "ltd": _3, "cx": _3, "ie": _3, "biz": _3, "co": _3, "pp": _3, "v": _3 }], "ug": [1, { "co": _2, "or": _2, "ac": _2, "sc": _2, "go": _2, "ne": _2, "com": _2, "org": _2, "blogspot": _3 }], "uk": [1, { "ac": _2, "co": [1, { "bytemark": [0, { "dh": _3, "vm": _3 }], "blogspot": _3, "layershift": _43, "barsy": _3, "barsyonline": _3, "retrosnub": _49, "nh-serv": _3, "no-ip": _3, "adimo": _3, "myspreadshop": _3 }], "gov": [1, { "api": _3, "campaign": _3, "service": _3 }], "ltd": _2, "me": _2, "net": _2, "nhs": _2, "org": [1, { "glug": _3, "lug": _3, "lugs": _3, "affinitylottery": _3, "raffleentry": _3, "weeklylottery": _3 }], "plc": _2, "police": _2, "sch": _15, "conn": _3, "copro": _3, "hosp": _3, "independent-commission": _3, "independent-inquest": _3, "independent-inquiry": _3, "independent-panel": _3, "independent-review": _3, "public-inquiry": _3, "royal-commission": _3, "pymnt": _3, "barsy": _3, "nimsite": _3, "oraclegovcloudapps": _5 }], "us": [1, { "dni": _2, "fed": _2, "isa": _2, "kids": _2, "nsn": _2, "ak": _58, "al": _58, "ar": _58, "as": _58, "az": _58, "ca": _58, "co": _58, "ct": _58, "dc": _58, "de": [1, { "cc": _2, "lib": _3 }], "fl": _58, "ga": _58, "gu": _58, "hi": _59, "ia": _58, "id": _58, "il": _58, "in": _58, "ks": _58, "ky": _58, "la": _58, "ma": [1, { "k12": [1, { "pvt": _2, "chtr": _2, "paroch": _2 }], "cc": _2, "lib": _2 }], "md": _58, "me": _58, "mi": [1, { "k12": _2, "cc": _2, "lib": _2, "ann-arbor": _2, "cog": _2, "dst": _2, "eaton": _2, "gen": _2, "mus": _2, "tec": _2, "washtenaw": _2 }], "mn": _58, "mo": _58, "ms": _58, "mt": _58, "nc": _58, "nd": _59, "ne": _58, "nh": _58, "nj": _58, "nm": _58, "nv": _58, "ny": _58, "oh": _58, "ok": _58, "or": _58, "pa": _58, "pr": _58, "ri": _59, "sc": _58, "sd": _59, "tn": _58, "tx": _58, "ut": _58, "vi": _58, "vt": _58, "va": _58, "wa": _58, "wi": _58, "wv": [1, { "cc": _2 }], "wy": _58, "cloudns": _3, "drud": _3, "is-by": _3, "land-4-sale": _3, "stuff-4-sale": _3, "heliohost": _3, "enscaled": [0, { "phx": _3 }], "mircloud": _3, "ngo": _3, "golffan": _3, "noip": _3, "pointto": _3, "freeddns": _3, "srv": [2, { "gh": _3, "gl": _3 }], "platterp": _3, "servername": _3 }], "uy": [1, { "com": _8, "edu": _2, "gub": _2, "mil": _2, "net": _2, "org": _2 }], "uz": [1, { "co": _2, "com": _2, "net": _2, "org": _2 }], "va": _2, "vc": [1, { "com": _2, "net": _2, "org": _2, "gov": _2, "mil": _2, "edu": _2, "gv": [2, { "d": _3 }], "0e": _3, "mydns": _3 }], "ve": [1, { "arts": _2, "bib": _2, "co": _2, "com": _2, "e12": _2, "edu": _2, "firm": _2, "gob": _2, "gov": _2, "info": _2, "int": _2, "mil": _2, "net": _2, "nom": _2, "org": _2, "rar": _2, "rec": _2, "store": _2, "tec": _2, "web": _2 }], "vg": _2, "vi": [1, { "co": _2, "com": _2, "k12": _2, "net": _2, "org": _2 }], "vn": [1, { "ac": _2, "ai": _2, "biz": _2, "com": _2, "edu": _2, "gov": _2, "health": _2, "id": _2, "info": _2, "int": _2, "io": _2, "name": _2, "net": _2, "org": _2, "pro": _2, "angiang": _2, "bacgiang": _2, "backan": _2, "baclieu": _2, "bacninh": _2, "baria-vungtau": _2, "bentre": _2, "binhdinh": _2, "binhduong": _2, "binhphuoc": _2, "binhthuan": _2, "camau": _2, "cantho": _2, "caobang": _2, "daklak": _2, "daknong": _2, "danang": _2, "dienbien": _2, "dongnai": _2, "dongthap": _2, "gialai": _2, "hagiang": _2, "haiduong": _2, "haiphong": _2, "hanam": _2, "hanoi": _2, "hatinh": _2, "haugiang": _2, "hoabinh": _2, "hungyen": _2, "khanhhoa": _2, "kiengiang": _2, "kontum": _2, "laichau": _2, "lamdong": _2, "langson": _2, "laocai": _2, "longan": _2, "namdinh": _2, "nghean": _2, "ninhbinh": _2, "ninhthuan": _2, "phutho": _2, "phuyen": _2, "quangbinh": _2, "quangnam": _2, "quangngai": _2, "quangninh": _2, "quangtri": _2, "soctrang": _2, "sonla": _2, "tayninh": _2, "thaibinh": _2, "thainguyen": _2, "thanhhoa": _2, "thanhphohochiminh": _2, "thuathienhue": _2, "tiengiang": _2, "travinh": _2, "tuyenquang": _2, "vinhlong": _2, "vinhphuc": _2, "yenbai": _2, "blogspot": _3 }], "vu": _42, "wf": [1, { "biz": _3, "sch": _3 }], "ws": [1, { "com": _2, "net": _2, "org": _2, "gov": _2, "edu": _2, "advisor": _5, "cloud66": _3, "dyndns": _3, "mypets": _3 }], "yt": [1, { "org": _3 }], "xn--mgbaam7a8h": _2, "": _2, "xn--y9a3aq": _2, "": _2, "xn--54b7fta0cc": _2, "": _2, "xn--90ae": _2, "": _2, "xn--mgbcpq6gpa1a": _2, "": _2, "xn--90ais": _2, "": _2, "xn--fiqs8s": _2, "": _2, "xn--fiqz9s": _2, "": _2, "xn--lgbbat1ad8j": _2, "": _2, "xn--wgbh1c": _2, "": _2, "xn--e1a4c": _2, "": _2, "xn--qxa6a": _2, "": _2, "xn--mgbah1a3hjkrd": _2, "": _2, "xn--node": _2, "": _2, "xn--qxam": _2, "": _2, "xn--j6w193g": [1, { "xn--55qx5d": _2, "xn--wcvs22d": _2, "xn--mxtq1m": _2, "xn--gmqw5a": _2, "xn--od0alg": _2, "xn--uc0atv": _2 }], "": [1, { "": _2, "": _2, "": _2, "": _2, "": _2, "": _2 }], "xn--2scrj9c": _2, "": _2, "xn--3hcrj9c": _2, "": _2, "xn--45br5cyl": _2, "": _2, "xn--h2breg3eve": _2, "": _2, "xn--h2brj9c8c": _2, "": _2, "xn--mgbgu82a": _2, "": _2, "xn--rvc1e0am3e": _2, "": _2, "xn--h2brj9c": _2, "": _2, "xn--mgbbh1a": _2, "": _2, "xn--mgbbh1a71e": _2, "": _2, "xn--fpcrj9c3d": _2, "": _2, "xn--gecrj9c": _2, "": _2, "xn--s9brj9c": _2, "": _2, "xn--45brj9c": _2, "": _2, "xn--xkc2dl3a5ee0h": _2, "": _2, "xn--mgba3a4f16a": _2, "": _2, "xn--mgba3a4fra": _2, "": _2, "xn--mgbtx2b": _2, "": _2, "xn--mgbayh7gpa": _2, "": _2, "xn--3e0b707e": _2, "": _2, "xn--80ao21a": _2, "": _2, "xn--q7ce6a": _2, "": _2, "xn--fzc2c9e2c": _2, "": _2, "xn--xkc2al3hye2a": _2, "": _2, "xn--mgbc0a9azcg": _2, "": _2, "xn--d1alf": _2, "": _2, "xn--l1acc": _2, "": _2, "xn--mix891f": _2, "": _2, "xn--mix082f": _2, "": _2, "xn--mgbx4cd0ab": _2, "": _2, "xn--mgb9awbf": _2, "": _2, "xn--mgbai9azgqp6j": _2, "": _2, "xn--mgbai9a5eva00b": _2, "": _2, "xn--ygbi2ammx": _2, "": _2, "xn--90a3ac": [1, { "xn--o1ac": _2, "xn--c1avg": _2, "xn--90azh": _2, "xn--d1at": _2, "xn--o1ach": _2, "xn--80au": _2 }], "": [1, { "": _2, "": _2, "": _2, "": _2, "": _2, "": _2 }], "xn--p1ai": _2, "": _2, "xn--wgbl6a": _2, "": _2, "xn--mgberp4a5d4ar": _2, "": _2, "xn--mgberp4a5d4a87g": _2, "": _2, "xn--mgbqly7c0a67fbc": _2, "": _2, "xn--mgbqly7cvafr": _2, "": _2, "xn--mgbpl2fh": _2, "": _2, "xn--yfro4i67o": _2, "": _2, "xn--clchc0ea0b2g2a9gcd": _2, "": _2, "xn--ogbpf8fl": _2, "": _2, "xn--mgbtf8fl": _2, "": _2, "xn--o3cw4h": [1, { "xn--12c1fe0br": _2, "xn--12co0c3b4eva": _2, "xn--h3cuzk1di": _2, "xn--o3cyx2a": _2, "xn--m3ch0j3a": _2, "xn--12cfi8ixb8l": _2 }], "": [1, { "": _2, "": _2, "": _2, "": _2, "": _2, "": _2 }], "xn--pgbs0dh": _2, "": _2, "xn--kpry57d": _2, "": _2, "xn--kprw13d": _2, "": _2, "xn--nnx388a": _2, "": _2, "xn--j1amh": _2, "": _2, "xn--mgb2ddes": _2, "": _2, "xxx": _2, "ye": _50, "za": [0, { "ac": _2, "agric": _2, "alt": _2, "co": _8, "edu": _2, "gov": _2, "grondar": _2, "law": _2, "mil": _2, "net": _2, "ngo": _2, "nic": _2, "nis": _2, "nom": _2, "org": _2, "school": _2, "tm": _2, "web": _2 }], "zm": [1, { "ac": _2, "biz": _2, "co": _2, "com": _2, "edu": _2, "gov": _2, "info": _2, "mil": _2, "net": _2, "org": _2, "sch": _2 }], "zw": [1, { "ac": _2, "co": _2, "gov": _2, "mil": _2, "org": _2 }], "aaa": _2, "aarp": _2, "abb": _2, "abbott": _2, "abbvie": _2, "abc": _2, "able": _2, "abogado": _2, "abudhabi": _2, "academy": [1, { "official": _3 }], "accenture": _2, "accountant": _2, "accountants": _2, "aco": _2, "actor": _2, "ads": _2, "adult": _2, "aeg": _2, "aetna": _2, "afl": _2, "africa": _2, "agakhan": _2, "agency": _2, "aig": _2, "airbus": _2, "airforce": _2, "airtel": _2, "akdn": _2, "alibaba": _2, "alipay": _2, "allfinanz": _2, "allstate": _2, "ally": _2, "alsace": _2, "alstom": _2, "amazon": _2, "americanexpress": _2, "americanfamily": _2, "amex": _2, "amfam": _2, "amica": _2, "amsterdam": _2, "analytics": _2, "android": _2, "anquan": _2, "anz": _2, "aol": _2, "apartments": _2, "app": [1, { "adaptable": _3, "beget": _5, "clerk": _3, "clerkstage": _3, "wnext": _3, "csb": [2, { "preview": _3 }], "platform0": _3, "deta": _3, "ondigitalocean": _3, "easypanel": _3, "encr": _3, "evervault": _6, "expo": [2, { "staging": _3 }], "edgecompute": _3, "flutterflow": _3, "framer": _3, "hosted": _5, "run": _5, "web": _3, "hasura": _3, "loginline": _3, "medusajs": _3, "messerli": _3, "netfy": _3, "netlify": _3, "ngrok": _3, "ngrok-free": _3, "developer": _5, "noop": _3, "northflank": _5, "upsun": _5, "replit": _7, "nyat": _3, "snowflake": [0, { "*": _3, "privatelink": _5 }], "streamlit": _3, "storipress": _3, "telebit": _3, "typedream": _3, "vercel": _3, "bookonline": _3, "wdh": _3, "zeabur": _3 }], "apple": _2, "aquarelle": _2, "arab": _2, "aramco": _2, "archi": _2, "army": _2, "art": _2, "arte": _2, "asda": _2, "associates": _2, "athleta": _2, "attorney": _2, "auction": _2, "audi": _2, "audible": _2, "audio": _2, "auspost": _2, "author": _2, "auto": _2, "autos": _2, "aws": [1, { "sagemaker": [0, { "ap-northeast-1": _11, "ap-northeast-2": _11, "ap-south-1": _11, "ap-southeast-1": _11, "ap-southeast-2": _11, "ca-central-1": _13, "eu-central-1": _11, "eu-west-1": _11, "eu-west-2": _11, "us-east-1": _13, "us-east-2": _13, "us-west-2": _13, "af-south-1": _10, "ap-east-1": _10, "ap-northeast-3": _10, "ap-south-2": _12, "ap-southeast-3": _10, "ap-southeast-4": _12, "ca-west-1": [0, { "notebook": _3, "notebook-fips": _3 }], "eu-central-2": _12, "eu-north-1": _10, "eu-south-1": _10, "eu-south-2": _10, "eu-west-3": _10, "il-central-1": _10, "me-central-1": _10, "me-south-1": _10, "sa-east-1": _10, "us-gov-east-1": _14, "us-gov-west-1": _14, "us-west-1": [0, { "notebook": _3, "notebook-fips": _3, "studio": _3 }], "experiments": _5 }], "repost": [0, { "private": _5 }] }], "axa": _2, "azure": _2, "baby": _2, "baidu": _2, "banamex": _2, "band": _2, "bank": _2, "bar": _2, "barcelona": _2, "barclaycard": _2, "barclays": _2, "barefoot": _2, "bargains": _2, "baseball": _2, "basketball": [1, { "aus": _3, "nz": _3 }], "bauhaus": _2, "bayern": _2, "bbc": _2, "bbt": _2, "bbva": _2, "bcg": _2, "bcn": _2, "beats": _2, "beauty": _2, "beer": _2, "bentley": _2, "berlin": _2, "best": _2, "bestbuy": _2, "bet": _2, "bharti": _2, "bible": _2, "bid": _2, "bike": _2, "bing": _2, "bingo": _2, "bio": _2, "black": _2, "blackfriday": _2, "blockbuster": _2, "blog": _2, "bloomberg": _2, "blue": _2, "bms": _2, "bmw": _2, "bnpparibas": _2, "boats": _2, "boehringer": _2, "bofa": _2, "bom": _2, "bond": _2, "boo": _2, "book": _2, "booking": _2, "bosch": _2, "bostik": _2, "boston": _2, "bot": _2, "boutique": _2, "box": _2, "bradesco": _2, "bridgestone": _2, "broadway": _2, "broker": _2, "brother": _2, "brussels": _2, "build": [1, { "v0": _3 }], "builders": [1, { "cloudsite": _3 }], "business": _17, "buy": _2, "buzz": _2, "bzh": _2, "cab": _2, "cafe": _2, "cal": _2, "call": _2, "calvinklein": _2, "cam": _2, "camera": _2, "camp": [1, { "emf": [0, { "at": _3 }] }], "canon": _2, "capetown": _2, "capital": _2, "capitalone": _2, "car": _2, "caravan": _2, "cards": _2, "care": _2, "career": _2, "careers": _2, "cars": _2, "casa": [1, { "nabu": [0, { "ui": _3 }] }], "case": _2, "cash": _2, "casino": _2, "catering": _2, "catholic": _2, "cba": _2, "cbn": _2, "cbre": _2, "center": _2, "ceo": _2, "cern": _2, "cfa": _2, "cfd": _2, "chanel": _2, "channel": _2, "charity": _2, "chase": _2, "chat": _2, "cheap": _2, "chintai": _2, "christmas": _2, "chrome": _2, "church": _2, "cipriani": _2, "circle": _2, "cisco": _2, "citadel": _2, "citi": _2, "citic": _2, "city": _2, "claims": _2, "cleaning": _2, "click": _2, "clinic": _2, "clinique": _2, "clothing": _2, "cloud": [1, { "elementor": _3, "encoway": [0, { "eu": _3 }], "statics": _5, "ravendb": _3, "axarnet": [0, { "es-1": _3 }], "diadem": _3, "jelastic": [0, { "vip": _3 }], "jele": _3, "jenv-aruba": [0, { "aruba": [0, { "eur": [0, { "it1": _3 }] }], "it1": _3 }], "keliweb": [2, { "cs": _3 }], "oxa": [2, { "tn": _3, "uk": _3 }], "primetel": [2, { "uk": _3 }], "reclaim": [0, { "ca": _3, "uk": _3, "us": _3 }], "trendhosting": [0, { "ch": _3, "de": _3 }], "jotelulu": _3, "kuleuven": _3, "linkyard": _3, "magentosite": _5, "matlab": _3, "observablehq": _3, "perspecta": _3, "vapor": _3, "on-rancher": _5, "scw": [0, { "baremetal": [0, { "fr-par-1": _3, "fr-par-2": _3, "nl-ams-1": _3 }], "fr-par": [0, { "cockpit": _3, "fnc": [2, { "functions": _3 }], "k8s": _19, "s3": _3, "s3-website": _3, "whm": _3 }], "instances": [0, { "priv": _3, "pub": _3 }], "k8s": _3, "nl-ams": [0, { "cockpit": _3, "k8s": _19, "s3": _3, "s3-website": _3, "whm": _3 }], "pl-waw": [0, { "cockpit": _3, "k8s": _19, "s3": _3, "s3-website": _3 }], "scalebook": _3, "smartlabeling": _3 }], "servebolt": _3, "onstackit": [0, { "runs": _3 }], "trafficplex": _3, "unison-services": _3, "urown": _3, "voorloper": _3, "zap": _3 }], "club": [1, { "cloudns": _3, "jele": _3, "barsy": _3 }], "clubmed": _2, "coach": _2, "codes": [1, { "owo": _5 }], "coffee": _2, "college": _2, "cologne": _2, "commbank": _2, "community": [1, { "nog": _3, "ravendb": _3, "myforum": _3 }], "company": _2, "compare": _2, "computer": _2, "comsec": _2, "condos": _2, "construction": _2, "consulting": _2, "contact": _2, "contractors": _2, "cooking": _2, "cool": [1, { "elementor": _3, "de": _3 }], "corsica": _2, "country": _2, "coupon": _2, "coupons": _2, "courses": _2, "cpa": _2, "credit": _2, "creditcard": _2, "creditunion": _2, "cricket": _2, "crown": _2, "crs": _2, "cruise": _2, "cruises": _2, "cuisinella": _2, "cymru": _2, "cyou": _2, "dad": _2, "dance": _2, "data": _2, "date": _2, "dating": _2, "datsun": _2, "day": _2, "dclk": _2, "dds": _2, "deal": _2, "dealer": _2, "deals": _2, "degree": _2, "delivery": _2, "dell": _2, "deloitte": _2, "delta": _2, "democrat": _2, "dental": _2, "dentist": _2, "desi": _2, "design": [1, { "graphic": _3, "bss": _3 }], "dev": [1, { "12chars": _3, "panel": _3, "lcl": _5, "lclstage": _5, "stg": _5, "stgstage": _5, "pages": _3, "r2": _3, "workers": _3, "curv": _3, "deno": _3, "deno-staging": _3, "deta": _3, "evervault": _6, "fly": _3, "githubpreview": _3, "gateway": _5, "hrsn": _3, "is-a-good": _3, "is-a": _3, "iserv": _3, "runcontainers": _3, "localcert": [0, { "user": _5 }], "loginline": _3, "barsy": _3, "mediatech": _3, "modx": _3, "ngrok": _3, "ngrok-free": _3, "is-a-fullstack": _3, "is-cool": _3, "is-not-a": _3, "localplayer": _3, "xmit": _3, "platter-app": _3, "replit": [2, { "archer": _3, "bones": _3, "canary": _3, "global": _3, "hacker": _3, "id": _3, "janeway": _3, "kim": _3, "kira": _3, "kirk": _3, "odo": _3, "paris": _3, "picard": _3, "pike": _3, "prerelease": _3, "reed": _3, "riker": _3, "sisko": _3, "spock": _3, "staging": _3, "sulu": _3, "tarpit": _3, "teams": _3, "tucker": _3, "wesley": _3, "worf": _3 }], "crm": [0, { "d": _5, "w": _5, "wa": _5, "wb": _5, "wc": _5, "wd": _5, "we": _5, "wf": _5 }], "vercel": _3, "webhare": _5 }], "dhl": _2, "diamonds": _2, "diet": _2, "digital": [1, { "cloudapps": [2, { "london": _3 }] }], "direct": [1, { "libp2p": _3 }], "directory": _2, "discount": _2, "discover": _2, "dish": _2, "diy": _2, "dnp": _2, "docs": _2, "doctor": _2, "dog": _2, "domains": _2, "dot": _2, "download": _2, "drive": _2, "dtv": _2, "dubai": _2, "dunlop": _2, "dupont": _2, "durban": _2, "dvag": _2, "dvr": _2, "earth": _2, "eat": _2, "eco": _2, "edeka": _2, "education": _17, "email": [1, { "crisp": [0, { "on": _3 }], "tawk": _45, "tawkto": _45 }], "emerck": _2, "energy": _2, "engineer": _2, "engineering": _2, "enterprises": _2, "epson": _2, "equipment": _2, "ericsson": _2, "erni": _2, "esq": _2, "estate": [1, { "compute": _5 }], "eurovision": _2, "eus": [1, { "party": _46 }], "events": [1, { "koobin": _3, "co": _3 }], "exchange": _2, "expert": _2, "exposed": _2, "express": _2, "extraspace": _2, "fage": _2, "fail": _2, "fairwinds": _2, "faith": _2, "family": _2, "fan": _2, "fans": _2, "farm": [1, { "storj": _3 }], "farmers": _2, "fashion": _2, "fast": _2, "fedex": _2, "feedback": _2, "ferrari": _2, "ferrero": _2, "fidelity": _2, "fido": _2, "film": _2, "final": _2, "finance": _2, "financial": _17, "fire": _2, "firestone": _2, "firmdale": _2, "fish": _2, "fishing": _2, "fit": _2, "fitness": _2, "flickr": _2, "flights": _2, "flir": _2, "florist": _2, "flowers": _2, "fly": _2, "foo": _2, "food": _2, "football": _2, "ford": _2, "forex": _2, "forsale": _2, "forum": _2, "foundation": _2, "fox": _2, "free": _2, "fresenius": _2, "frl": _2, "frogans": _2, "frontier": _2, "ftr": _2, "fujitsu": _2, "fun": _2, "fund": _2, "furniture": _2, "futbol": _2, "fyi": _2, "gal": _2, "gallery": _2, "gallo": _2, "gallup": _2, "game": _2, "games": [1, { "pley": _3, "sheezy": _3 }], "gap": _2, "garden": _2, "gay": [1, { "pages": _3 }], "gbiz": _2, "gdn": [1, { "cnpy": _3 }], "gea": _2, "gent": _2, "genting": _2, "george": _2, "ggee": _2, "gift": _2, "gifts": _2, "gives": _2, "giving": _2, "glass": _2, "gle": _2, "global": _2, "globo": _2, "gmail": _2, "gmbh": _2, "gmo": _2, "gmx": _2, "godaddy": _2, "gold": _2, "goldpoint": _2, "golf": _2, "goo": _2, "goodyear": _2, "goog": [1, { "cloud": _3, "translate": _3, "usercontent": _5 }], "google": _2, "gop": _2, "got": _2, "grainger": _2, "graphics": _2, "gratis": _2, "green": _2, "gripe": _2, "grocery": _2, "group": [1, { "discourse": _3 }], "gucci": _2, "guge": _2, "guide": _2, "guitars": _2, "guru": _2, "hair": _2, "hamburg": _2, "hangout": _2, "haus": _2, "hbo": _2, "hdfc": _2, "hdfcbank": _2, "health": [1, { "hra": _3 }], "healthcare": _2, "help": _2, "helsinki": _2, "here": _2, "hermes": _2, "hiphop": _2, "hisamitsu": _2, "hitachi": _2, "hiv": _2, "hkt": _2, "hockey": _2, "holdings": _2, "holiday": _2, "homedepot": _2, "homegoods": _2, "homes": _2, "homesense": _2, "honda": _2, "horse": _2, "hospital": _2, "host": [1, { "cloudaccess": _3, "freesite": _3, "easypanel": _3, "fastvps": _3, "myfast": _3, "tempurl": _3, "wpmudev": _3, "jele": _3, "mircloud": _3, "wp2": _3, "half": _3 }], "hosting": [1, { "opencraft": _3 }], "hot": _2, "hotels": _2, "hotmail": _2, "house": _2, "how": _2, "hsbc": _2, "hughes": _2, "hyatt": _2, "hyundai": _2, "ibm": _2, "icbc": _2, "ice": _2, "icu": _2, "ieee": _2, "ifm": _2, "ikano": _2, "imamat": _2, "imdb": _2, "immo": _2, "immobilien": _2, "inc": _2, "industries": _2, "infiniti": _2, "ing": _2, "ink": _2, "institute": _2, "insurance": _2, "insure": _2, "international": _2, "intuit": _2, "investments": _2, "ipiranga": _2, "irish": _2, "ismaili": _2, "ist": _2, "istanbul": _2, "itau": _2, "itv": _2, "jaguar": _2, "java": _2, "jcb": _2, "jeep": _2, "jetzt": _2, "jewelry": _2, "jio": _2, "jll": _2, "jmp": _2, "jnj": _2, "joburg": _2, "jot": _2, "joy": _2, "jpmorgan": _2, "jprs": _2, "juegos": _2, "juniper": _2, "kaufen": _2, "kddi": _2, "kerryhotels": _2, "kerrylogistics": _2, "kerryproperties": _2, "kfh": _2, "kia": _2, "kids": _2, "kim": _2, "kindle": _2, "kitchen": _2, "kiwi": _2, "koeln": _2, "komatsu": _2, "kosher": _2, "kpmg": _2, "kpn": _2, "krd": [1, { "co": _3, "edu": _3 }], "kred": _2, "kuokgroup": _2, "kyoto": _2, "lacaixa": _2, "lamborghini": _2, "lamer": _2, "lancaster": _2, "land": _2, "landrover": _2, "lanxess": _2, "lasalle": _2, "lat": _2, "latino": _2, "latrobe": _2, "law": _2, "lawyer": _2, "lds": _2, "lease": _2, "leclerc": _2, "lefrak": _2, "legal": _2, "lego": _2, "lexus": _2, "lgbt": _2, "lidl": _2, "life": _2, "lifeinsurance": _2, "lifestyle": _2, "lighting": _2, "like": _2, "lilly": _2, "limited": _2, "limo": _2, "lincoln": _2, "link": [1, { "myfritz": _3, "cyon": _3, "dweb": _5, "nftstorage": [0, { "ipfs": _3 }], "mypep": _3 }], "lipsy": _2, "live": [1, { "aem": _3, "hlx": _3, "ewp": _5 }], "living": _2, "llc": _2, "llp": _2, "loan": _2, "loans": _2, "locker": _2, "locus": _2, "lol": [1, { "omg": _3 }], "london": _2, "lotte": _2, "lotto": _2, "love": _2, "lpl": _2, "lplfinancial": _2, "ltd": _2, "ltda": _2, "lundbeck": _2, "luxe": _2, "luxury": _2, "madrid": _2, "maif": _2, "maison": _2, "makeup": _2, "man": _2, "management": [1, { "router": _3 }], "mango": _2, "map": _2, "market": _2, "marketing": _2, "markets": _2, "marriott": _2, "marshalls": _2, "mattel": _2, "mba": _2, "mckinsey": _2, "med": _2, "media": _53, "meet": _2, "melbourne": _2, "meme": _2, "memorial": _2, "men": _2, "menu": [1, { "barsy": _3, "barsyonline": _3 }], "merck": _2, "merckmsd": _2, "miami": _2, "microsoft": _2, "mini": _2, "mint": _2, "mit": _2, "mitsubishi": _2, "mlb": _2, "mls": _2, "mma": _2, "mobile": _2, "moda": _2, "moe": _2, "moi": _2, "mom": [1, { "ind": _3 }], "monash": _2, "money": _2, "monster": _2, "mormon": _2, "mortgage": _2, "moscow": _2, "moto": _2, "motorcycles": _2, "mov": _2, "movie": _2, "msd": _2, "mtn": _2, "mtr": _2, "music": _2, "nab": _2, "nagoya": _2, "navy": _2, "nba": _2, "nec": _2, "netbank": _2, "netflix": _2, "network": [1, { "alces": _5, "co": _3, "arvo": _3, "azimuth": _3, "tlon": _3 }], "neustar": _2, "new": _2, "news": [1, { "noticeable": _3 }], "next": _2, "nextdirect": _2, "nexus": _2, "nfl": _2, "ngo": _2, "nhk": _2, "nico": _2, "nike": _2, "nikon": _2, "ninja": _2, "nissan": _2, "nissay": _2, "nokia": _2, "norton": _2, "now": _2, "nowruz": _2, "nowtv": _2, "nra": _2, "nrw": _2, "ntt": _2, "nyc": _2, "obi": _2, "observer": _2, "office": _2, "okinawa": _2, "olayan": _2, "olayangroup": _2, "ollo": _2, "omega": _2, "one": [1, { "kin": _5, "service": _3 }], "ong": [1, { "obl": _3 }], "onl": _2, "online": [1, { "eero": _3, "eero-stage": _3, "websitebuilder": _3, "barsy": _3 }], "ooo": _2, "open": _2, "oracle": _2, "orange": [1, { "tech": _3 }], "organic": _2, "origins": _2, "osaka": _2, "otsuka": _2, "ott": _2, "ovh": [1, { "nerdpol": _3 }], "page": [1, { "aem": _3, "hlx": _3, "hlx3": _3, "translated": _3, "codeberg": _3, "heyflow": _3, "prvcy": _3, "rocky": _3, "pdns": _3, "plesk": _3 }], "panasonic": _2, "paris": _2, "pars": _2, "partners": _2, "parts": _2, "party": _2, "pay": _2, "pccw": _2, "pet": _2, "pfizer": _2, "pharmacy": _2, "phd": _2, "philips": _2, "phone": _2, "photo": _2, "photography": _2, "photos": _53, "physio": _2, "pics": _2, "pictet": _2, "pictures": [1, { "1337": _3 }], "pid": _2, "pin": _2, "ping": _2, "pink": _2, "pioneer": _2, "pizza": [1, { "ngrok": _3 }], "place": _17, "play": _2, "playstation": _2, "plumbing": _2, "plus": _2, "pnc": _2, "pohl": _2, "poker": _2, "politie": _2, "porn": _2, "pramerica": _2, "praxi": _2, "press": _2, "prime": _2, "prod": _2, "productions": _2, "prof": _2, "progressive": _2, "promo": _2, "properties": _2, "property": _2, "protection": _2, "pru": _2, "prudential": _2, "pub": [1, { "id": _5, "kin": _5, "barsy": _3 }], "pwc": _2, "qpon": _2, "quebec": _2, "quest": _2, "racing": _2, "radio": _2, "read": _2, "realestate": _2, "realtor": _2, "realty": _2, "recipes": _2, "red": _2, "redstone": _2, "redumbrella": _2, "rehab": _2, "reise": _2, "reisen": _2, "reit": _2, "reliance": _2, "ren": _2, "rent": _2, "rentals": _2, "repair": _2, "report": _2, "republican": _2, "rest": _2, "restaurant": _2, "review": _2, "reviews": _2, "rexroth": _2, "rich": _2, "richardli": _2, "ricoh": _2, "ril": _2, "rio": _2, "rip": [1, { "clan": _3 }], "rocks": [1, { "myddns": _3, "stackit": _3, "lima-city": _3, "webspace": _3 }], "rodeo": _2, "rogers": _2, "room": _2, "rsvp": _2, "rugby": _2, "ruhr": _2, "run": [1, { "development": _3, "ravendb": _3, "servers": _3, "build": _5, "code": _5, "database": _5, "migration": _5, "onporter": _3, "repl": _3, "stackit": _3, "val": [0, { "express": _3, "web": _3 }], "wix": _3 }], "rwe": _2, "ryukyu": _2, "saarland": _2, "safe": _2, "safety": _2, "sakura": _2, "sale": _2, "salon": _2, "samsclub": _2, "samsung": _2, "sandvik": _2, "sandvikcoromant": _2, "sanofi": _2, "sap": _2, "sarl": _2, "sas": _2, "save": _2, "saxo": _2, "sbi": _2, "sbs": _2, "scb": _2, "schaeffler": _2, "schmidt": _2, "scholarships": _2, "school": _2, "schule": _2, "schwarz": _2, "science": _2, "scot": [1, { "gov": [2, { "service": _3 }] }], "search": _2, "seat": _2, "secure": _2, "security": _2, "seek": _2, "select": _2, "sener": _2, "services": [1, { "loginline": _3 }], "seven": _2, "sew": _2, "sex": _2, "sexy": _2, "sfr": _2, "shangrila": _2, "sharp": _2, "shell": _2, "shia": _2, "shiksha": _2, "shoes": _2, "shop": [1, { "base": _3, "hoplix": _3, "barsy": _3, "barsyonline": _3, "shopware": _3 }], "shopping": _2, "shouji": _2, "show": _2, "silk": _2, "sina": _2, "singles": _2, "site": [1, { "canva": _20, "cloudera": _5, "convex": _3, "cyon": _3, "fnwk": _3, "folionetwork": _3, "fastvps": _3, "heyflow": _3, "jele": _3, "jouwweb": _3, "lelux": _3, "loginline": _3, "barsy": _3, "notion": _3, "omniwe": _3, "opensocial": _3, "madethis": _3, "platformsh": _5, "tst": _5, "byen": _3, "srht": _3, "novecore": _3, "wpsquared": _3 }], "ski": _2, "skin": _2, "sky": _2, "skype": _2, "sling": _2, "smart": _2, "smile": _2, "sncf": _2, "soccer": _2, "social": _2, "softbank": _2, "software": _2, "sohu": _2, "solar": _2, "solutions": [1, { "diher": _3 }], "song": _2, "sony": _2, "soy": _2, "spa": _2, "space": [1, { "myfast": _3, "heiyu": _3, "hf": [2, { "static": _3 }], "app-ionos": _3, "project": _3, "uber": _3, "xs4all": _3 }], "sport": _2, "spot": _2, "srl": _2, "stada": _2, "staples": _2, "star": _2, "statebank": _2, "statefarm": _2, "stc": _2, "stcgroup": _2, "stockholm": _2, "storage": _2, "store": [1, { "barsy": _3, "sellfy": _3, "shopware": _3, "storebase": _3 }], "stream": _2, "studio": _2, "study": _2, "style": _2, "sucks": _2, "supplies": _2, "supply": _2, "support": [1, { "barsy": _3 }], "surf": _2, "surgery": _2, "suzuki": _2, "swatch": _2, "swiss": _2, "sydney": _2, "systems": [1, { "knightpoint": _3 }], "tab": _2, "taipei": _2, "talk": _2, "taobao": _2, "target": _2, "tatamotors": _2, "tatar": _2, "tattoo": _2, "tax": _2, "taxi": _2, "tci": _2, "tdk": _2, "team": [1, { "discourse": _3, "jelastic": _3 }], "tech": [1, { "cleverapps": _3 }], "technology": _17, "temasek": _2, "tennis": _2, "teva": _2, "thd": _2, "theater": _2, "theatre": _2, "tiaa": _2, "tickets": _2, "tienda": _2, "tips": _2, "tires": _2, "tirol": _2, "tjmaxx": _2, "tjx": _2, "tkmaxx": _2, "tmall": _2, "today": [1, { "prequalifyme": _3 }], "tokyo": _2, "tools": _2, "top": [1, { "now-dns": _3, "ntdll": _3, "wadl": _5 }], "toray": _2, "toshiba": _2, "total": _2, "tours": _2, "town": _2, "toyota": _2, "toys": _2, "trade": _2, "trading": _2, "training": _2, "travel": _2, "travelers": _2, "travelersinsurance": _2, "trust": _2, "trv": _2, "tube": _2, "tui": _2, "tunes": _2, "tushu": _2, "tvs": _2, "ubank": _2, "ubs": _2, "unicom": _2, "university": _2, "uno": _2, "uol": _2, "ups": _2, "vacations": _2, "vana": _2, "vanguard": _2, "vegas": _2, "ventures": _2, "verisign": _2, "versicherung": _2, "vet": _2, "viajes": _2, "video": _2, "vig": _2, "viking": _2, "villas": _2, "vin": _2, "vip": _2, "virgin": _2, "visa": _2, "vision": _2, "viva": _2, "vivo": _2, "vlaanderen": _2, "vodka": [1, { "aaa": _3 }], "volvo": _2, "vote": _2, "voting": _2, "voto": _2, "voyage": _2, "wales": _2, "walmart": _2, "walter": _2, "wang": _2, "wanggou": _2, "watch": _2, "watches": _2, "weather": _2, "weatherchannel": _2, "webcam": _2, "weber": _2, "website": _53, "wed": _2, "wedding": _2, "weibo": _2, "weir": _2, "whoswho": _2, "wien": _2, "wiki": _53, "williamhill": _2, "win": _2, "windows": _2, "wine": _2, "winners": _2, "wme": _2, "wolterskluwer": _2, "woodside": _2, "work": _2, "works": _2, "world": _2, "wow": _2, "wtc": _2, "wtf": _2, "xbox": _2, "xerox": _2, "xihuan": _2, "xin": _2, "xn--11b4c3d": _2, "": _2, "xn--1ck2e1b": _2, "": _2, "xn--1qqw23a": _2, "": _2, "xn--30rr7y": _2, "": _2, "xn--3bst00m": _2, "": _2, "xn--3ds443g": _2, "": _2, "xn--3pxu8k": _2, "": _2, "xn--42c2d9a": _2, "": _2, "xn--45q11c": _2, "": _2, "xn--4gbrim": _2, "": _2, "xn--55qw42g": _2, "": _2, "xn--55qx5d": _2, "": _2, "xn--5su34j936bgsg": _2, "": _2, "xn--5tzm5g": _2, "": _2, "xn--6frz82g": _2, "": _2, "xn--6qq986b3xl": _2, "": _2, "xn--80adxhks": _2, "": _2, "xn--80aqecdr1a": _2, "": _2, "xn--80asehdb": _2, "": _2, "xn--80aswg": _2, "": _2, "xn--8y0a063a": _2, "": _2, "xn--9dbq2a": _2, "": _2, "xn--9et52u": _2, "": _2, "xn--9krt00a": _2, "": _2, "xn--b4w605ferd": _2, "": _2, "xn--bck1b9a5dre4c": _2, "": _2, "xn--c1avg": _2, "": _2, "xn--c2br7g": _2, "": _2, "xn--cck2b3b": _2, "": _2, "xn--cckwcxetd": _2, "": _2, "xn--cg4bki": _2, "": _2, "xn--czr694b": _2, "": _2, "xn--czrs0t": _2, "": _2, "xn--czru2d": _2, "": _2, "xn--d1acj3b": _2, "": _2, "xn--eckvdtc9d": _2, "": _2, "xn--efvy88h": _2, "": _2, "xn--fct429k": _2, "": _2, "xn--fhbei": _2, "": _2, "xn--fiq228c5hs": _2, "": _2, "xn--fiq64b": _2, "": _2, "xn--fjq720a": _2, "": _2, "xn--flw351e": _2, "": _2, "xn--fzys8d69uvgm": _2, "": _2, "xn--g2xx48c": _2, "": _2, "xn--gckr3f0f": _2, "": _2, "xn--gk3at1e": _2, "": _2, "xn--hxt814e": _2, "": _2, "xn--i1b6b1a6a2e": _2, "": _2, "xn--imr513n": _2, "": _2, "xn--io0a7i": _2, "": _2, "xn--j1aef": _2, "": _2, "xn--jlq480n2rg": _2, "": _2, "xn--jvr189m": _2, "": _2, "xn--kcrx77d1x4a": _2, "": _2, "xn--kput3i": _2, "": _2, "xn--mgba3a3ejt": _2, "": _2, "xn--mgba7c0bbn0a": _2, "": _2, "xn--mgbab2bd": _2, "": _2, "xn--mgbca7dzdo": _2, "": _2, "xn--mgbi4ecexp": _2, "": _2, "xn--mgbt3dhd": _2, "": _2, "xn--mk1bu44c": _2, "": _2, "xn--mxtq1m": _2, "": _2, "xn--ngbc5azd": _2, "": _2, "xn--ngbe9e0a": _2, "": _2, "xn--ngbrx": _2, "": _2, "xn--nqv7f": _2, "": _2, "xn--nqv7fs00ema": _2, "": _2, "xn--nyqy26a": _2, "": _2, "xn--otu796d": _2, "": _2, "xn--p1acf": [1, { "xn--90amc": _3, "xn--j1aef": _3, "xn--j1ael8b": _3, "xn--h1ahn": _3, "xn--j1adp": _3, "xn--c1avg": _3, "xn--80aaa0cvac": _3, "xn--h1aliz": _3, "xn--90a1af": _3, "xn--41a": _3 }], "": [1, { "": _3, "": _3, "": _3, "": _3, "": _3, "": _3, "": _3, "": _3, "": _3, "": _3 }], "xn--pssy2u": _2, "": _2, "xn--q9jyb4c": _2, "": _2, "xn--qcka1pmc": _2, "": _2, "xn--rhqv96g": _2, "": _2, "xn--rovu88b": _2, "": _2, "xn--ses554g": _2, "": _2, "xn--t60b56a": _2, "": _2, "xn--tckwe": _2, "": _2, "xn--tiq49xqyj": _2, "": _2, "xn--unup4y": _2, "": _2, "xn--vermgensberater-ctb": _2, "vermgensberater": _2, "xn--vermgensberatung-pwb": _2, "vermgensberatung": _2, "xn--vhquv": _2, "": _2, "xn--vuq861b": _2, "": _2, "xn--w4r85el8fhu5dnra": _2, "": _2, "xn--w4rs40l": _2, "": _2, "xn--xhq521b": _2, "": _2, "xn--zfr164b": _2, "": _2, "xyz": [1, { "telebit": _5 }], "yachts": _2, "yahoo": _2, "yamaxun": _2, "yandex": _2, "yodobashi": _2, "yoga": _2, "yokohama": _2, "you": _2, "youtube": _2, "yun": _2, "zappos": _2, "zara": _2, "zero": _2, "zip": _2, "zone": [1, { "cloud66": _3, "triton": _5, "stackit": _3, "lima": _3 }], "zuerich": _2 }];
    return rules;
})();

/**
 * Lookup parts of domain in Trie
 */
function lookupInTrie(parts, trie, index, allowedMask) {
    let result = null;
    let node = trie;
    while (node !== undefined) {
        // We have a match!
        if ((node[0] & allowedMask) !== 0) {
            result = {
                index: index + 1,
                isIcann: node[0] === 1 /* RULE_TYPE.ICANN */,
                isPrivate: node[0] === 2 /* RULE_TYPE.PRIVATE */,
            };
        }
        // No more `parts` to look for
        if (index === -1) {
            break;
        }
        const succ = node[1];
        node = Object.prototype.hasOwnProperty.call(succ, parts[index])
            ? succ[parts[index]]
            : succ['*'];
        index -= 1;
    }
    return result;
}
/**
 * Check if `hostname` has a valid public suffix in `trie`.
 */
function suffixLookup(hostname, options, out) {
    var _a;
    if (fastPathLookup(hostname, options, out)) {
        return;
    }
    const hostnameParts = hostname.split('.');
    const allowedMask = (options.allowPrivateDomains ? 2 /* RULE_TYPE.PRIVATE */ : 0) |
        (options.allowIcannDomains ? 1 /* RULE_TYPE.ICANN */ : 0);
    // Look for exceptions
    const exceptionMatch = lookupInTrie(hostnameParts, exceptions, hostnameParts.length - 1, allowedMask);
    if (exceptionMatch !== null) {
        out.isIcann = exceptionMatch.isIcann;
        out.isPrivate = exceptionMatch.isPrivate;
        out.publicSuffix = hostnameParts.slice(exceptionMatch.index + 1).join('.');
        return;
    }
    // Look for a match in rules
    const rulesMatch = lookupInTrie(hostnameParts, rules, hostnameParts.length - 1, allowedMask);
    if (rulesMatch !== null) {
        out.isIcann = rulesMatch.isIcann;
        out.isPrivate = rulesMatch.isPrivate;
        out.publicSuffix = hostnameParts.slice(rulesMatch.index).join('.');
        return;
    }
    // No match found...
    // Prevailing rule is '*' so we consider the top-level domain to be the
    // public suffix of `hostname` (e.g.: 'example.org' => 'org').
    out.isIcann = false;
    out.isPrivate = false;
    out.publicSuffix = (_a = hostnameParts[hostnameParts.length - 1]) !== null && _a !== void 0 ? _a : null;
}

// For all methods but 'parse', it does not make sense to allocate an object
// every single time to only return the value of a specific attribute. To avoid
// this un-necessary allocation, we use a global object which is re-used.
const RESULT = getEmptyResult();
function parse(url, options = {}) {
    return parseImpl(url, 5 /* FLAG.ALL */, suffixLookup, options, getEmptyResult());
}
function getHostname(url, options = {}) {
    /*@__INLINE__*/ resetResult(RESULT);
    return parseImpl(url, 0 /* FLAG.HOSTNAME */, suffixLookup, options, RESULT).hostname;
}
function getPublicSuffix(url, options = {}) {
    /*@__INLINE__*/ resetResult(RESULT);
    return parseImpl(url, 2 /* FLAG.PUBLIC_SUFFIX */, suffixLookup, options, RESULT)
        .publicSuffix;
}
function getDomain(url, options = {}) {
    /*@__INLINE__*/ resetResult(RESULT);
    return parseImpl(url, 3 /* FLAG.DOMAIN */, suffixLookup, options, RESULT).domain;
}
function getSubdomain(url, options = {}) {
    /*@__INLINE__*/ resetResult(RESULT);
    return parseImpl(url, 4 /* FLAG.SUB_DOMAIN */, suffixLookup, options, RESULT)
        .subdomain;
}
function getDomainWithoutSuffix(url, options = {}) {
    /*@__INLINE__*/ resetResult(RESULT);
    return parseImpl(url, 5 /* FLAG.ALL */, suffixLookup, options, RESULT)
        .domainWithoutSuffix;
}

var es6 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    getDomain: getDomain,
    getDomainWithoutSuffix: getDomainWithoutSuffix,
    getHostname: getHostname,
    getPublicSuffix: getPublicSuffix,
    getSubdomain: getSubdomain,
    parse: parse
});

var require$$0 = /*@__PURE__*/getAugmentedNamespace(es6);

var hasRequiredGetPublicSuffix;

function requireGetPublicSuffix () {
	if (hasRequiredGetPublicSuffix) return getPublicSuffix$1;
	hasRequiredGetPublicSuffix = 1;
	Object.defineProperty(getPublicSuffix$1, "__esModule", { value: true });
	getPublicSuffix$1.getPublicSuffix = getPublicSuffix;
	const tldts_1 = require$$0;
	// RFC 6761
	const SPECIAL_USE_DOMAINS = ['local', 'example', 'invalid', 'localhost', 'test'];
	const SPECIAL_TREATMENT_DOMAINS = ['localhost', 'invalid'];
	const defaultGetPublicSuffixOptions = {
	    allowSpecialUseDomain: false,
	    ignoreError: false,
	};
	/**
	 * Returns the public suffix of this hostname. The public suffix is the shortest domain
	 * name upon which a cookie can be set.
	 *
	 * @remarks
	 * A "public suffix" is a domain that is controlled by a
	 * public registry, such as "com", "co.uk", and "pvt.k12.wy.us".
	 * This step is essential for preventing attacker.com from
	 * disrupting the integrity of example.com by setting a cookie
	 * with a Domain attribute of "com".  Unfortunately, the set of
	 * public suffixes (also known as "registry controlled domains")
	 * changes over time.  If feasible, user agents SHOULD use an
	 * up-to-date public suffix list, such as the one maintained by
	 * the Mozilla project at http://publicsuffix.org/.
	 * (See {@link https://www.rfc-editor.org/rfc/rfc6265.html#section-5.3 | RFC6265 - Section 5.3})
	 *
	 * @example
	 * ```
	 * getPublicSuffix('www.example.com') === 'example.com'
	 * getPublicSuffix('www.subdomain.example.com') === 'example.com'
	 * ```
	 *
	 * @param domain - the domain attribute of a cookie
	 * @param options - optional configuration for controlling how the public suffix is determined
	 * @public
	 */
	function getPublicSuffix(domain, options = {}) {
	    options = { ...defaultGetPublicSuffixOptions, ...options };
	    const domainParts = domain.split('.');
	    const topLevelDomain = domainParts[domainParts.length - 1];
	    const allowSpecialUseDomain = !!options.allowSpecialUseDomain;
	    const ignoreError = !!options.ignoreError;
	    if (allowSpecialUseDomain &&
	        topLevelDomain !== undefined &&
	        SPECIAL_USE_DOMAINS.includes(topLevelDomain)) {
	        if (domainParts.length > 1) {
	            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
	            const secondLevelDomain = domainParts[domainParts.length - 2];
	            // In aforementioned example, the eTLD/pubSuf will be apple.localhost
	            return `${secondLevelDomain}.${topLevelDomain}`;
	        }
	        else if (SPECIAL_TREATMENT_DOMAINS.includes(topLevelDomain)) {
	            // For a single word special use domain, e.g. 'localhost' or 'invalid', per RFC 6761,
	            // "Application software MAY recognize {localhost/invalid} names as special, or
	            // MAY pass them to name resolution APIs as they would for other domain names."
	            return topLevelDomain;
	        }
	    }
	    if (!ignoreError &&
	        topLevelDomain !== undefined &&
	        SPECIAL_USE_DOMAINS.includes(topLevelDomain)) {
	        throw new Error(`Cookie has domain set to the public suffix "${topLevelDomain}" which is a special use domain. To allow this, configure your CookieJar with {allowSpecialUseDomain: true, rejectPublicSuffixes: false}.`);
	    }
	    const publicSuffix = (0, tldts_1.getDomain)(domain, {
	        allowIcannDomains: true,
	        allowPrivateDomains: true,
	    });
	    if (publicSuffix)
	        return publicSuffix;
	}
	return getPublicSuffix$1;
}

var hasRequiredPermuteDomain;

function requirePermuteDomain () {
	if (hasRequiredPermuteDomain) return permuteDomain;
	hasRequiredPermuteDomain = 1;
	Object.defineProperty(permuteDomain, "__esModule", { value: true });
	permuteDomain.permuteDomain = permuteDomain$1;
	const getPublicSuffix_1 = requireGetPublicSuffix();
	/**
	 * Generates the permutation of all possible values that {@link domainMatch} the given `domain` parameter. The
	 * array is in shortest-to-longest order. Useful when building custom {@link Store} implementations.
	 *
	 * @example
	 * ```
	 * permuteDomain('foo.bar.example.com')
	 * // ['example.com', 'bar.example.com', 'foo.bar.example.com']
	 * ```
	 *
	 * @public
	 * @param domain - the domain to generate permutations for
	 * @param allowSpecialUseDomain - flag to control if {@link https://www.rfc-editor.org/rfc/rfc6761.html | Special Use Domains} such as `localhost` should be allowed
	 */
	function permuteDomain$1(domain, allowSpecialUseDomain) {
	    const pubSuf = (0, getPublicSuffix_1.getPublicSuffix)(domain, {
	        allowSpecialUseDomain: allowSpecialUseDomain,
	    });
	    if (!pubSuf) {
	        return undefined;
	    }
	    if (pubSuf == domain) {
	        return [domain];
	    }
	    // Nuke trailing dot
	    if (domain.slice(-1) == '.') {
	        domain = domain.slice(0, -1);
	    }
	    const prefix = domain.slice(0, -(pubSuf.length + 1)); // ".example.com"
	    const parts = prefix.split('.').reverse();
	    let cur = pubSuf;
	    const permutations = [cur];
	    while (parts.length) {
	        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
	        const part = parts.shift();
	        cur = `${part}.${cur}`;
	        permutations.push(cur);
	    }
	    return permutations;
	}
	return permuteDomain;
}

var store = {};

var hasRequiredStore;

function requireStore () {
	if (hasRequiredStore) return store;
	hasRequiredStore = 1;
	// disabling this lint on this whole file because Store should be abstract
	// but we have implementations in the wild that may not implement all features
	/* eslint-disable @typescript-eslint/no-unused-vars */
	Object.defineProperty(store, "__esModule", { value: true });
	store.Store = void 0;
	/**
	 * Base class for {@link CookieJar} stores.
	 *
	 * The storage model for each {@link CookieJar} instance can be replaced with a custom implementation. The default is
	 * {@link MemoryCookieStore}.
	 *
	 * @remarks
	 * - Stores should inherit from the base Store class, which is available as a top-level export.
	 *
	 * - Stores are asynchronous by default, but if {@link Store.synchronous} is set to true, then the `*Sync` methods
	 *     of the containing {@link CookieJar} can be used.
	 *
	 * @public
	 */
	class Store {
	    constructor() {
	        this.synchronous = false;
	    }
	    /**
	     * @internal No doc because this is an overload that supports the implementation
	     */
	    findCookie(_domain, _path, _key, _callback) {
	        throw new Error('findCookie is not implemented');
	    }
	    /**
	     * @internal No doc because this is an overload that supports the implementation
	     */
	    findCookies(_domain, _path, _allowSpecialUseDomain = false, _callback) {
	        throw new Error('findCookies is not implemented');
	    }
	    /**
	     * @internal No doc because this is an overload that supports the implementation
	     */
	    putCookie(_cookie, _callback) {
	        throw new Error('putCookie is not implemented');
	    }
	    /**
	     * @internal No doc because this is an overload that supports the implementation
	     */
	    updateCookie(_oldCookie, _newCookie, _callback) {
	        // recommended default implementation:
	        // return this.putCookie(newCookie, cb);
	        throw new Error('updateCookie is not implemented');
	    }
	    /**
	     * @internal No doc because this is an overload that supports the implementation
	     */
	    removeCookie(_domain, _path, _key, _callback) {
	        throw new Error('removeCookie is not implemented');
	    }
	    /**
	     * @internal No doc because this is an overload that supports the implementation
	     */
	    removeCookies(_domain, _path, _callback) {
	        throw new Error('removeCookies is not implemented');
	    }
	    /**
	     * @internal No doc because this is an overload that supports the implementation
	     */
	    removeAllCookies(_callback) {
	        throw new Error('removeAllCookies is not implemented');
	    }
	    /**
	     * @internal No doc because this is an overload that supports the implementation
	     */
	    getAllCookies(_callback) {
	        throw new Error('getAllCookies is not implemented (therefore jar cannot be serialized)');
	    }
	}
	store.Store = Store;
	return store;
}

var utils = {};

var hasRequiredUtils;

function requireUtils () {
	if (hasRequiredUtils) return utils;
	hasRequiredUtils = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.safeToString = exports.objectToString = void 0;
		exports.createPromiseCallback = createPromiseCallback;
		exports.inOperator = inOperator;
		/** Wrapped `Object.prototype.toString`, so that you don't need to remember to use `.call()`. */
		const objectToString = (obj) => Object.prototype.toString.call(obj);
		exports.objectToString = objectToString;
		/**
		 * Converts an array to string, safely handling symbols, null prototype objects, and recursive arrays.
		 */
		const safeArrayToString = (arr, seenArrays) => {
		    // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toString#description
		    if (typeof arr.join !== 'function')
		        return (0, exports.objectToString)(arr);
		    seenArrays.add(arr);
		    const mapped = arr.map((val) => val === null || val === undefined || seenArrays.has(val)
		        ? ''
		        : safeToStringImpl(val, seenArrays));
		    return mapped.join();
		};
		const safeToStringImpl = (val, seenArrays = new WeakSet()) => {
		    // Using .toString() fails for null/undefined and implicit conversion (val + "") fails for symbols
		    // and objects with null prototype
		    if (typeof val !== 'object' || val === null) {
		        return String(val);
		    }
		    else if (typeof val.toString === 'function') {
		        return Array.isArray(val)
		            ? // Arrays have a weird custom toString that we need to replicate
		                safeArrayToString(val, seenArrays)
		            : String(val);
		    }
		    else {
		        // This case should just be objects with null prototype, so we can just use Object#toString
		        return (0, exports.objectToString)(val);
		    }
		};
		/** Safely converts any value to string, using the value's own `toString` when available. */
		const safeToString = (val) => safeToStringImpl(val);
		exports.safeToString = safeToString;
		/** Converts a callback into a utility object where either a callback or a promise can be used. */
		function createPromiseCallback(cb) {
		    let callback;
		    let resolve;
		    let reject;
		    const promise = new Promise((_resolve, _reject) => {
		        resolve = _resolve;
		        reject = _reject;
		    });
		    if (typeof cb === 'function') {
		        callback = (err, result) => {
		            try {
		                if (err)
		                    cb(err);
		                // If `err` is null, we know `result` must be `T`
		                // The assertion isn't *strictly* correct, as `T` could be nullish, but, ehh, good enough...
		                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
		                else
		                    cb(null, result);
		            }
		            catch (e) {
		                reject(e instanceof Error ? e : new Error());
		            }
		        };
		    }
		    else {
		        callback = (err, result) => {
		            try {
		                // If `err` is null, we know `result` must be `T`
		                // The assertion isn't *strictly* correct, as `T` could be nullish, but, ehh, good enough...
		                if (err)
		                    reject(err);
		                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
		                else
		                    resolve(result);
		            }
		            catch (e) {
		                reject(e instanceof Error ? e : new Error());
		            }
		        };
		    }
		    return {
		        promise,
		        callback,
		        resolve: (value) => {
		            callback(null, value);
		            return promise;
		        },
		        reject: (error) => {
		            callback(error);
		            return promise;
		        },
		    };
		}
		function inOperator(k, o) {
		    return k in o;
		} 
	} (utils));
	return utils;
}

var hasRequiredMemstore;

function requireMemstore () {
	if (hasRequiredMemstore) return memstore;
	hasRequiredMemstore = 1;
	Object.defineProperty(memstore, "__esModule", { value: true });
	memstore.MemoryCookieStore = void 0;
	const pathMatch_1 = requirePathMatch();
	const permuteDomain_1 = requirePermuteDomain();
	const store_1 = requireStore();
	const utils_1 = requireUtils();
	/**
	 * An in-memory {@link Store} implementation for {@link CookieJar}. This is the default implementation used by
	 * {@link CookieJar} and supports both async and sync operations. Also supports serialization, getAllCookies, and removeAllCookies.
	 * @public
	 */
	class MemoryCookieStore extends store_1.Store {
	    /**
	     * Create a new {@link MemoryCookieStore}.
	     */
	    constructor() {
	        super();
	        this.synchronous = true;
	        this.idx = Object.create(null);
	    }
	    /**
	     * @internal No doc because this is an overload that supports the implementation
	     */
	    findCookie(domain, path, key, callback) {
	        const promiseCallback = (0, utils_1.createPromiseCallback)(callback);
	        if (domain == null || path == null || key == null) {
	            return promiseCallback.resolve(undefined);
	        }
	        const result = this.idx[domain]?.[path]?.[key];
	        return promiseCallback.resolve(result);
	    }
	    /**
	     * @internal No doc because this is an overload that supports the implementation
	     */
	    findCookies(domain, path, allowSpecialUseDomain = false, callback) {
	        if (typeof allowSpecialUseDomain === 'function') {
	            callback = allowSpecialUseDomain;
	            // TODO: It's weird that `allowSpecialUseDomain` defaults to false with no callback,
	            // but true with a callback. This is legacy behavior from v4.
	            allowSpecialUseDomain = true;
	        }
	        const results = [];
	        const promiseCallback = (0, utils_1.createPromiseCallback)(callback);
	        if (!domain) {
	            return promiseCallback.resolve([]);
	        }
	        let pathMatcher;
	        if (!path) {
	            // null means "all paths"
	            pathMatcher = function matchAll(domainIndex) {
	                for (const curPath in domainIndex) {
	                    const pathIndex = domainIndex[curPath];
	                    for (const key in pathIndex) {
	                        const value = pathIndex[key];
	                        if (value) {
	                            results.push(value);
	                        }
	                    }
	                }
	            };
	        }
	        else {
	            pathMatcher = function matchRFC(domainIndex) {
	                //NOTE: we should use path-match algorithm from S5.1.4 here
	                //(see : https://github.com/ChromiumWebApps/chromium/blob/b3d3b4da8bb94c1b2e061600df106d590fda3620/net/cookies/canonical_cookie.cc#L299)
	                for (const cookiePath in domainIndex) {
	                    if ((0, pathMatch_1.pathMatch)(path, cookiePath)) {
	                        const pathIndex = domainIndex[cookiePath];
	                        for (const key in pathIndex) {
	                            const value = pathIndex[key];
	                            if (value) {
	                                results.push(value);
	                            }
	                        }
	                    }
	                }
	            };
	        }
	        const domains = (0, permuteDomain_1.permuteDomain)(domain, allowSpecialUseDomain) || [domain];
	        const idx = this.idx;
	        domains.forEach((curDomain) => {
	            const domainIndex = idx[curDomain];
	            if (!domainIndex) {
	                return;
	            }
	            pathMatcher(domainIndex);
	        });
	        return promiseCallback.resolve(results);
	    }
	    /**
	     * @internal No doc because this is an overload that supports the implementation
	     */
	    putCookie(cookie, callback) {
	        const promiseCallback = (0, utils_1.createPromiseCallback)(callback);
	        const { domain, path, key } = cookie;
	        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
	        if (domain == null || path == null || key == null) {
	            return promiseCallback.resolve(undefined);
	        }
	        const domainEntry = this.idx[domain] ??
	            Object.create(null);
	        this.idx[domain] = domainEntry;
	        const pathEntry = domainEntry[path] ??
	            Object.create(null);
	        domainEntry[path] = pathEntry;
	        pathEntry[key] = cookie;
	        return promiseCallback.resolve(undefined);
	    }
	    /**
	     * @internal No doc because this is an overload that supports the implementation
	     */
	    updateCookie(_oldCookie, newCookie, callback) {
	        // updateCookie() may avoid updating cookies that are identical.  For example,
	        // lastAccessed may not be important to some stores and an equality
	        // comparison could exclude that field.
	        // Don't return a value when using a callback, so that the return type is truly "void"
	        if (callback)
	            this.putCookie(newCookie, callback);
	        else
	            return this.putCookie(newCookie);
	    }
	    /**
	     * @internal No doc because this is an overload that supports the implementation
	     */
	    removeCookie(domain, path, key, callback) {
	        const promiseCallback = (0, utils_1.createPromiseCallback)(callback);
	        delete this.idx[domain]?.[path]?.[key];
	        return promiseCallback.resolve(undefined);
	    }
	    /**
	     * @internal No doc because this is an overload that supports the implementation
	     */
	    removeCookies(domain, path, callback) {
	        const promiseCallback = (0, utils_1.createPromiseCallback)(callback);
	        const domainEntry = this.idx[domain];
	        if (domainEntry) {
	            if (path) {
	                // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
	                delete domainEntry[path];
	            }
	            else {
	                // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
	                delete this.idx[domain];
	            }
	        }
	        return promiseCallback.resolve(undefined);
	    }
	    /**
	     * @internal No doc because this is an overload that supports the implementation
	     */
	    removeAllCookies(callback) {
	        const promiseCallback = (0, utils_1.createPromiseCallback)(callback);
	        this.idx = Object.create(null);
	        return promiseCallback.resolve(undefined);
	    }
	    /**
	     * @internal No doc because this is an overload that supports the implementation
	     */
	    getAllCookies(callback) {
	        const promiseCallback = (0, utils_1.createPromiseCallback)(callback);
	        const cookies = [];
	        const idx = this.idx;
	        const domains = Object.keys(idx);
	        domains.forEach((domain) => {
	            const domainEntry = idx[domain] ?? {};
	            const paths = Object.keys(domainEntry);
	            paths.forEach((path) => {
	                const pathEntry = domainEntry[path] ?? {};
	                const keys = Object.keys(pathEntry);
	                keys.forEach((key) => {
	                    const keyEntry = pathEntry[key];
	                    if (keyEntry != null) {
	                        cookies.push(keyEntry);
	                    }
	                });
	            });
	        });
	        // Sort by creationIndex so deserializing retains the creation order.
	        // When implementing your own store, this SHOULD retain the order too
	        cookies.sort((a, b) => {
	            return (a.creationIndex || 0) - (b.creationIndex || 0);
	        });
	        return promiseCallback.resolve(cookies);
	    }
	}
	memstore.MemoryCookieStore = MemoryCookieStore;
	return memstore;
}

var validators = {};

var hasRequiredValidators;

function requireValidators () {
	if (hasRequiredValidators) return validators;
	hasRequiredValidators = 1;
	/* ************************************************************************************
	Extracted from check-types.js
	https://gitlab.com/philbooth/check-types.js

	MIT License

	Copyright (c) 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019 Phil Booth

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in all
	copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	SOFTWARE.

	************************************************************************************ */
	Object.defineProperty(validators, "__esModule", { value: true });
	validators.ParameterError = void 0;
	validators.isNonEmptyString = isNonEmptyString;
	validators.isDate = isDate;
	validators.isEmptyString = isEmptyString;
	validators.isString = isString;
	validators.isObject = isObject;
	validators.isInteger = isInteger;
	validators.validate = validate;
	const utils_1 = requireUtils();
	/* Validation functions copied from check-types package - https://www.npmjs.com/package/check-types */
	/** Determines whether the argument is a non-empty string. */
	function isNonEmptyString(data) {
	    return isString(data) && data !== '';
	}
	/** Determines whether the argument is a *valid* Date. */
	function isDate(data) {
	    return data instanceof Date && isInteger(data.getTime());
	}
	/** Determines whether the argument is the empty string. */
	function isEmptyString(data) {
	    return data === '' || (data instanceof String && data.toString() === '');
	}
	/** Determines whether the argument is a string. */
	function isString(data) {
	    return typeof data === 'string' || data instanceof String;
	}
	/** Determines whether the string representation of the argument is "[object Object]". */
	function isObject(data) {
	    return (0, utils_1.objectToString)(data) === '[object Object]';
	}
	/** Determines whether the argument is an integer. */
	function isInteger(data) {
	    return typeof data === 'number' && data % 1 === 0;
	}
	/* -- End validation functions -- */
	/**
	 * When the first argument is false, an error is created with the given message. If a callback is
	 * provided, the error is passed to the callback, otherwise the error is thrown.
	 */
	function validate(bool, cbOrMessage, message) {
	    if (bool)
	        return; // Validation passes
	    const cb = typeof cbOrMessage === 'function' ? cbOrMessage : undefined;
	    let options = typeof cbOrMessage === 'function' ? message : cbOrMessage;
	    // The default message prior to v5 was '[object Object]' due to a bug, and the message is kept
	    // for backwards compatibility.
	    if (!isObject(options))
	        options = '[object Object]';
	    const err = new ParameterError((0, utils_1.safeToString)(options));
	    if (cb)
	        cb(err);
	    else
	        throw err;
	}
	/**
	 * Represents a validation error.
	 * @public
	 */
	class ParameterError extends Error {
	}
	validators.ParameterError = ParameterError;
	return validators;
}

var version$1 = {};

var hasRequiredVersion;

function requireVersion () {
	if (hasRequiredVersion) return version$1;
	hasRequiredVersion = 1;
	Object.defineProperty(version$1, "__esModule", { value: true });
	version$1.version = void 0;
	/**
	 * The version of `tough-cookie`
	 * @public
	 */
	version$1.version = '5.0.0';
	return version$1;
}

var canonicalDomain = {};

var constants = {};

var hasRequiredConstants;

function requireConstants () {
	if (hasRequiredConstants) return constants;
	hasRequiredConstants = 1;
	Object.defineProperty(constants, "__esModule", { value: true });
	constants.IP_V6_REGEX_OBJECT = constants.PrefixSecurityEnum = void 0;
	/**
	 * Cookie prefixes are a way to indicate that a given cookie was set with a set of attributes simply by inspecting the
	 * first few characters of the cookie's name. These are defined in {@link https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis-13#section-4.1.3 | RFC6265bis - Section 4.1.3}.
	 *
	 * The following values can be used to configure how a {@link CookieJar} enforces attribute restrictions for Cookie prefixes:
	 *
	 * - `silent` - Enable cookie prefix checking but silently ignores the cookie if conditions are not met. This is the default configuration for a {@link CookieJar}.
	 *
	 * - `strict` - Enables cookie prefix checking and will raise an error if conditions are not met.
	 *
	 * - `unsafe-disabled` - Disables cookie prefix checking.
	 * @public
	 */
	constants.PrefixSecurityEnum = Object.freeze({
	    SILENT: 'silent',
	    STRICT: 'strict',
	    DISABLED: 'unsafe-disabled',
	});
	const IP_V6_REGEX = `
\\[?(?:
(?:[a-fA-F\\d]{1,4}:){7}(?:[a-fA-F\\d]{1,4}|:)|
(?:[a-fA-F\\d]{1,4}:){6}(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|:[a-fA-F\\d]{1,4}|:)|
(?:[a-fA-F\\d]{1,4}:){5}(?::(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,2}|:)|
(?:[a-fA-F\\d]{1,4}:){4}(?:(?::[a-fA-F\\d]{1,4}){0,1}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,3}|:)|
(?:[a-fA-F\\d]{1,4}:){3}(?:(?::[a-fA-F\\d]{1,4}){0,2}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,4}|:)|
(?:[a-fA-F\\d]{1,4}:){2}(?:(?::[a-fA-F\\d]{1,4}){0,3}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,5}|:)|
(?:[a-fA-F\\d]{1,4}:){1}(?:(?::[a-fA-F\\d]{1,4}){0,4}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,6}|:)|
(?::(?:(?::[a-fA-F\\d]{1,4}){0,5}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,7}|:))
)(?:%[0-9a-zA-Z]{1,})?\\]?
`
	    .replace(/\s*\/\/.*$/gm, '')
	    .replace(/\n/g, '')
	    .trim();
	constants.IP_V6_REGEX_OBJECT = new RegExp(`^${IP_V6_REGEX}$`);
	return constants;
}

var hasRequiredCanonicalDomain;

function requireCanonicalDomain () {
	if (hasRequiredCanonicalDomain) return canonicalDomain;
	hasRequiredCanonicalDomain = 1;
	Object.defineProperty(canonicalDomain, "__esModule", { value: true });
	canonicalDomain.canonicalDomain = canonicalDomain$1;
	const constants_1 = requireConstants();
	const node_url_1 = require$$1$2;
	/**
	 * Transforms a domain name into a canonical domain name. The canonical domain name is a domain name
	 * that has been trimmed, lowercased, stripped of leading dot, and optionally punycode-encoded
	 * ({@link https://www.rfc-editor.org/rfc/rfc6265.html#section-5.1.2 | Section 5.1.2 of RFC 6265}). For
	 * the most part, this function is idempotent (calling the function with the output from a previous call
	 * returns the same output).
	 *
	 * @remarks
	 * A canonicalized host name is the string generated by the following
	 * algorithm:
	 *
	 * 1.  Convert the host name to a sequence of individual domain name
	 *     labels.
	 *
	 * 2.  Convert each label that is not a Non-Reserved LDH (NR-LDH) label,
	 *     to an A-label (see Section 2.3.2.1 of [RFC5890] for the former
	 *     and latter), or to a "punycode label" (a label resulting from the
	 *     "ToASCII" conversion in Section 4 of [RFC3490]), as appropriate
	 *     (see Section 6.3 of this specification).
	 *
	 * 3.  Concatenate the resulting labels, separated by a %x2E (".")
	 *     character.
	 *
	 * @example
	 * ```
	 * canonicalDomain('.EXAMPLE.com') === 'example.com'
	 * ```
	 *
	 * @param domainName - the domain name to generate the canonical domain from
	 * @public
	 */
	function canonicalDomain$1(domainName) {
	    if (domainName == null) {
	        return undefined;
	    }
	    let str = domainName.trim().replace(/^\./, ''); // S4.1.2.3 & S5.2.3: ignore leading .
	    if (constants_1.IP_V6_REGEX_OBJECT.test(str)) {
	        if (!str.startsWith('[')) {
	            str = '[' + str;
	        }
	        if (!str.endsWith(']')) {
	            str = str + ']';
	        }
	        return (0, node_url_1.domainToASCII)(str).slice(1, -1); // remove [ and ]
	    }
	    // convert to IDN if any non-ASCII characters
	    // eslint-disable-next-line no-control-regex
	    if (/[^\u0001-\u007f]/.test(str)) {
	        return (0, node_url_1.domainToASCII)(str);
	    }
	    // ASCII-only domain - not canonicalized with new URL() because it may be a malformed URL
	    return str.toLowerCase();
	}
	return canonicalDomain;
}

var cookie = {};

var formatDate = {};

var hasRequiredFormatDate;

function requireFormatDate () {
	if (hasRequiredFormatDate) return formatDate;
	hasRequiredFormatDate = 1;
	Object.defineProperty(formatDate, "__esModule", { value: true });
	formatDate.formatDate = formatDate$1;
	/**
	 * Format a {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date | Date} into
	 * the {@link https://www.rfc-editor.org/rfc/rfc2616#section-3.3.1 | preferred Internet standard format}
	 * defined in {@link https://www.rfc-editor.org/rfc/rfc822#section-5 | RFC822} and
	 * updated in {@link https://www.rfc-editor.org/rfc/rfc1123#page-55 | RFC1123}.
	 *
	 * @example
	 * ```
	 * formatDate(new Date(0)) === 'Thu, 01 Jan 1970 00:00:00 GMT`
	 * ```
	 *
	 * @param date - the date value to format
	 * @public
	 */
	function formatDate$1(date) {
	    return date.toUTCString();
	}
	return formatDate;
}

var parseDate = {};

var hasRequiredParseDate;

function requireParseDate () {
	if (hasRequiredParseDate) return parseDate;
	hasRequiredParseDate = 1;
	// date-time parsing constants (RFC6265 S5.1.1)
	Object.defineProperty(parseDate, "__esModule", { value: true });
	parseDate.parseDate = parseDate$1;
	// eslint-disable-next-line no-control-regex
	const DATE_DELIM = /[\x09\x20-\x2F\x3B-\x40\x5B-\x60\x7B-\x7E]/;
	const MONTH_TO_NUM = {
	    jan: 0,
	    feb: 1,
	    mar: 2,
	    apr: 3,
	    may: 4,
	    jun: 5,
	    jul: 6,
	    aug: 7,
	    sep: 8,
	    oct: 9,
	    nov: 10,
	    dec: 11,
	};
	/*
	 * Parses a Natural number (i.e., non-negative integer) with either the
	 *    <min>*<max>DIGIT ( non-digit *OCTET )
	 * or
	 *    <min>*<max>DIGIT
	 * grammar (RFC6265 S5.1.1).
	 *
	 * The "trailingOK" boolean controls if the grammar accepts a
	 * "( non-digit *OCTET )" trailer.
	 */
	function parseDigits(token, minDigits, maxDigits, trailingOK) {
	    let count = 0;
	    while (count < token.length) {
	        const c = token.charCodeAt(count);
	        // "non-digit = %x00-2F / %x3A-FF"
	        if (c <= 0x2f || c >= 0x3a) {
	            break;
	        }
	        count++;
	    }
	    // constrain to a minimum and maximum number of digits.
	    if (count < minDigits || count > maxDigits) {
	        return;
	    }
	    if (!trailingOK && count != token.length) {
	        return;
	    }
	    return parseInt(token.slice(0, count), 10);
	}
	function parseTime(token) {
	    const parts = token.split(':');
	    const result = [0, 0, 0];
	    /* RF6256 S5.1.1:
	     *      time            = hms-time ( non-digit *OCTET )
	     *      hms-time        = time-field ":" time-field ":" time-field
	     *      time-field      = 1*2DIGIT
	     */
	    if (parts.length !== 3) {
	        return;
	    }
	    for (let i = 0; i < 3; i++) {
	        // "time-field" must be strictly "1*2DIGIT", HOWEVER, "hms-time" can be
	        // followed by "( non-digit *OCTET )" therefore the last time-field can
	        // have a trailer
	        const trailingOK = i == 2;
	        const numPart = parts[i];
	        if (numPart === undefined) {
	            return;
	        }
	        const num = parseDigits(numPart, 1, 2, trailingOK);
	        if (num === undefined) {
	            return;
	        }
	        result[i] = num;
	    }
	    return result;
	}
	function parseMonth(token) {
	    token = String(token).slice(0, 3).toLowerCase();
	    switch (token) {
	        case 'jan':
	            return MONTH_TO_NUM.jan;
	        case 'feb':
	            return MONTH_TO_NUM.feb;
	        case 'mar':
	            return MONTH_TO_NUM.mar;
	        case 'apr':
	            return MONTH_TO_NUM.apr;
	        case 'may':
	            return MONTH_TO_NUM.may;
	        case 'jun':
	            return MONTH_TO_NUM.jun;
	        case 'jul':
	            return MONTH_TO_NUM.jul;
	        case 'aug':
	            return MONTH_TO_NUM.aug;
	        case 'sep':
	            return MONTH_TO_NUM.sep;
	        case 'oct':
	            return MONTH_TO_NUM.oct;
	        case 'nov':
	            return MONTH_TO_NUM.nov;
	        case 'dec':
	            return MONTH_TO_NUM.dec;
	        default:
	            return;
	    }
	}
	/**
	 * Parse a cookie date string into a {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date | Date}. Parses according to
	 * {@link https://www.rfc-editor.org/rfc/rfc6265.html#section-5.1.1 | RFC6265 - Section 5.1.1}, not
	 * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/parse | Date.parse()}.
	 *
	 * @remarks
	 *
	 * ### RFC6265 - 5.1.1. Dates
	 *
	 * The user agent MUST use an algorithm equivalent to the following
	 * algorithm to parse a cookie-date.  Note that the various boolean
	 * flags defined as a part of the algorithm (i.e., found-time, found-
	 * day-of-month, found-month, found-year) are initially "not set".
	 *
	 * 1.  Using the grammar below, divide the cookie-date into date-tokens.
	 *
	 * ```
	 *     cookie-date     = *delimiter date-token-list *delimiter
	 *     date-token-list = date-token *( 1*delimiter date-token )
	 *     date-token      = 1*non-delimiter
	 *
	 *     delimiter       = %x09 / %x20-2F / %x3B-40 / %x5B-60 / %x7B-7E
	 *     non-delimiter   = %x00-08 / %x0A-1F / DIGIT / ":" / ALPHA / %x7F-FF
	 *     non-digit       = %x00-2F / %x3A-FF
	 *
	 *     day-of-month    = 1*2DIGIT ( non-digit *OCTET )
	 *     month           = ( "jan" / "feb" / "mar" / "apr" /
	 *                        "may" / "jun" / "jul" / "aug" /
	 *                        "sep" / "oct" / "nov" / "dec" ) *OCTET
	 *     year            = 2*4DIGIT ( non-digit *OCTET )
	 *     time            = hms-time ( non-digit *OCTET )
	 *     hms-time        = time-field ":" time-field ":" time-field
	 *     time-field      = 1*2DIGIT
	 * ```
	 *
	 * 2. Process each date-token sequentially in the order the date-tokens
	 *     appear in the cookie-date:
	 *
	 *     1. If the found-time flag is not set and the token matches the
	 *         time production, set the found-time flag and set the hour-
	 *         value, minute-value, and second-value to the numbers denoted
	 *         by the digits in the date-token, respectively.  Skip the
	 *         remaining sub-steps and continue to the next date-token.
	 *
	 *     2. If the found-day-of-month flag is not set and the date-token
	 *         matches the day-of-month production, set the found-day-of-
	 *         month flag and set the day-of-month-value to the number
	 *         denoted by the date-token.  Skip the remaining sub-steps and
	 *         continue to the next date-token.
	 *
	 *     3. If the found-month flag is not set and the date-token matches
	 *         the month production, set the found-month flag and set the
	 *         month-value to the month denoted by the date-token.  Skip the
	 *         remaining sub-steps and continue to the next date-token.
	 *
	 *     4. If the found-year flag is not set and the date-token matches
	 *         the year production, set the found-year flag and set the
	 *         year-value to the number denoted by the date-token.  Skip the
	 *         remaining sub-steps and continue to the next date-token.
	 *
	 *  3. If the year-value is greater than or equal to 70 and less than or
	 *      equal to 99, increment the year-value by 1900.
	 *
	 *  4. If the year-value is greater than or equal to 0 and less than or
	 *      equal to 69, increment the year-value by 2000.
	 *
	 *      1. NOTE: Some existing user agents interpret two-digit years differently.
	 *
	 *  5. Abort these steps and fail to parse the cookie-date if:
	 *
	 *      - at least one of the found-day-of-month, found-month, found-
	 *          year, or found-time flags is not set,
	 *
	 *      - the day-of-month-value is less than 1 or greater than 31,
	 *
	 *      - the year-value is less than 1601,
	 *
	 *      - the hour-value is greater than 23,
	 *
	 *      - the minute-value is greater than 59, or
	 *
	 *      - the second-value is greater than 59.
	 *
	 *      (Note that leap seconds cannot be represented in this syntax.)
	 *
	 *  6. Let the parsed-cookie-date be the date whose day-of-month, month,
	 *      year, hour, minute, and second (in UTC) are the day-of-month-
	 *      value, the month-value, the year-value, the hour-value, the
	 *      minute-value, and the second-value, respectively.  If no such
	 *      date exists, abort these steps and fail to parse the cookie-date.
	 *
	 *  7. Return the parsed-cookie-date as the result of this algorithm.
	 *
	 * @example
	 * ```
	 * parseDate('Wed, 09 Jun 2021 10:18:14 GMT')
	 * ```
	 *
	 * @param cookieDate - the cookie date string
	 * @public
	 */
	function parseDate$1(cookieDate) {
	    if (!cookieDate) {
	        return;
	    }
	    /* RFC6265 S5.1.1:
	     * 2. Process each date-token sequentially in the order the date-tokens
	     * appear in the cookie-date
	     */
	    const tokens = cookieDate.split(DATE_DELIM);
	    let hour;
	    let minute;
	    let second;
	    let dayOfMonth;
	    let month;
	    let year;
	    for (let i = 0; i < tokens.length; i++) {
	        const token = (tokens[i] ?? '').trim();
	        if (!token.length) {
	            continue;
	        }
	        /* 2.1. If the found-time flag is not set and the token matches the time
	         * production, set the found-time flag and set the hour- value,
	         * minute-value, and second-value to the numbers denoted by the digits in
	         * the date-token, respectively.  Skip the remaining sub-steps and continue
	         * to the next date-token.
	         */
	        if (second === undefined) {
	            const result = parseTime(token);
	            if (result) {
	                hour = result[0];
	                minute = result[1];
	                second = result[2];
	                continue;
	            }
	        }
	        /* 2.2. If the found-day-of-month flag is not set and the date-token matches
	         * the day-of-month production, set the found-day-of- month flag and set
	         * the day-of-month-value to the number denoted by the date-token.  Skip
	         * the remaining sub-steps and continue to the next date-token.
	         */
	        if (dayOfMonth === undefined) {
	            // "day-of-month = 1*2DIGIT ( non-digit *OCTET )"
	            const result = parseDigits(token, 1, 2, true);
	            if (result !== undefined) {
	                dayOfMonth = result;
	                continue;
	            }
	        }
	        /* 2.3. If the found-month flag is not set and the date-token matches the
	         * month production, set the found-month flag and set the month-value to
	         * the month denoted by the date-token.  Skip the remaining sub-steps and
	         * continue to the next date-token.
	         */
	        if (month === undefined) {
	            const result = parseMonth(token);
	            if (result !== undefined) {
	                month = result;
	                continue;
	            }
	        }
	        /* 2.4. If the found-year flag is not set and the date-token matches the
	         * year production, set the found-year flag and set the year-value to the
	         * number denoted by the date-token.  Skip the remaining sub-steps and
	         * continue to the next date-token.
	         */
	        if (year === undefined) {
	            // "year = 2*4DIGIT ( non-digit *OCTET )"
	            const result = parseDigits(token, 2, 4, true);
	            if (result !== undefined) {
	                year = result;
	                /* From S5.1.1:
	                 * 3.  If the year-value is greater than or equal to 70 and less
	                 * than or equal to 99, increment the year-value by 1900.
	                 * 4.  If the year-value is greater than or equal to 0 and less
	                 * than or equal to 69, increment the year-value by 2000.
	                 */
	                if (year >= 70 && year <= 99) {
	                    year += 1900;
	                }
	                else if (year >= 0 && year <= 69) {
	                    year += 2000;
	                }
	            }
	        }
	    }
	    /* RFC 6265 S5.1.1
	     * "5. Abort these steps and fail to parse the cookie-date if:
	     *     *  at least one of the found-day-of-month, found-month, found-
	     *        year, or found-time flags is not set,
	     *     *  the day-of-month-value is less than 1 or greater than 31,
	     *     *  the year-value is less than 1601,
	     *     *  the hour-value is greater than 23,
	     *     *  the minute-value is greater than 59, or
	     *     *  the second-value is greater than 59.
	     *     (Note that leap seconds cannot be represented in this syntax.)"
	     *
	     * So, in order as above:
	     */
	    if (dayOfMonth === undefined ||
	        month === undefined ||
	        year === undefined ||
	        hour === undefined ||
	        minute === undefined ||
	        second === undefined ||
	        dayOfMonth < 1 ||
	        dayOfMonth > 31 ||
	        year < 1601 ||
	        hour > 23 ||
	        minute > 59 ||
	        second > 59) {
	        return;
	    }
	    return new Date(Date.UTC(year, month, dayOfMonth, hour, minute, second));
	}
	return parseDate;
}

var hasRequiredCookie$1;

function requireCookie$1 () {
	if (hasRequiredCookie$1) return cookie;
	hasRequiredCookie$1 = 1;
	var __createBinding = (cookie && cookie.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (cookie && cookie.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (cookie && cookie.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(cookie, "__esModule", { value: true });
	cookie.Cookie = void 0;
	/*!
	 * Copyright (c) 2015-2020, Salesforce.com, Inc.
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are met:
	 *
	 * 1. Redistributions of source code must retain the above copyright notice,
	 * this list of conditions and the following disclaimer.
	 *
	 * 2. Redistributions in binary form must reproduce the above copyright notice,
	 * this list of conditions and the following disclaimer in the documentation
	 * and/or other materials provided with the distribution.
	 *
	 * 3. Neither the name of Salesforce.com nor the names of its contributors may
	 * be used to endorse or promote products derived from this software without
	 * specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
	 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
	 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
	 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
	 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
	 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
	 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
	 * POSSIBILITY OF SUCH DAMAGE.
	 */
	const getPublicSuffix_1 = requireGetPublicSuffix();
	const validators = __importStar(requireValidators());
	const utils_1 = requireUtils();
	const formatDate_1 = requireFormatDate();
	const parseDate_1 = requireParseDate();
	const canonicalDomain_1 = requireCanonicalDomain();
	// From RFC6265 S4.1.1
	// note that it excludes \x3B ";"
	const COOKIE_OCTETS = /^[\x21\x23-\x2B\x2D-\x3A\x3C-\x5B\x5D-\x7E]+$/;
	// RFC6265 S4.1.1 defines path value as 'any CHAR except CTLs or ";"'
	// Note ';' is \x3B
	const PATH_VALUE = /[\x20-\x3A\x3C-\x7E]+/;
	// eslint-disable-next-line no-control-regex
	const CONTROL_CHARS = /[\x00-\x1F]/;
	// From Chromium // '\r', '\n' and '\0' should be treated as a terminator in
	// the "relaxed" mode, see:
	// https://github.com/ChromiumWebApps/chromium/blob/b3d3b4da8bb94c1b2e061600df106d590fda3620/net/cookies/parsed_cookie.cc#L60
	const TERMINATORS = ['\n', '\r', '\0'];
	function trimTerminator(str) {
	    if (validators.isEmptyString(str))
	        return str;
	    for (let t = 0; t < TERMINATORS.length; t++) {
	        const terminator = TERMINATORS[t];
	        const terminatorIdx = terminator ? str.indexOf(terminator) : -1;
	        if (terminatorIdx !== -1) {
	            str = str.slice(0, terminatorIdx);
	        }
	    }
	    return str;
	}
	function parseCookiePair(cookiePair, looseMode) {
	    cookiePair = trimTerminator(cookiePair);
	    let firstEq = cookiePair.indexOf('=');
	    if (looseMode) {
	        if (firstEq === 0) {
	            // '=' is immediately at start
	            cookiePair = cookiePair.substring(1);
	            firstEq = cookiePair.indexOf('='); // might still need to split on '='
	        }
	    }
	    else {
	        // non-loose mode
	        if (firstEq <= 0) {
	            // no '=' or is at start
	            return undefined; // needs to have non-empty "cookie-name"
	        }
	    }
	    let cookieName, cookieValue;
	    if (firstEq <= 0) {
	        cookieName = '';
	        cookieValue = cookiePair.trim();
	    }
	    else {
	        cookieName = cookiePair.slice(0, firstEq).trim();
	        cookieValue = cookiePair.slice(firstEq + 1).trim();
	    }
	    if (CONTROL_CHARS.test(cookieName) || CONTROL_CHARS.test(cookieValue)) {
	        return undefined;
	    }
	    const c = new Cookie();
	    c.key = cookieName;
	    c.value = cookieValue;
	    return c;
	}
	function parse(str, options) {
	    if (validators.isEmptyString(str) || !validators.isString(str)) {
	        return undefined;
	    }
	    str = str.trim();
	    // We use a regex to parse the "name-value-pair" part of S5.2
	    const firstSemi = str.indexOf(';'); // S5.2 step 1
	    const cookiePair = firstSemi === -1 ? str : str.slice(0, firstSemi);
	    const c = parseCookiePair(cookiePair, options?.loose ?? false);
	    if (!c) {
	        return undefined;
	    }
	    if (firstSemi === -1) {
	        return c;
	    }
	    // S5.2.3 "unparsed-attributes consist of the remainder of the set-cookie-string
	    // (including the %x3B (";") in question)." plus later on in the same section
	    // "discard the first ";" and trim".
	    const unparsed = str.slice(firstSemi + 1).trim();
	    // "If the unparsed-attributes string is empty, skip the rest of these
	    // steps."
	    if (unparsed.length === 0) {
	        return c;
	    }
	    /*
	     * S5.2 says that when looping over the items "[p]rocess the attribute-name
	     * and attribute-value according to the requirements in the following
	     * subsections" for every item.  Plus, for many of the individual attributes
	     * in S5.3 it says to use the "attribute-value of the last attribute in the
	     * cookie-attribute-list".  Therefore, in this implementation, we overwrite
	     * the previous value.
	     */
	    const cookie_avs = unparsed.split(';');
	    while (cookie_avs.length) {
	        const av = (cookie_avs.shift() ?? '').trim();
	        if (av.length === 0) {
	            // happens if ";;" appears
	            continue;
	        }
	        const av_sep = av.indexOf('=');
	        let av_key, av_value;
	        if (av_sep === -1) {
	            av_key = av;
	            av_value = null;
	        }
	        else {
	            av_key = av.slice(0, av_sep);
	            av_value = av.slice(av_sep + 1);
	        }
	        av_key = av_key.trim().toLowerCase();
	        if (av_value) {
	            av_value = av_value.trim();
	        }
	        switch (av_key) {
	            case 'expires': // S5.2.1
	                if (av_value) {
	                    const exp = (0, parseDate_1.parseDate)(av_value);
	                    // "If the attribute-value failed to parse as a cookie date, ignore the
	                    // cookie-av."
	                    if (exp) {
	                        // over and underflow not realistically a concern: V8's getTime() seems to
	                        // store something larger than a 32-bit time_t (even with 32-bit node)
	                        c.expires = exp;
	                    }
	                }
	                break;
	            case 'max-age': // S5.2.2
	                if (av_value) {
	                    // "If the first character of the attribute-value is not a DIGIT or a "-"
	                    // character ...[or]... If the remainder of attribute-value contains a
	                    // non-DIGIT character, ignore the cookie-av."
	                    if (/^-?[0-9]+$/.test(av_value)) {
	                        const delta = parseInt(av_value, 10);
	                        // "If delta-seconds is less than or equal to zero (0), let expiry-time
	                        // be the earliest representable date and time."
	                        c.setMaxAge(delta);
	                    }
	                }
	                break;
	            case 'domain': // S5.2.3
	                // "If the attribute-value is empty, the behavior is undefined.  However,
	                // the user agent SHOULD ignore the cookie-av entirely."
	                if (av_value) {
	                    // S5.2.3 "Let cookie-domain be the attribute-value without the leading %x2E
	                    // (".") character."
	                    const domain = av_value.trim().replace(/^\./, '');
	                    if (domain) {
	                        // "Convert the cookie-domain to lower case."
	                        c.domain = domain.toLowerCase();
	                    }
	                }
	                break;
	            case 'path': // S5.2.4
	                /*
	                 * "If the attribute-value is empty or if the first character of the
	                 * attribute-value is not %x2F ("/"):
	                 *   Let cookie-path be the default-path.
	                 * Otherwise:
	                 *   Let cookie-path be the attribute-value."
	                 *
	                 * We'll represent the default-path as null since it depends on the
	                 * context of the parsing.
	                 */
	                c.path = av_value && av_value[0] === '/' ? av_value : null;
	                break;
	            case 'secure': // S5.2.5
	                /*
	                 * "If the attribute-name case-insensitively matches the string "Secure",
	                 * the user agent MUST append an attribute to the cookie-attribute-list
	                 * with an attribute-name of Secure and an empty attribute-value."
	                 */
	                c.secure = true;
	                break;
	            case 'httponly': // S5.2.6 -- effectively the same as 'secure'
	                c.httpOnly = true;
	                break;
	            case 'samesite': // RFC6265bis-02 S5.3.7
	                switch (av_value ? av_value.toLowerCase() : '') {
	                    case 'strict':
	                        c.sameSite = 'strict';
	                        break;
	                    case 'lax':
	                        c.sameSite = 'lax';
	                        break;
	                    case 'none':
	                        c.sameSite = 'none';
	                        break;
	                    default:
	                        c.sameSite = undefined;
	                        break;
	                }
	                break;
	            default:
	                c.extensions = c.extensions || [];
	                c.extensions.push(av);
	                break;
	        }
	    }
	    return c;
	}
	function fromJSON(str) {
	    if (!str || validators.isEmptyString(str)) {
	        return undefined;
	    }
	    let obj;
	    if (typeof str === 'string') {
	        try {
	            obj = JSON.parse(str);
	        }
	        catch {
	            return undefined;
	        }
	    }
	    else {
	        // assume it's an Object
	        obj = str;
	    }
	    const c = new Cookie();
	    Cookie.serializableProperties.forEach((prop) => {
	        if (obj && typeof obj === 'object' && (0, utils_1.inOperator)(prop, obj)) {
	            const val = obj[prop];
	            if (val === undefined) {
	                return;
	            }
	            if ((0, utils_1.inOperator)(prop, cookieDefaults) && val === cookieDefaults[prop]) {
	                return;
	            }
	            switch (prop) {
	                case 'key':
	                case 'value':
	                case 'sameSite':
	                    if (typeof val === 'string') {
	                        c[prop] = val;
	                    }
	                    break;
	                case 'expires':
	                case 'creation':
	                case 'lastAccessed':
	                    if (typeof val === 'number' ||
	                        typeof val === 'string' ||
	                        val instanceof Date) {
	                        c[prop] = obj[prop] == 'Infinity' ? 'Infinity' : new Date(val);
	                    }
	                    else if (val === null) {
	                        c[prop] = null;
	                    }
	                    break;
	                case 'maxAge':
	                    if (typeof val === 'number' ||
	                        val === 'Infinity' ||
	                        val === '-Infinity') {
	                        c[prop] = val;
	                    }
	                    break;
	                case 'domain':
	                case 'path':
	                    if (typeof val === 'string' || val === null) {
	                        c[prop] = val;
	                    }
	                    break;
	                case 'secure':
	                case 'httpOnly':
	                    if (typeof val === 'boolean') {
	                        c[prop] = val;
	                    }
	                    break;
	                case 'extensions':
	                    if (Array.isArray(val) &&
	                        val.every((item) => typeof item === 'string')) {
	                        c[prop] = val;
	                    }
	                    break;
	                case 'hostOnly':
	                case 'pathIsDefault':
	                    if (typeof val === 'boolean' || val === null) {
	                        c[prop] = val;
	                    }
	                    break;
	            }
	        }
	    });
	    return c;
	}
	const cookieDefaults = {
	    // the order in which the RFC has them:
	    key: '',
	    value: '',
	    expires: 'Infinity',
	    maxAge: null,
	    domain: null,
	    path: null,
	    secure: false,
	    httpOnly: false,
	    extensions: null,
	    // set by the CookieJar:
	    hostOnly: null,
	    pathIsDefault: null,
	    creation: null,
	    lastAccessed: null,
	    sameSite: undefined,
	};
	/**
	 * An HTTP cookie (web cookie, browser cookie) is a small piece of data that a server sends to a user's web browser.
	 * It is defined in {@link https://www.rfc-editor.org/rfc/rfc6265.html | RFC6265}.
	 * @public
	 */
	class Cookie {
	    /**
	     * Create a new Cookie instance.
	     * @public
	     * @param options - The attributes to set on the cookie
	     */
	    constructor(options = {}) {
	        this.key = options.key ?? cookieDefaults.key;
	        this.value = options.value ?? cookieDefaults.value;
	        this.expires = options.expires ?? cookieDefaults.expires;
	        this.maxAge = options.maxAge ?? cookieDefaults.maxAge;
	        this.domain = options.domain ?? cookieDefaults.domain;
	        this.path = options.path ?? cookieDefaults.path;
	        this.secure = options.secure ?? cookieDefaults.secure;
	        this.httpOnly = options.httpOnly ?? cookieDefaults.httpOnly;
	        this.extensions = options.extensions ?? cookieDefaults.extensions;
	        this.creation = options.creation ?? cookieDefaults.creation;
	        this.hostOnly = options.hostOnly ?? cookieDefaults.hostOnly;
	        this.pathIsDefault = options.pathIsDefault ?? cookieDefaults.pathIsDefault;
	        this.lastAccessed = options.lastAccessed ?? cookieDefaults.lastAccessed;
	        this.sameSite = options.sameSite ?? cookieDefaults.sameSite;
	        this.creation = options.creation ?? new Date();
	        // used to break creation ties in cookieCompare():
	        Object.defineProperty(this, 'creationIndex', {
	            configurable: false,
	            enumerable: false, // important for assert.deepEqual checks
	            writable: true,
	            value: ++Cookie.cookiesCreated,
	        });
	        // Duplicate operation, but it makes TypeScript happy...
	        this.creationIndex = Cookie.cookiesCreated;
	    }
	    [Symbol.for('nodejs.util.inspect.custom')]() {
	        const now = Date.now();
	        const hostOnly = this.hostOnly != null ? this.hostOnly.toString() : '?';
	        const createAge = this.creation && this.creation !== 'Infinity'
	            ? `${String(now - this.creation.getTime())}ms`
	            : '?';
	        const accessAge = this.lastAccessed && this.lastAccessed !== 'Infinity'
	            ? `${String(now - this.lastAccessed.getTime())}ms`
	            : '?';
	        return `Cookie="${this.toString()}; hostOnly=${hostOnly}; aAge=${accessAge}; cAge=${createAge}"`;
	    }
	    /**
	     * For convenience in using `JSON.stringify(cookie)`. Returns a plain-old Object that can be JSON-serialized.
	     *
	     * @remarks
	     * - Any `Date` properties (such as {@link Cookie.expires}, {@link Cookie.creation}, and {@link Cookie.lastAccessed}) are exported in ISO format (`Date.toISOString()`).
	     *
	     *  - Custom Cookie properties are discarded. In tough-cookie 1.x, since there was no {@link Cookie.toJSON} method explicitly defined, all enumerable properties were captured.
	     *      If you want a property to be serialized, add the property name to {@link Cookie.serializableProperties}.
	     */
	    toJSON() {
	        const obj = {};
	        for (const prop of Cookie.serializableProperties) {
	            const val = this[prop];
	            if (val === cookieDefaults[prop]) {
	                continue; // leave as prototype default
	            }
	            switch (prop) {
	                case 'key':
	                case 'value':
	                case 'sameSite':
	                    if (typeof val === 'string') {
	                        obj[prop] = val;
	                    }
	                    break;
	                case 'expires':
	                case 'creation':
	                case 'lastAccessed':
	                    if (typeof val === 'number' ||
	                        typeof val === 'string' ||
	                        val instanceof Date) {
	                        obj[prop] =
	                            val == 'Infinity' ? 'Infinity' : new Date(val).toISOString();
	                    }
	                    else if (val === null) {
	                        obj[prop] = null;
	                    }
	                    break;
	                case 'maxAge':
	                    if (typeof val === 'number' ||
	                        val === 'Infinity' ||
	                        val === '-Infinity') {
	                        obj[prop] = val;
	                    }
	                    break;
	                case 'domain':
	                case 'path':
	                    if (typeof val === 'string' || val === null) {
	                        obj[prop] = val;
	                    }
	                    break;
	                case 'secure':
	                case 'httpOnly':
	                    if (typeof val === 'boolean') {
	                        obj[prop] = val;
	                    }
	                    break;
	                case 'extensions':
	                    if (Array.isArray(val)) {
	                        obj[prop] = val;
	                    }
	                    break;
	                case 'hostOnly':
	                case 'pathIsDefault':
	                    if (typeof val === 'boolean' || val === null) {
	                        obj[prop] = val;
	                    }
	                    break;
	            }
	        }
	        return obj;
	    }
	    /**
	     * Does a deep clone of this cookie, implemented exactly as `Cookie.fromJSON(cookie.toJSON())`.
	     * @public
	     */
	    clone() {
	        return fromJSON(this.toJSON());
	    }
	    /**
	     * Validates cookie attributes for semantic correctness. Useful for "lint" checking any `Set-Cookie` headers you generate.
	     * For now, it returns a boolean, but eventually could return a reason string.
	     *
	     * @remarks
	     * Works for a few things, but is by no means comprehensive.
	     *
	     * @beta
	     */
	    validate() {
	        if (!this.value || !COOKIE_OCTETS.test(this.value)) {
	            return false;
	        }
	        if (this.expires != 'Infinity' &&
	            !(this.expires instanceof Date) &&
	            !(0, parseDate_1.parseDate)(this.expires)) {
	            return false;
	        }
	        if (this.maxAge != null &&
	            this.maxAge !== 'Infinity' &&
	            (this.maxAge === '-Infinity' || this.maxAge <= 0)) {
	            return false; // "Max-Age=" non-zero-digit *DIGIT
	        }
	        if (this.path != null && !PATH_VALUE.test(this.path)) {
	            return false;
	        }
	        const cdomain = this.cdomain();
	        if (cdomain) {
	            if (cdomain.match(/\.$/)) {
	                return false; // S4.1.2.3 suggests that this is bad. domainMatch() tests confirm this
	            }
	            const suffix = (0, getPublicSuffix_1.getPublicSuffix)(cdomain);
	            if (suffix == null) {
	                // it's a public suffix
	                return false;
	            }
	        }
	        return true;
	    }
	    /**
	     * Sets the 'Expires' attribute on a cookie.
	     *
	     * @remarks
	     * When given a `string` value it will be parsed with {@link parseDate}. If the value can't be parsed as a cookie date
	     * then the 'Expires' attribute will be set to `"Infinity"`.
	     *
	     * @param exp - the new value for the 'Expires' attribute of the cookie.
	     */
	    setExpires(exp) {
	        if (exp instanceof Date) {
	            this.expires = exp;
	        }
	        else {
	            this.expires = (0, parseDate_1.parseDate)(exp) || 'Infinity';
	        }
	    }
	    /**
	     * Sets the 'Max-Age' attribute (in seconds) on a cookie.
	     *
	     * @remarks
	     * Coerces `-Infinity` to `"-Infinity"` and `Infinity` to `"Infinity"` so it can be serialized to JSON.
	     *
	     * @param age - the new value for the 'Max-Age' attribute (in seconds).
	     */
	    setMaxAge(age) {
	        if (age === Infinity) {
	            this.maxAge = 'Infinity';
	        }
	        else if (age === -Infinity) {
	            this.maxAge = '-Infinity';
	        }
	        else {
	            this.maxAge = age;
	        }
	    }
	    /**
	     * Encodes to a `Cookie` header value (specifically, the {@link Cookie.key} and {@link Cookie.value} properties joined with "=").
	     * @public
	     */
	    cookieString() {
	        const val = this.value || '';
	        if (this.key) {
	            return `${this.key}=${val}`;
	        }
	        return val;
	    }
	    /**
	     * Encodes to a `Set-Cookie header` value.
	     * @public
	     */
	    toString() {
	        let str = this.cookieString();
	        if (this.expires != 'Infinity') {
	            if (this.expires instanceof Date) {
	                str += `; Expires=${(0, formatDate_1.formatDate)(this.expires)}`;
	            }
	        }
	        if (this.maxAge != null && this.maxAge != Infinity) {
	            str += `; Max-Age=${String(this.maxAge)}`;
	        }
	        if (this.domain && !this.hostOnly) {
	            str += `; Domain=${this.domain}`;
	        }
	        if (this.path) {
	            str += `; Path=${this.path}`;
	        }
	        if (this.secure) {
	            str += '; Secure';
	        }
	        if (this.httpOnly) {
	            str += '; HttpOnly';
	        }
	        if (this.sameSite && this.sameSite !== 'none') {
	            if (this.sameSite.toLowerCase() ===
	                Cookie.sameSiteCanonical.lax.toLowerCase()) {
	                str += `; SameSite=${Cookie.sameSiteCanonical.lax}`;
	            }
	            else if (this.sameSite.toLowerCase() ===
	                Cookie.sameSiteCanonical.strict.toLowerCase()) {
	                str += `; SameSite=${Cookie.sameSiteCanonical.strict}`;
	            }
	            else {
	                str += `; SameSite=${this.sameSite}`;
	            }
	        }
	        if (this.extensions) {
	            this.extensions.forEach((ext) => {
	                str += `; ${ext}`;
	            });
	        }
	        return str;
	    }
	    /**
	     * Computes the TTL relative to now (milliseconds).
	     *
	     * @remarks
	     * - `Infinity` is returned for cookies without an explicit expiry
	     *
	     * - `0` is returned if the cookie is expired.
	     *
	     * - Otherwise a time-to-live in milliseconds is returned.
	     *
	     * @param now - passing an explicit value is mostly used for testing purposes since this defaults to the `Date.now()`
	     * @public
	     */
	    TTL(now = Date.now()) {
	        // TTL() partially replaces the "expiry-time" parts of S5.3 step 3 (setCookie()
	        // elsewhere)
	        // S5.3 says to give the "latest representable date" for which we use Infinity
	        // For "expired" we use 0
	        // -----
	        // RFC6265 S4.1.2.2 If a cookie has both the Max-Age and the Expires
	        // attribute, the Max-Age attribute has precedence and controls the
	        // expiration date of the cookie.
	        // (Concurs with S5.3 step 3)
	        if (this.maxAge != null && typeof this.maxAge === 'number') {
	            return this.maxAge <= 0 ? 0 : this.maxAge * 1000;
	        }
	        const expires = this.expires;
	        if (expires === 'Infinity') {
	            return Infinity;
	        }
	        return (expires?.getTime() ?? now) - (now || Date.now());
	    }
	    /**
	     * Computes the absolute unix-epoch milliseconds that this cookie expires.
	     *
	     * The "Max-Age" attribute takes precedence over "Expires" (as per the RFC). The {@link Cookie.lastAccessed} attribute
	     * (or the `now` parameter if given) is used to offset the {@link Cookie.maxAge} attribute.
	     *
	     * If Expires ({@link Cookie.expires}) is set, that's returned.
	     *
	     * @param now - can be used to provide a time offset (instead of {@link Cookie.lastAccessed}) to use when calculating the "Max-Age" value
	     */
	    expiryTime(now) {
	        // expiryTime() replaces the "expiry-time" parts of S5.3 step 3 (setCookie() elsewhere)
	        if (this.maxAge != null) {
	            const relativeTo = now || this.lastAccessed || new Date();
	            const maxAge = typeof this.maxAge === 'number' ? this.maxAge : -Infinity;
	            const age = maxAge <= 0 ? -Infinity : maxAge * 1000;
	            if (relativeTo === 'Infinity') {
	                return Infinity;
	            }
	            return relativeTo.getTime() + age;
	        }
	        if (this.expires == 'Infinity') {
	            return Infinity;
	        }
	        return this.expires ? this.expires.getTime() : undefined;
	    }
	    /**
	     * Indicates if the cookie has been persisted to a store or not.
	     * @public
	     */
	    isPersistent() {
	        // This replaces the "persistent-flag" parts of S5.3 step 3
	        return this.maxAge != null || this.expires != 'Infinity';
	    }
	    /**
	     * Calls {@link canonicalDomain} with the {@link Cookie.domain} property.
	     * @public
	     */
	    canonicalizedDomain() {
	        // Mostly S5.1.2 and S5.2.3:
	        return (0, canonicalDomain_1.canonicalDomain)(this.domain);
	    }
	    /**
	     * Alias for {@link Cookie.canonicalizedDomain}
	     * @public
	     */
	    cdomain() {
	        return (0, canonicalDomain_1.canonicalDomain)(this.domain);
	    }
	    /**
	     * Parses a string into a Cookie object.
	     *
	     * @remarks
	     * Note: when parsing a `Cookie` header it must be split by ';' before each Cookie string can be parsed.
	     *
	     * @example
	     * ```
	     * // parse a `Set-Cookie` header
	     * const setCookieHeader = 'a=bcd; Expires=Tue, 18 Oct 2011 07:05:03 GMT'
	     * const cookie = Cookie.parse(setCookieHeader)
	     * cookie.key === 'a'
	     * cookie.value === 'bcd'
	     * cookie.expires === new Date(Date.parse('Tue, 18 Oct 2011 07:05:03 GMT'))
	     * ```
	     *
	     * @example
	     * ```
	     * // parse a `Cookie` header
	     * const cookieHeader = 'name=value; name2=value2; name3=value3'
	     * const cookies = cookieHeader.split(';').map(Cookie.parse)
	     * cookies[0].name === 'name'
	     * cookies[0].value === 'value'
	     * cookies[1].name === 'name2'
	     * cookies[1].value === 'value2'
	     * cookies[2].name === 'name3'
	     * cookies[2].value === 'value3'
	     * ```
	     *
	     * @param str - The `Set-Cookie` header or a Cookie string to parse.
	     * @param options - Configures `strict` or `loose` mode for cookie parsing
	     */
	    static parse(str, options) {
	        return parse(str, options);
	    }
	    /**
	     * Does the reverse of {@link Cookie.toJSON}.
	     *
	     * @remarks
	     * Any Date properties (such as .expires, .creation, and .lastAccessed) are parsed via Date.parse, not tough-cookie's parseDate, since ISO timestamps are being handled at this layer.
	     *
	     * @example
	     * ```
	     * const json = JSON.stringify({
	     *   key: 'alpha',
	     *   value: 'beta',
	     *   domain: 'example.com',
	     *   path: '/foo',
	     *   expires: '2038-01-19T03:14:07.000Z',
	     * })
	     * const cookie = Cookie.fromJSON(json)
	     * cookie.key === 'alpha'
	     * cookie.value === 'beta'
	     * cookie.domain === 'example.com'
	     * cookie.path === '/foo'
	     * cookie.expires === new Date(Date.parse('2038-01-19T03:14:07.000Z'))
	     * ```
	     *
	     * @param str - An unparsed JSON string or a value that has already been parsed as JSON
	     */
	    static fromJSON(str) {
	        return fromJSON(str);
	    }
	}
	cookie.Cookie = Cookie;
	Cookie.cookiesCreated = 0;
	/**
	 * @internal
	 */
	Cookie.sameSiteLevel = {
	    strict: 3,
	    lax: 2,
	    none: 1,
	};
	/**
	 * @internal
	 */
	Cookie.sameSiteCanonical = {
	    strict: 'Strict',
	    lax: 'Lax',
	};
	/**
	 * Cookie properties that will be serialized when using {@link Cookie.fromJSON} and {@link Cookie.toJSON}.
	 * @public
	 */
	Cookie.serializableProperties = [
	    'key',
	    'value',
	    'expires',
	    'maxAge',
	    'domain',
	    'path',
	    'secure',
	    'httpOnly',
	    'extensions',
	    'hostOnly',
	    'pathIsDefault',
	    'creation',
	    'lastAccessed',
	    'sameSite',
	];
	return cookie;
}

var cookieCompare = {};

var hasRequiredCookieCompare;

function requireCookieCompare () {
	if (hasRequiredCookieCompare) return cookieCompare;
	hasRequiredCookieCompare = 1;
	Object.defineProperty(cookieCompare, "__esModule", { value: true });
	cookieCompare.cookieCompare = cookieCompare$1;
	/**
	 * The maximum timestamp a cookie, in milliseconds. The value is (2^31 - 1) seconds since the Unix
	 * epoch, corresponding to 2038-01-19.
	 */
	const MAX_TIME = 2147483647000;
	/**
	 * A comparison function that can be used with {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort | Array.sort()},
	 * which orders a list of cookies into the recommended order given in Step 2 of {@link https://www.rfc-editor.org/rfc/rfc6265.html#section-5.4 | RFC6265 - Section 5.4}.
	 *
	 * The sort algorithm is, in order of precedence:
	 *
	 * - Longest {@link Cookie.path}
	 *
	 * - Oldest {@link Cookie.creation} (which has a 1-ms precision, same as Date)
	 *
	 * - Lowest {@link Cookie.creationIndex} (to get beyond the 1-ms precision)
	 *
	 * @remarks
	 * ### RFC6265 - Section 5.4 - Step 2
	 *
	 * The user agent SHOULD sort the cookie-list in the following order:
	 *
	 * - Cookies with longer paths are listed before cookies with shorter paths.
	 *
	 * - Among cookies that have equal-length path fields, cookies with
	 *    earlier creation-times are listed before cookies with later
	 *    creation-times.
	 *
	 * NOTE: Not all user agents sort the cookie-list in this order, but
	 * this order reflects common practice when this document was
	 * written, and, historically, there have been servers that
	 * (erroneously) depended on this order.
	 *
	 * ### Custom Store Implementors
	 *
	 * Since the JavaScript Date is limited to a 1-ms precision, cookies within the same millisecond are entirely possible.
	 * This is especially true when using the `now` option to `CookieJar.setCookie(...)`. The {@link Cookie.creationIndex}
	 * property is a per-process global counter, assigned during construction with `new Cookie()`, which preserves the spirit
	 * of the RFC sorting: older cookies go first. This works great for {@link MemoryCookieStore} since `Set-Cookie` headers
	 * are parsed in order, but is not so great for distributed systems.
	 *
	 * Sophisticated Stores may wish to set this to some other
	 * logical clock so that if cookies `A` and `B` are created in the same millisecond, but cookie `A` is created before
	 * cookie `B`, then `A.creationIndex < B.creationIndex`.
	 *
	 * @example
	 * ```
	 * const cookies = [
	 *   new Cookie({ key: 'a', value: '' }),
	 *   new Cookie({ key: 'b', value: '' }),
	 *   new Cookie({ key: 'c', value: '', path: '/path' }),
	 *   new Cookie({ key: 'd', value: '', path: '/path' }),
	 * ]
	 * cookies.sort(cookieCompare)
	 * // cookie sort order would be ['c', 'd', 'a', 'b']
	 * ```
	 *
	 * @param a - the first Cookie for comparison
	 * @param b - the second Cookie for comparison
	 * @public
	 */
	function cookieCompare$1(a, b) {
	    let cmp;
	    // descending for length: b CMP a
	    const aPathLen = a.path ? a.path.length : 0;
	    const bPathLen = b.path ? b.path.length : 0;
	    cmp = bPathLen - aPathLen;
	    if (cmp !== 0) {
	        return cmp;
	    }
	    // ascending for time: a CMP b
	    const aTime = a.creation && a.creation instanceof Date ? a.creation.getTime() : MAX_TIME;
	    const bTime = b.creation && b.creation instanceof Date ? b.creation.getTime() : MAX_TIME;
	    cmp = aTime - bTime;
	    if (cmp !== 0) {
	        return cmp;
	    }
	    // break ties for the same millisecond (precision of JavaScript's clock)
	    cmp = (a.creationIndex || 0) - (b.creationIndex || 0);
	    return cmp;
	}
	return cookieCompare;
}

var cookieJar = {};

var defaultPath = {};

var hasRequiredDefaultPath;

function requireDefaultPath () {
	if (hasRequiredDefaultPath) return defaultPath;
	hasRequiredDefaultPath = 1;
	Object.defineProperty(defaultPath, "__esModule", { value: true });
	defaultPath.defaultPath = defaultPath$1;
	/**
	 * Given a current request/response path, gives the path appropriate for storing
	 * in a cookie. This is basically the "directory" of a "file" in the path, but
	 * is specified by {@link https://www.rfc-editor.org/rfc/rfc6265.html#section-5.1.4 | RFC6265 - Section 5.1.4}.
	 *
	 * @remarks
	 * ### RFC6265 - Section 5.1.4
	 *
	 * The user agent MUST use an algorithm equivalent to the following algorithm to compute the default-path of a cookie:
	 *
	 * 1. Let uri-path be the path portion of the request-uri if such a
	 *     portion exists (and empty otherwise).  For example, if the
	 *     request-uri contains just a path (and optional query string),
	 *     then the uri-path is that path (without the %x3F ("?") character
	 *     or query string), and if the request-uri contains a full
	 *     absoluteURI, the uri-path is the path component of that URI.
	 *
	 * 2. If the uri-path is empty or if the first character of the uri-
	 *     path is not a %x2F ("/") character, output %x2F ("/") and skip
	 *     the remaining steps.
	 *
	 * 3. If the uri-path contains no more than one %x2F ("/") character,
	 *     output %x2F ("/") and skip the remaining step.
	 *
	 * 4. Output the characters of the uri-path from the first character up
	 *     to, but not including, the right-most %x2F ("/").
	 *
	 * @example
	 * ```
	 * defaultPath('') === '/'
	 * defaultPath('/some-path') === '/'
	 * defaultPath('/some-parent-path/some-path') === '/some-parent-path'
	 * defaultPath('relative-path') === '/'
	 * ```
	 *
	 * @param path - the path portion of the request-uri (excluding the hostname, query, fragment, and so on)
	 * @public
	 */
	function defaultPath$1(path) {
	    // "2. If the uri-path is empty or if the first character of the uri-path is not
	    // a %x2F ("/") character, output %x2F ("/") and skip the remaining steps.
	    if (!path || path.slice(0, 1) !== '/') {
	        return '/';
	    }
	    // "3. If the uri-path contains no more than one %x2F ("/") character, output
	    // %x2F ("/") and skip the remaining step."
	    if (path === '/') {
	        return path;
	    }
	    const rightSlash = path.lastIndexOf('/');
	    if (rightSlash === 0) {
	        return '/';
	    }
	    // "4. Output the characters of the uri-path from the first character up to,
	    // but not including, the right-most %x2F ("/")."
	    return path.slice(0, rightSlash);
	}
	return defaultPath;
}

var domainMatch = {};

var hasRequiredDomainMatch;

function requireDomainMatch () {
	if (hasRequiredDomainMatch) return domainMatch;
	hasRequiredDomainMatch = 1;
	Object.defineProperty(domainMatch, "__esModule", { value: true });
	domainMatch.domainMatch = domainMatch$1;
	const canonicalDomain_1 = requireCanonicalDomain();
	// Dumped from ip-regex@4.0.0, with the following changes:
	// * all capturing groups converted to non-capturing -- "(?:)"
	// * support for IPv6 Scoped Literal ("%eth1") removed
	// * lowercase hexadecimal only
	const IP_REGEX_LOWERCASE = /(?:^(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}$)|(?:^(?:(?:[a-f\d]{1,4}:){7}(?:[a-f\d]{1,4}|:)|(?:[a-f\d]{1,4}:){6}(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|:[a-f\d]{1,4}|:)|(?:[a-f\d]{1,4}:){5}(?::(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,2}|:)|(?:[a-f\d]{1,4}:){4}(?:(?::[a-f\d]{1,4}){0,1}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,3}|:)|(?:[a-f\d]{1,4}:){3}(?:(?::[a-f\d]{1,4}){0,2}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,4}|:)|(?:[a-f\d]{1,4}:){2}(?:(?::[a-f\d]{1,4}){0,3}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,5}|:)|(?:[a-f\d]{1,4}:){1}(?:(?::[a-f\d]{1,4}){0,4}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,6}|:)|(?::(?:(?::[a-f\d]{1,4}){0,5}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,7}|:)))$)/;
	/**
	 * Answers "does this real domain match the domain in a cookie?". The `domain` is the "current" domain name and the
	 * `cookieDomain` is the "cookie" domain name. Matches according to {@link https://www.rfc-editor.org/rfc/rfc6265.html#section-5.1.3 | RFC6265 - Section 5.1.3},
	 * but it helps to think of it as a "suffix match".
	 *
	 * @remarks
	 * ### 5.1.3.  Domain Matching
	 *
	 * A string domain-matches a given domain string if at least one of the
	 * following conditions hold:
	 *
	 * - The domain string and the string are identical.  (Note that both
	 *     the domain string and the string will have been canonicalized to
	 *     lower case at this point.)
	 *
	 * - All of the following conditions hold:
	 *
	 *     - The domain string is a suffix of the string.
	 *
	 *     - The last character of the string that is not included in the
	 *         domain string is a %x2E (".") character.
	 *
	 *     - The string is a host name (i.e., not an IP address).
	 *
	 * @example
	 * ```
	 * domainMatch('example.com', 'example.com') === true
	 * domainMatch('eXaMpLe.cOm', 'ExAmPlE.CoM') === true
	 * domainMatch('no.ca', 'yes.ca') === false
	 * ```
	 *
	 * @param domain - The domain string to test
	 * @param cookieDomain - The cookie domain string to match against
	 * @param canonicalize - The canonicalize parameter toggles whether the domain parameters get normalized with canonicalDomain or not
	 * @public
	 */
	function domainMatch$1(domain, cookieDomain, canonicalize) {
	    if (domain == null || cookieDomain == null) {
	        return undefined;
	    }
	    let _str;
	    let _domStr;
	    if (canonicalize !== false) {
	        _str = (0, canonicalDomain_1.canonicalDomain)(domain);
	        _domStr = (0, canonicalDomain_1.canonicalDomain)(cookieDomain);
	    }
	    else {
	        _str = domain;
	        _domStr = cookieDomain;
	    }
	    if (_str == null || _domStr == null) {
	        return undefined;
	    }
	    /*
	     * S5.1.3:
	     * "A string domain-matches a given domain string if at least one of the
	     * following conditions hold:"
	     *
	     * " o The domain string and the string are identical. (Note that both the
	     * domain string and the string will have been canonicalized to lower case at
	     * this point)"
	     */
	    if (_str == _domStr) {
	        return true;
	    }
	    /* " o All of the following [three] conditions hold:" */
	    /* "* The domain string is a suffix of the string" */
	    const idx = _str.lastIndexOf(cookieDomain);
	    if (idx <= 0) {
	        return false; // it's a non-match (-1) or prefix (0)
	    }
	    // next, check it's a proper suffix
	    // e.g., "a.b.c".indexOf("b.c") === 2
	    // 5 === 3+2
	    if (_str.length !== _domStr.length + idx) {
	        return false; // it's not a suffix
	    }
	    /* "  * The last character of the string that is not included in the
	     * domain string is a %x2E (".") character." */
	    if (_str.substring(idx - 1, idx) !== '.') {
	        return false; // doesn't align on "."
	    }
	    /* "  * The string is a host name (i.e., not an IP address)." */
	    return !IP_REGEX_LOWERCASE.test(_str);
	}
	return domainMatch;
}

var hasRequiredCookieJar;

function requireCookieJar () {
	if (hasRequiredCookieJar) return cookieJar;
	hasRequiredCookieJar = 1;
	var __createBinding = (cookieJar && cookieJar.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (cookieJar && cookieJar.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (cookieJar && cookieJar.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(cookieJar, "__esModule", { value: true });
	cookieJar.CookieJar = void 0;
	const getPublicSuffix_1 = requireGetPublicSuffix();
	const validators = __importStar(requireValidators());
	const validators_1 = requireValidators();
	const store_1 = requireStore();
	const memstore_1 = requireMemstore();
	const pathMatch_1 = requirePathMatch();
	const cookie_1 = requireCookie$1();
	const utils_1 = requireUtils();
	const canonicalDomain_1 = requireCanonicalDomain();
	const constants_1 = requireConstants();
	const defaultPath_1 = requireDefaultPath();
	const domainMatch_1 = requireDomainMatch();
	const cookieCompare_1 = requireCookieCompare();
	const version_1 = requireVersion();
	const defaultSetCookieOptions = {
	    loose: false,
	    sameSiteContext: undefined,
	    ignoreError: false,
	    http: true,
	};
	const defaultGetCookieOptions = {
	    http: true,
	    expire: true,
	    allPaths: false,
	    sameSiteContext: undefined,
	    sort: undefined,
	};
	const SAME_SITE_CONTEXT_VAL_ERR = 'Invalid sameSiteContext option for getCookies(); expected one of "strict", "lax", or "none"';
	function getCookieContext(url) {
	    if (url &&
	        typeof url === 'object' &&
	        'hostname' in url &&
	        typeof url.hostname === 'string' &&
	        'pathname' in url &&
	        typeof url.pathname === 'string' &&
	        'protocol' in url &&
	        typeof url.protocol === 'string') {
	        return {
	            hostname: url.hostname,
	            pathname: url.pathname,
	            protocol: url.protocol,
	        };
	    }
	    else if (typeof url === 'string') {
	        try {
	            return new URL(decodeURI(url));
	        }
	        catch {
	            return new URL(url);
	        }
	    }
	    else {
	        throw new validators_1.ParameterError('`url` argument is not a string or URL.');
	    }
	}
	function checkSameSiteContext(value) {
	    const context = String(value).toLowerCase();
	    if (context === 'none' || context === 'lax' || context === 'strict') {
	        return context;
	    }
	    else {
	        return undefined;
	    }
	}
	/**
	 *  If the cookie-name begins with a case-sensitive match for the
	 *  string "__Secure-", abort these steps and ignore the cookie
	 *  entirely unless the cookie's secure-only-flag is true.
	 * @param cookie
	 * @returns boolean
	 */
	function isSecurePrefixConditionMet(cookie) {
	    const startsWithSecurePrefix = typeof cookie.key === 'string' && cookie.key.startsWith('__Secure-');
	    return !startsWithSecurePrefix || cookie.secure;
	}
	/**
	 *  If the cookie-name begins with a case-sensitive match for the
	 *  string "__Host-", abort these steps and ignore the cookie
	 *  entirely unless the cookie meets all the following criteria:
	 *    1.  The cookie's secure-only-flag is true.
	 *    2.  The cookie's host-only-flag is true.
	 *    3.  The cookie-attribute-list contains an attribute with an
	 *        attribute-name of "Path", and the cookie's path is "/".
	 * @param cookie
	 * @returns boolean
	 */
	function isHostPrefixConditionMet(cookie) {
	    const startsWithHostPrefix = typeof cookie.key === 'string' && cookie.key.startsWith('__Host-');
	    return (!startsWithHostPrefix ||
	        Boolean(cookie.secure &&
	            cookie.hostOnly &&
	            cookie.path != null &&
	            cookie.path === '/'));
	}
	function getNormalizedPrefixSecurity(prefixSecurity) {
	    const normalizedPrefixSecurity = prefixSecurity.toLowerCase();
	    /* The three supported options */
	    switch (normalizedPrefixSecurity) {
	        case constants_1.PrefixSecurityEnum.STRICT:
	        case constants_1.PrefixSecurityEnum.SILENT:
	        case constants_1.PrefixSecurityEnum.DISABLED:
	            return normalizedPrefixSecurity;
	        default:
	            return constants_1.PrefixSecurityEnum.SILENT;
	    }
	}
	/**
	 * A CookieJar is for storage and retrieval of {@link Cookie} objects as defined in
	 * {@link https://www.rfc-editor.org/rfc/rfc6265.html#section-5.3 | RFC6265 - Section 5.3}.
	 *
	 * It also supports a pluggable persistence layer via {@link Store}.
	 * @public
	 */
	class CookieJar {
	    /**
	     * Creates a new `CookieJar` instance.
	     *
	     * @remarks
	     * - If a custom store is not passed to the constructor, an in-memory store ({@link MemoryCookieStore} will be created and used.
	     * - If a boolean value is passed as the `options` parameter, this is equivalent to passing `{ rejectPublicSuffixes: <value> }`
	     *
	     * @param store - a custom {@link Store} implementation (defaults to {@link MemoryCookieStore})
	     * @param options - configures how cookies are processed by the cookie jar
	     */
	    constructor(store, options) {
	        if (typeof options === 'boolean') {
	            options = { rejectPublicSuffixes: options };
	        }
	        this.rejectPublicSuffixes = options?.rejectPublicSuffixes ?? true;
	        this.enableLooseMode = options?.looseMode ?? false;
	        this.allowSpecialUseDomain = options?.allowSpecialUseDomain ?? true;
	        this.prefixSecurity = getNormalizedPrefixSecurity(options?.prefixSecurity ?? 'silent');
	        this.store = store ?? new memstore_1.MemoryCookieStore();
	    }
	    callSync(fn) {
	        if (!this.store.synchronous) {
	            throw new Error('CookieJar store is not synchronous; use async API instead.');
	        }
	        let syncErr = null;
	        let syncResult = undefined;
	        try {
	            fn.call(this, (error, result) => {
	                syncErr = error;
	                syncResult = result;
	            });
	        }
	        catch (err) {
	            syncErr = err;
	        }
	        if (syncErr)
	            throw syncErr;
	        return syncResult;
	    }
	    /**
	     * @internal No doc because this is the overload implementation
	     */
	    setCookie(cookie, url, options, callback) {
	        if (typeof options === 'function') {
	            callback = options;
	            options = undefined;
	        }
	        const promiseCallback = (0, utils_1.createPromiseCallback)(callback);
	        const cb = promiseCallback.callback;
	        let context;
	        try {
	            if (typeof url === 'string') {
	                validators.validate(validators.isNonEmptyString(url), callback, (0, utils_1.safeToString)(options));
	            }
	            context = getCookieContext(url);
	            if (typeof url === 'function') {
	                return promiseCallback.reject(new Error('No URL was specified'));
	            }
	            if (typeof options === 'function') {
	                options = defaultSetCookieOptions;
	            }
	            validators.validate(typeof cb === 'function', cb);
	            if (!validators.isNonEmptyString(cookie) &&
	                !validators.isObject(cookie) &&
	                cookie instanceof String &&
	                cookie.length == 0) {
	                return promiseCallback.resolve(undefined);
	            }
	        }
	        catch (err) {
	            return promiseCallback.reject(err);
	        }
	        const host = (0, canonicalDomain_1.canonicalDomain)(context.hostname) ?? null;
	        const loose = options?.loose || this.enableLooseMode;
	        let sameSiteContext = null;
	        if (options?.sameSiteContext) {
	            sameSiteContext = checkSameSiteContext(options.sameSiteContext);
	            if (!sameSiteContext) {
	                return promiseCallback.reject(new Error(SAME_SITE_CONTEXT_VAL_ERR));
	            }
	        }
	        // S5.3 step 1
	        if (typeof cookie === 'string' || cookie instanceof String) {
	            const parsedCookie = cookie_1.Cookie.parse(cookie.toString(), { loose: loose });
	            if (!parsedCookie) {
	                const err = new Error('Cookie failed to parse');
	                return options?.ignoreError
	                    ? promiseCallback.resolve(undefined)
	                    : promiseCallback.reject(err);
	            }
	            cookie = parsedCookie;
	        }
	        else if (!(cookie instanceof cookie_1.Cookie)) {
	            // If you're seeing this error, and are passing in a Cookie object,
	            // it *might* be a Cookie object from another loaded version of tough-cookie.
	            const err = new Error('First argument to setCookie must be a Cookie object or string');
	            return options?.ignoreError
	                ? promiseCallback.resolve(undefined)
	                : promiseCallback.reject(err);
	        }
	        // S5.3 step 2
	        const now = options?.now || new Date(); // will assign later to save effort in the face of errors
	        // S5.3 step 3: NOOP; persistent-flag and expiry-time is handled by getCookie()
	        // S5.3 step 4: NOOP; domain is null by default
	        // S5.3 step 5: public suffixes
	        if (this.rejectPublicSuffixes && cookie.domain) {
	            try {
	                const cdomain = cookie.cdomain();
	                const suffix = typeof cdomain === 'string'
	                    ? (0, getPublicSuffix_1.getPublicSuffix)(cdomain, {
	                        allowSpecialUseDomain: this.allowSpecialUseDomain,
	                        ignoreError: options?.ignoreError,
	                    })
	                    : null;
	                if (suffix == null && !constants_1.IP_V6_REGEX_OBJECT.test(cookie.domain)) {
	                    // e.g. "com"
	                    const err = new Error('Cookie has domain set to a public suffix');
	                    return options?.ignoreError
	                        ? promiseCallback.resolve(undefined)
	                        : promiseCallback.reject(err);
	                }
	                // Using `any` here rather than `unknown` to avoid a type assertion, at the cost of needing
	                // to disable eslint directives. It's easier to have this one spot of technically incorrect
	                // types, rather than having to deal with _all_ callback errors being `unknown`.
	                // eslint-disable-next-line @typescript-eslint/no-explicit-any
	            }
	            catch (err) {
	                return options?.ignoreError
	                    ? promiseCallback.resolve(undefined)
	                    : // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
	                        promiseCallback.reject(err);
	            }
	        }
	        // S5.3 step 6:
	        if (cookie.domain) {
	            if (!(0, domainMatch_1.domainMatch)(host ?? undefined, cookie.cdomain() ?? undefined, false)) {
	                const err = new Error(`Cookie not in this host's domain. Cookie:${cookie.cdomain() ?? 'null'} Request:${host ?? 'null'}`);
	                return options?.ignoreError
	                    ? promiseCallback.resolve(undefined)
	                    : promiseCallback.reject(err);
	            }
	            if (cookie.hostOnly == null) {
	                // don't reset if already set
	                cookie.hostOnly = false;
	            }
	        }
	        else {
	            cookie.hostOnly = true;
	            cookie.domain = host;
	        }
	        //S5.2.4 If the attribute-value is empty or if the first character of the
	        //attribute-value is not %x2F ("/"):
	        //Let cookie-path be the default-path.
	        if (!cookie.path || cookie.path[0] !== '/') {
	            cookie.path = (0, defaultPath_1.defaultPath)(context.pathname);
	            cookie.pathIsDefault = true;
	        }
	        // S5.3 step 8: NOOP; secure attribute
	        // S5.3 step 9: NOOP; httpOnly attribute
	        // S5.3 step 10
	        if (options?.http === false && cookie.httpOnly) {
	            const err = new Error("Cookie is HttpOnly and this isn't an HTTP API");
	            return options.ignoreError
	                ? promiseCallback.resolve(undefined)
	                : promiseCallback.reject(err);
	        }
	        // 6252bis-02 S5.4 Step 13 & 14:
	        if (cookie.sameSite !== 'none' &&
	            cookie.sameSite !== undefined &&
	            sameSiteContext) {
	            // "If the cookie's "same-site-flag" is not "None", and the cookie
	            //  is being set from a context whose "site for cookies" is not an
	            //  exact match for request-uri's host's registered domain, then
	            //  abort these steps and ignore the newly created cookie entirely."
	            if (sameSiteContext === 'none') {
	                const err = new Error('Cookie is SameSite but this is a cross-origin request');
	                return options?.ignoreError
	                    ? promiseCallback.resolve(undefined)
	                    : promiseCallback.reject(err);
	            }
	        }
	        /* 6265bis-02 S5.4 Steps 15 & 16 */
	        const ignoreErrorForPrefixSecurity = this.prefixSecurity === constants_1.PrefixSecurityEnum.SILENT;
	        const prefixSecurityDisabled = this.prefixSecurity === constants_1.PrefixSecurityEnum.DISABLED;
	        /* If prefix checking is not disabled ...*/
	        if (!prefixSecurityDisabled) {
	            let errorFound = false;
	            let errorMsg;
	            /* Check secure prefix condition */
	            if (!isSecurePrefixConditionMet(cookie)) {
	                errorFound = true;
	                errorMsg = 'Cookie has __Secure prefix but Secure attribute is not set';
	            }
	            else if (!isHostPrefixConditionMet(cookie)) {
	                /* Check host prefix condition */
	                errorFound = true;
	                errorMsg =
	                    "Cookie has __Host prefix but either Secure or HostOnly attribute is not set or Path is not '/'";
	            }
	            if (errorFound) {
	                return options?.ignoreError || ignoreErrorForPrefixSecurity
	                    ? promiseCallback.resolve(undefined)
	                    : promiseCallback.reject(new Error(errorMsg));
	            }
	        }
	        const store = this.store;
	        // TODO: It feels weird to be manipulating the store as a side effect of a method.
	        // We should either do it in the constructor or not at all.
	        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
	        if (!store.updateCookie) {
	            store.updateCookie = async function (_oldCookie, newCookie, cb) {
	                return this.putCookie(newCookie).then(() => cb?.(null), (error) => cb?.(error));
	            };
	        }
	        const withCookie = function withCookie(err, oldCookie) {
	            if (err) {
	                cb(err);
	                return;
	            }
	            const next = function (err) {
	                if (err) {
	                    cb(err);
	                }
	                else if (typeof cookie === 'string') {
	                    cb(null, undefined);
	                }
	                else {
	                    cb(null, cookie);
	                }
	            };
	            if (oldCookie) {
	                // S5.3 step 11 - "If the cookie store contains a cookie with the same name,
	                // domain, and path as the newly created cookie:"
	                if (options &&
	                    'http' in options &&
	                    options.http === false &&
	                    oldCookie.httpOnly) {
	                    // step 11.2
	                    err = new Error("old Cookie is HttpOnly and this isn't an HTTP API");
	                    if (options.ignoreError)
	                        cb(null, undefined);
	                    else
	                        cb(err);
	                    return;
	                }
	                if (cookie instanceof cookie_1.Cookie) {
	                    cookie.creation = oldCookie.creation;
	                    // step 11.3
	                    cookie.creationIndex = oldCookie.creationIndex;
	                    // preserve tie-breaker
	                    cookie.lastAccessed = now;
	                    // Step 11.4 (delete cookie) is implied by just setting the new one:
	                    store.updateCookie(oldCookie, cookie, next); // step 12
	                }
	            }
	            else {
	                if (cookie instanceof cookie_1.Cookie) {
	                    cookie.creation = cookie.lastAccessed = now;
	                    store.putCookie(cookie, next); // step 12
	                }
	            }
	        };
	        // TODO: Refactor to avoid using a callback
	        store.findCookie(cookie.domain, cookie.path, cookie.key, withCookie);
	        return promiseCallback.promise;
	    }
	    /**
	     * Synchronously attempt to set the {@link Cookie} in the {@link CookieJar}.
	     *
	     * <strong>Note:</strong> Only works if the configured {@link Store} is also synchronous.
	     *
	     * @remarks
	     * - If successfully persisted, the {@link Cookie} will have updated
	     *     {@link Cookie.creation}, {@link Cookie.lastAccessed} and {@link Cookie.hostOnly}
	     *     properties.
	     *
	     * - As per the RFC, the {@link Cookie.hostOnly} flag is set if there was no `Domain={value}`
	     *     atttribute on the cookie string. The {@link Cookie.domain} property is set to the
	     *     fully-qualified hostname of `currentUrl` in this case. Matching this cookie requires an
	     *     exact hostname match (not a {@link domainMatch} as per usual)
	     *
	     * @param cookie - The cookie object or cookie string to store. A string value will be parsed into a cookie using {@link Cookie.parse}.
	     * @param url - The domain to store the cookie with.
	     * @param options - Configuration settings to use when storing the cookie.
	     * @public
	     */
	    setCookieSync(cookie, url, options) {
	        const setCookieFn = options
	            ? this.setCookie.bind(this, cookie, url, options)
	            : this.setCookie.bind(this, cookie, url);
	        return this.callSync(setCookieFn);
	    }
	    /**
	     * @internal No doc because this is the overload implementation
	     */
	    getCookies(url, options, callback) {
	        // RFC6365 S5.4
	        if (typeof options === 'function') {
	            callback = options;
	            options = defaultGetCookieOptions;
	        }
	        else if (options === undefined) {
	            options = defaultGetCookieOptions;
	        }
	        const promiseCallback = (0, utils_1.createPromiseCallback)(callback);
	        const cb = promiseCallback.callback;
	        let context;
	        try {
	            if (typeof url === 'string') {
	                validators.validate(validators.isNonEmptyString(url), cb, url);
	            }
	            context = getCookieContext(url);
	            validators.validate(validators.isObject(options), cb, (0, utils_1.safeToString)(options));
	            validators.validate(typeof cb === 'function', cb);
	        }
	        catch (parameterError) {
	            return promiseCallback.reject(parameterError);
	        }
	        const host = (0, canonicalDomain_1.canonicalDomain)(context.hostname);
	        const path = context.pathname || '/';
	        const secure = context.protocol &&
	            (context.protocol == 'https:' || context.protocol == 'wss:');
	        let sameSiteLevel = 0;
	        if (options.sameSiteContext) {
	            const sameSiteContext = checkSameSiteContext(options.sameSiteContext);
	            if (sameSiteContext == null) {
	                return promiseCallback.reject(new Error(SAME_SITE_CONTEXT_VAL_ERR));
	            }
	            sameSiteLevel = cookie_1.Cookie.sameSiteLevel[sameSiteContext];
	            if (!sameSiteLevel) {
	                return promiseCallback.reject(new Error(SAME_SITE_CONTEXT_VAL_ERR));
	            }
	        }
	        const http = options.http ?? true;
	        const now = Date.now();
	        const expireCheck = options.expire ?? true;
	        const allPaths = options.allPaths ?? false;
	        const store = this.store;
	        function matchingCookie(c) {
	            // "Either:
	            //   The cookie's host-only-flag is true and the canonicalized
	            //   request-host is identical to the cookie's domain.
	            // Or:
	            //   The cookie's host-only-flag is false and the canonicalized
	            //   request-host domain-matches the cookie's domain."
	            if (c.hostOnly) {
	                if (c.domain != host) {
	                    return false;
	                }
	            }
	            else {
	                if (!(0, domainMatch_1.domainMatch)(host ?? undefined, c.domain ?? undefined, false)) {
	                    return false;
	                }
	            }
	            // "The request-uri's path path-matches the cookie's path."
	            if (!allPaths && typeof c.path === 'string' && !(0, pathMatch_1.pathMatch)(path, c.path)) {
	                return false;
	            }
	            // "If the cookie's secure-only-flag is true, then the request-uri's
	            // scheme must denote a "secure" protocol"
	            if (c.secure && !secure) {
	                return false;
	            }
	            // "If the cookie's http-only-flag is true, then exclude the cookie if the
	            // cookie-string is being generated for a "non-HTTP" API"
	            if (c.httpOnly && !http) {
	                return false;
	            }
	            // RFC6265bis-02 S5.3.7
	            if (sameSiteLevel) {
	                let cookieLevel;
	                if (c.sameSite === 'lax') {
	                    cookieLevel = cookie_1.Cookie.sameSiteLevel.lax;
	                }
	                else if (c.sameSite === 'strict') {
	                    cookieLevel = cookie_1.Cookie.sameSiteLevel.strict;
	                }
	                else {
	                    cookieLevel = cookie_1.Cookie.sameSiteLevel.none;
	                }
	                if (cookieLevel > sameSiteLevel) {
	                    // only allow cookies at or below the request level
	                    return false;
	                }
	            }
	            // deferred from S5.3
	            // non-RFC: allow retention of expired cookies by choice
	            const expiryTime = c.expiryTime();
	            if (expireCheck && expiryTime && expiryTime <= now) {
	                store.removeCookie(c.domain, c.path, c.key, () => { }); // result ignored
	                return false;
	            }
	            return true;
	        }
	        store.findCookies(host, allPaths ? null : path, this.allowSpecialUseDomain, (err, cookies) => {
	            if (err) {
	                cb(err);
	                return;
	            }
	            if (cookies == null) {
	                cb(null, []);
	                return;
	            }
	            cookies = cookies.filter(matchingCookie);
	            // sorting of S5.4 part 2
	            if ('sort' in options && options.sort !== false) {
	                cookies = cookies.sort(cookieCompare_1.cookieCompare);
	            }
	            // S5.4 part 3
	            const now = new Date();
	            for (const cookie of cookies) {
	                cookie.lastAccessed = now;
	            }
	            // TODO persist lastAccessed
	            cb(null, cookies);
	        });
	        return promiseCallback.promise;
	    }
	    /**
	     * Synchronously retrieve the list of cookies that can be sent in a Cookie header for the
	     * current URL.
	     *
	     * <strong>Note</strong>: Only works if the configured Store is also synchronous.
	     *
	     * @remarks
	     * - The array of cookies returned will be sorted according to {@link cookieCompare}.
	     *
	     * - The {@link Cookie.lastAccessed} property will be updated on all returned cookies.
	     *
	     * @param url - The domain to store the cookie with.
	     * @param options - Configuration settings to use when retrieving the cookies.
	     */
	    getCookiesSync(url, options) {
	        return this.callSync(this.getCookies.bind(this, url, options)) ?? [];
	    }
	    /**
	     * @internal No doc because this is the overload implementation
	     */
	    getCookieString(url, options, callback) {
	        if (typeof options === 'function') {
	            callback = options;
	            options = undefined;
	        }
	        const promiseCallback = (0, utils_1.createPromiseCallback)(callback);
	        const next = function (err, cookies) {
	            if (err) {
	                promiseCallback.callback(err);
	            }
	            else {
	                promiseCallback.callback(null, cookies
	                    ?.sort(cookieCompare_1.cookieCompare)
	                    .map((c) => c.cookieString())
	                    .join('; '));
	            }
	        };
	        this.getCookies(url, options, next);
	        return promiseCallback.promise;
	    }
	    /**
	     * Synchronous version of `.getCookieString()`. Accepts the same options as `.getCookies()` but returns a string suitable for a
	     * `Cookie` header rather than an Array.
	     *
	     * <strong>Note</strong>: Only works if the configured Store is also synchronous.
	     *
	     * @param url - The domain to store the cookie with.
	     * @param options - Configuration settings to use when retrieving the cookies.
	     */
	    getCookieStringSync(url, options) {
	        return (this.callSync(options
	            ? this.getCookieString.bind(this, url, options)
	            : this.getCookieString.bind(this, url)) ?? '');
	    }
	    /**
	     * @internal No doc because this is the overload implementation
	     */
	    getSetCookieStrings(url, options, callback) {
	        if (typeof options === 'function') {
	            callback = options;
	            options = undefined;
	        }
	        const promiseCallback = (0, utils_1.createPromiseCallback)(callback);
	        const next = function (err, cookies) {
	            if (err) {
	                promiseCallback.callback(err);
	            }
	            else {
	                promiseCallback.callback(null, cookies?.map((c) => {
	                    return c.toString();
	                }));
	            }
	        };
	        this.getCookies(url, options, next);
	        return promiseCallback.promise;
	    }
	    /**
	     * Synchronous version of `.getSetCookieStrings()`. Returns an array of strings suitable for `Set-Cookie` headers.
	     * Accepts the same options as `.getCookies()`.
	     *
	     * <strong>Note</strong>: Only works if the configured Store is also synchronous.
	     *
	     * @param url - The domain to store the cookie with.
	     * @param options - Configuration settings to use when retrieving the cookies.
	     */
	    getSetCookieStringsSync(url, options = {}) {
	        return (this.callSync(this.getSetCookieStrings.bind(this, url, options)) ?? []);
	    }
	    /**
	     * @internal No doc because this is the overload implementation
	     */
	    serialize(callback) {
	        const promiseCallback = (0, utils_1.createPromiseCallback)(callback);
	        let type = this.store.constructor.name;
	        if (validators.isObject(type)) {
	            type = null;
	        }
	        // update README.md "Serialization Format" if you change this, please!
	        const serialized = {
	            // The version of tough-cookie that serialized this jar. Generally a good
	            // practice since future versions can make data import decisions based on
	            // known past behavior. When/if this matters, use `semver`.
	            version: `tough-cookie@${version_1.version}`,
	            // add the store type, to make humans happy:
	            storeType: type,
	            // CookieJar configuration:
	            rejectPublicSuffixes: this.rejectPublicSuffixes,
	            enableLooseMode: this.enableLooseMode,
	            allowSpecialUseDomain: this.allowSpecialUseDomain,
	            prefixSecurity: getNormalizedPrefixSecurity(this.prefixSecurity),
	            // this gets filled from getAllCookies:
	            cookies: [],
	        };
	        if (typeof this.store.getAllCookies !== 'function') {
	            return promiseCallback.reject(new Error('store does not support getAllCookies and cannot be serialized'));
	        }
	        this.store.getAllCookies((err, cookies) => {
	            if (err) {
	                promiseCallback.callback(err);
	                return;
	            }
	            if (cookies == null) {
	                promiseCallback.callback(null, serialized);
	                return;
	            }
	            serialized.cookies = cookies.map((cookie) => {
	                // convert to serialized 'raw' cookies
	                const serializedCookie = cookie.toJSON();
	                // Remove the index so new ones get assigned during deserialization
	                delete serializedCookie.creationIndex;
	                return serializedCookie;
	            });
	            promiseCallback.callback(null, serialized);
	        });
	        return promiseCallback.promise;
	    }
	    /**
	     * Serialize the CookieJar if the underlying store supports `.getAllCookies`.
	     *
	     * <strong>Note</strong>: Only works if the configured Store is also synchronous.
	     */
	    serializeSync() {
	        return this.callSync((callback) => {
	            this.serialize(callback);
	        });
	    }
	    /**
	     * Alias of {@link CookieJar.serializeSync}. Allows the cookie to be serialized
	     * with `JSON.stringify(cookieJar)`.
	     */
	    toJSON() {
	        return this.serializeSync();
	    }
	    /**
	     * Use the class method CookieJar.deserialize instead of calling this directly
	     * @internal
	     */
	    _importCookies(serialized, callback) {
	        let cookies = undefined;
	        if (serialized &&
	            typeof serialized === 'object' &&
	            (0, utils_1.inOperator)('cookies', serialized) &&
	            Array.isArray(serialized.cookies)) {
	            cookies = serialized.cookies;
	        }
	        if (!cookies) {
	            callback(new Error('serialized jar has no cookies array'), undefined);
	            return;
	        }
	        cookies = cookies.slice(); // do not modify the original
	        const putNext = (err) => {
	            if (err) {
	                callback(err, undefined);
	                return;
	            }
	            if (Array.isArray(cookies)) {
	                if (!cookies.length) {
	                    callback(err, this);
	                    return;
	                }
	                let cookie;
	                try {
	                    cookie = cookie_1.Cookie.fromJSON(cookies.shift());
	                }
	                catch (e) {
	                    callback(e instanceof Error ? e : new Error(), undefined);
	                    return;
	                }
	                if (cookie === undefined) {
	                    putNext(null); // skip this cookie
	                    return;
	                }
	                this.store.putCookie(cookie, putNext);
	            }
	        };
	        putNext(null);
	    }
	    /**
	     * @internal
	     */
	    _importCookiesSync(serialized) {
	        this.callSync(this._importCookies.bind(this, serialized));
	    }
	    /**
	     * @internal No doc because this is the overload implementation
	     */
	    clone(newStore, callback) {
	        if (typeof newStore === 'function') {
	            callback = newStore;
	            newStore = undefined;
	        }
	        const promiseCallback = (0, utils_1.createPromiseCallback)(callback);
	        const cb = promiseCallback.callback;
	        this.serialize((err, serialized) => {
	            if (err) {
	                return promiseCallback.reject(err);
	            }
	            return CookieJar.deserialize(serialized ?? '', newStore, cb);
	        });
	        return promiseCallback.promise;
	    }
	    /**
	     * @internal
	     */
	    _cloneSync(newStore) {
	        const cloneFn = newStore && typeof newStore !== 'function'
	            ? this.clone.bind(this, newStore)
	            : this.clone.bind(this);
	        return this.callSync((callback) => {
	            cloneFn(callback);
	        });
	    }
	    /**
	     * Produces a deep clone of this CookieJar. Modifications to the original do
	     * not affect the clone, and vice versa.
	     *
	     * <strong>Note</strong>: Only works if both the configured Store and destination
	     * Store are synchronous.
	     *
	     * @remarks
	     * - When no {@link Store} is provided, a new {@link MemoryCookieStore} will be used.
	     *
	     * - Transferring between store types is supported so long as the source
	     *     implements `.getAllCookies()` and the destination implements `.putCookie()`.
	     *
	     * @param newStore - The target {@link Store} to clone cookies into.
	     */
	    cloneSync(newStore) {
	        if (!newStore) {
	            return this._cloneSync();
	        }
	        if (!newStore.synchronous) {
	            throw new Error('CookieJar clone destination store is not synchronous; use async API instead.');
	        }
	        return this._cloneSync(newStore);
	    }
	    /**
	     * @internal No doc because this is the overload implementation
	     */
	    removeAllCookies(callback) {
	        const promiseCallback = (0, utils_1.createPromiseCallback)(callback);
	        const cb = promiseCallback.callback;
	        const store = this.store;
	        // Check that the store implements its own removeAllCookies(). The default
	        // implementation in Store will immediately call the callback with a "not
	        // implemented" Error.
	        if (typeof store.removeAllCookies === 'function' &&
	            store.removeAllCookies !== store_1.Store.prototype.removeAllCookies) {
	            // `Callback<undefined>` and `ErrorCallback` are *technically* incompatible, but for the
	            // standard implementation `cb = (err, result) => {}`, they're essentially the same.
	            store.removeAllCookies(cb);
	            return promiseCallback.promise;
	        }
	        store.getAllCookies((err, cookies) => {
	            if (err) {
	                cb(err);
	                return;
	            }
	            if (!cookies) {
	                cookies = [];
	            }
	            if (cookies.length === 0) {
	                cb(null, undefined);
	                return;
	            }
	            let completedCount = 0;
	            const removeErrors = [];
	            // TODO: Refactor to avoid using callback
	            const removeCookieCb = function removeCookieCb(removeErr) {
	                if (removeErr) {
	                    removeErrors.push(removeErr);
	                }
	                completedCount++;
	                if (completedCount === cookies.length) {
	                    if (removeErrors[0])
	                        cb(removeErrors[0]);
	                    else
	                        cb(null, undefined);
	                    return;
	                }
	            };
	            cookies.forEach((cookie) => {
	                store.removeCookie(cookie.domain, cookie.path, cookie.key, removeCookieCb);
	            });
	        });
	        return promiseCallback.promise;
	    }
	    /**
	     * Removes all cookies from the CookieJar.
	     *
	     * <strong>Note</strong>: Only works if the configured Store is also synchronous.
	     *
	     * @remarks
	     * - This is a new backwards-compatible feature of tough-cookie version 2.5,
	     *     so not all Stores will implement it efficiently. For Stores that do not
	     *     implement `removeAllCookies`, the fallback is to call `removeCookie` after
	     *     `getAllCookies`.
	     *
	     * - If `getAllCookies` fails or isn't implemented in the Store, an error is returned.
	     *
	     * - If one or more of the `removeCookie` calls fail, only the first error is returned.
	     */
	    removeAllCookiesSync() {
	        this.callSync((callback) => {
	            // `Callback<undefined>` and `ErrorCallback` are *technically* incompatible, but for the
	            // standard implementation `cb = (err, result) => {}`, they're essentially the same.
	            this.removeAllCookies(callback);
	        });
	    }
	    /**
	     * @internal No doc because this is the overload implementation
	     */
	    static deserialize(strOrObj, store, callback) {
	        if (typeof store === 'function') {
	            callback = store;
	            store = undefined;
	        }
	        const promiseCallback = (0, utils_1.createPromiseCallback)(callback);
	        let serialized;
	        if (typeof strOrObj === 'string') {
	            try {
	                serialized = JSON.parse(strOrObj);
	            }
	            catch (e) {
	                return promiseCallback.reject(e instanceof Error ? e : new Error());
	            }
	        }
	        else {
	            serialized = strOrObj;
	        }
	        const readSerializedProperty = (property) => {
	            return serialized &&
	                typeof serialized === 'object' &&
	                (0, utils_1.inOperator)(property, serialized)
	                ? serialized[property]
	                : undefined;
	        };
	        const readSerializedBoolean = (property) => {
	            const value = readSerializedProperty(property);
	            return typeof value === 'boolean' ? value : undefined;
	        };
	        const readSerializedString = (property) => {
	            const value = readSerializedProperty(property);
	            return typeof value === 'string' ? value : undefined;
	        };
	        const jar = new CookieJar(store, {
	            rejectPublicSuffixes: readSerializedBoolean('rejectPublicSuffixes'),
	            looseMode: readSerializedBoolean('enableLooseMode'),
	            allowSpecialUseDomain: readSerializedBoolean('allowSpecialUseDomain'),
	            prefixSecurity: getNormalizedPrefixSecurity(readSerializedString('prefixSecurity') ?? 'silent'),
	        });
	        jar._importCookies(serialized, (err) => {
	            if (err) {
	                promiseCallback.callback(err);
	                return;
	            }
	            promiseCallback.callback(null, jar);
	        });
	        return promiseCallback.promise;
	    }
	    /**
	     * A new CookieJar is created and the serialized {@link Cookie} values are added to
	     * the underlying store. Each {@link Cookie} is added via `store.putCookie(...)` in
	     * the order in which they appear in the serialization.
	     *
	     * <strong>Note</strong>: Only works if the configured Store is also synchronous.
	     *
	     * @remarks
	     * - When no {@link Store} is provided, a new {@link MemoryCookieStore} will be used.
	     *
	     * - As a convenience, if `strOrObj` is a string, it is passed through `JSON.parse` first.
	     *
	     * @param strOrObj - A JSON string or object representing the deserialized cookies.
	     * @param store - The underlying store to persist the deserialized cookies into.
	     */
	    static deserializeSync(strOrObj, store) {
	        const serialized = typeof strOrObj === 'string' ? JSON.parse(strOrObj) : strOrObj;
	        const readSerializedProperty = (property) => {
	            return serialized &&
	                typeof serialized === 'object' &&
	                (0, utils_1.inOperator)(property, serialized)
	                ? serialized[property]
	                : undefined;
	        };
	        const readSerializedBoolean = (property) => {
	            const value = readSerializedProperty(property);
	            return typeof value === 'boolean' ? value : undefined;
	        };
	        const readSerializedString = (property) => {
	            const value = readSerializedProperty(property);
	            return typeof value === 'string' ? value : undefined;
	        };
	        const jar = new CookieJar(store, {
	            rejectPublicSuffixes: readSerializedBoolean('rejectPublicSuffixes'),
	            looseMode: readSerializedBoolean('enableLooseMode'),
	            allowSpecialUseDomain: readSerializedBoolean('allowSpecialUseDomain'),
	            prefixSecurity: getNormalizedPrefixSecurity(readSerializedString('prefixSecurity') ?? 'silent'),
	        });
	        // catch this mistake early:
	        if (!jar.store.synchronous) {
	            throw new Error('CookieJar store is not synchronous; use async API instead.');
	        }
	        jar._importCookiesSync(serialized);
	        return jar;
	    }
	    /**
	     * Alias of {@link CookieJar.deserializeSync}.
	     *
	     * @remarks
	     * - When no {@link Store} is provided, a new {@link MemoryCookieStore} will be used.
	     *
	     * - As a convenience, if `strOrObj` is a string, it is passed through `JSON.parse` first.
	     *
	     * @param jsonString - A JSON string or object representing the deserialized cookies.
	     * @param store - The underlying store to persist the deserialized cookies into.
	     */
	    static fromJSON(jsonString, store) {
	        return CookieJar.deserializeSync(jsonString, store);
	    }
	}
	cookieJar.CookieJar = CookieJar;
	return cookieJar;
}

var permutePath = {};

var hasRequiredPermutePath;

function requirePermutePath () {
	if (hasRequiredPermutePath) return permutePath;
	hasRequiredPermutePath = 1;
	Object.defineProperty(permutePath, "__esModule", { value: true });
	permutePath.permutePath = permutePath$1;
	/**
	 * Generates the permutation of all possible values that {@link pathMatch} the `path` parameter.
	 * The array is in longest-to-shortest order.  Useful when building custom {@link Store} implementations.
	 *
	 * @example
	 * ```
	 * permutePath('/foo/bar/')
	 * // ['/foo/bar/', '/foo/bar', '/foo', '/']
	 * ```
	 *
	 * @param path - the path to generate permutations for
	 * @public
	 */
	function permutePath$1(path) {
	    if (path === '/') {
	        return ['/'];
	    }
	    const permutations = [path];
	    while (path.length > 1) {
	        const lindex = path.lastIndexOf('/');
	        if (lindex === 0) {
	            break;
	        }
	        path = path.slice(0, lindex);
	        permutations.push(path);
	    }
	    permutations.push('/');
	    return permutations;
	}
	return permutePath;
}

var hasRequiredCookie;

function requireCookie () {
	if (hasRequiredCookie) return cookie$1;
	hasRequiredCookie = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.permutePath = exports.parseDate = exports.formatDate = exports.domainMatch = exports.defaultPath = exports.CookieJar = exports.cookieCompare = exports.Cookie = exports.PrefixSecurityEnum = exports.canonicalDomain = exports.version = exports.ParameterError = exports.Store = exports.getPublicSuffix = exports.permuteDomain = exports.pathMatch = exports.MemoryCookieStore = void 0;
		exports.parse = parse;
		exports.fromJSON = fromJSON;
		var memstore_1 = requireMemstore();
		Object.defineProperty(exports, "MemoryCookieStore", { enumerable: true, get: function () { return memstore_1.MemoryCookieStore; } });
		var pathMatch_1 = requirePathMatch();
		Object.defineProperty(exports, "pathMatch", { enumerable: true, get: function () { return pathMatch_1.pathMatch; } });
		var permuteDomain_1 = requirePermuteDomain();
		Object.defineProperty(exports, "permuteDomain", { enumerable: true, get: function () { return permuteDomain_1.permuteDomain; } });
		var getPublicSuffix_1 = requireGetPublicSuffix();
		Object.defineProperty(exports, "getPublicSuffix", { enumerable: true, get: function () { return getPublicSuffix_1.getPublicSuffix; } });
		var store_1 = requireStore();
		Object.defineProperty(exports, "Store", { enumerable: true, get: function () { return store_1.Store; } });
		var validators_1 = requireValidators();
		Object.defineProperty(exports, "ParameterError", { enumerable: true, get: function () { return validators_1.ParameterError; } });
		var version_1 = requireVersion();
		Object.defineProperty(exports, "version", { enumerable: true, get: function () { return version_1.version; } });
		var canonicalDomain_1 = requireCanonicalDomain();
		Object.defineProperty(exports, "canonicalDomain", { enumerable: true, get: function () { return canonicalDomain_1.canonicalDomain; } });
		var constants_1 = requireConstants();
		Object.defineProperty(exports, "PrefixSecurityEnum", { enumerable: true, get: function () { return constants_1.PrefixSecurityEnum; } });
		var cookie_1 = requireCookie$1();
		Object.defineProperty(exports, "Cookie", { enumerable: true, get: function () { return cookie_1.Cookie; } });
		var cookieCompare_1 = requireCookieCompare();
		Object.defineProperty(exports, "cookieCompare", { enumerable: true, get: function () { return cookieCompare_1.cookieCompare; } });
		var cookieJar_1 = requireCookieJar();
		Object.defineProperty(exports, "CookieJar", { enumerable: true, get: function () { return cookieJar_1.CookieJar; } });
		var defaultPath_1 = requireDefaultPath();
		Object.defineProperty(exports, "defaultPath", { enumerable: true, get: function () { return defaultPath_1.defaultPath; } });
		var domainMatch_1 = requireDomainMatch();
		Object.defineProperty(exports, "domainMatch", { enumerable: true, get: function () { return domainMatch_1.domainMatch; } });
		var formatDate_1 = requireFormatDate();
		Object.defineProperty(exports, "formatDate", { enumerable: true, get: function () { return formatDate_1.formatDate; } });
		var parseDate_1 = requireParseDate();
		Object.defineProperty(exports, "parseDate", { enumerable: true, get: function () { return parseDate_1.parseDate; } });
		var permutePath_1 = requirePermutePath();
		Object.defineProperty(exports, "permutePath", { enumerable: true, get: function () { return permutePath_1.permutePath; } });
		const cookie_2 = requireCookie$1();
		/**
		 * {@inheritDoc Cookie.parse}
		 * @public
		 */
		function parse(str, options) {
		    return cookie_2.Cookie.parse(str, options);
		}
		/**
		 * {@inheritDoc Cookie.fromJSON}
		 * @public
		 */
		function fromJSON(str) {
		    return cookie_2.Cookie.fromJSON(str);
		} 
	} (cookie$1));
	return cookie$1;
}

var cookieExports = requireCookie();

var http$1 = {};

var create_cookie_agent = {};

var create_cookie_header_value = {};

var hasRequiredCreate_cookie_header_value;

function requireCreate_cookie_header_value () {
	if (hasRequiredCreate_cookie_header_value) return create_cookie_header_value;
	hasRequiredCreate_cookie_header_value = 1;

	Object.defineProperty(create_cookie_header_value, "__esModule", {
	  value: true
	});
	create_cookie_header_value.createCookieHeaderValue = createCookieHeaderValue;
	var _toughCookie = requireCookie();
	function createCookieHeaderValue({
	  cookieOptions,
	  passedValues,
	  requestUrl
	}) {
	  const {
	    jar
	  } = cookieOptions;
	  const cookies = jar.getCookiesSync(requestUrl);
	  const cookiesMap = new Map(cookies.map(cookie => [cookie.key, cookie]));
	  for (const passedValue of passedValues) {
	    if (typeof passedValue !== 'string') {
	      continue;
	    }
	    for (const str of passedValue.split(';')) {
	      const cookie = _toughCookie.Cookie.parse(str.trim());
	      if (cookie != null) {
	        cookiesMap.set(cookie.key, cookie);
	      }
	    }
	  }
	  const cookieHeaderValue = Array.from(cookiesMap.values()).map(cookie => cookie.cookieString()).join(';\x20');
	  return cookieHeaderValue;
	}
	return create_cookie_header_value;
}

var save_cookies_from_header = {};

var hasRequiredSave_cookies_from_header;

function requireSave_cookies_from_header () {
	if (hasRequiredSave_cookies_from_header) return save_cookies_from_header;
	hasRequiredSave_cookies_from_header = 1;

	Object.defineProperty(save_cookies_from_header, "__esModule", {
	  value: true
	});
	save_cookies_from_header.saveCookiesFromHeader = saveCookiesFromHeader;
	function saveCookiesFromHeader({
	  cookieOptions,
	  cookies,
	  requestUrl
	}) {
	  const {
	    jar
	  } = cookieOptions;
	  for (const cookie of [cookies].flat()) {
	    if (cookie == null) {
	      continue;
	    }
	    jar.setCookieSync(cookie, requestUrl, {
	      ignoreError: true
	    });
	  }
	}
	return save_cookies_from_header;
}

var validate_cookie_options = {};

var hasRequiredValidate_cookie_options;

function requireValidate_cookie_options () {
	if (hasRequiredValidate_cookie_options) return validate_cookie_options;
	hasRequiredValidate_cookie_options = 1;

	Object.defineProperty(validate_cookie_options, "__esModule", {
	  value: true
	});
	validate_cookie_options.validateCookieOptions = validateCookieOptions;
	function validateCookieOptions(opts) {
	  if (!('jar' in opts)) {
	    throw new TypeError('invalid cookies.jar');
	  }
	  if (!opts.jar.store.synchronous) {
	    throw new TypeError('an asynchronous cookie store is not supported.');
	  }
	}
	return validate_cookie_options;
}

var hasRequiredCreate_cookie_agent;

function requireCreate_cookie_agent () {
	if (hasRequiredCreate_cookie_agent) return create_cookie_agent;
	hasRequiredCreate_cookie_agent = 1;

	Object.defineProperty(create_cookie_agent, "__esModule", {
	  value: true
	});
	create_cookie_agent.createCookieAgent = createCookieAgent;
	var _nodeUrl = _interopRequireDefault(require$$1$2);
	var _create_cookie_header_value = requireCreate_cookie_header_value();
	var _save_cookies_from_header = requireSave_cookies_from_header();
	var _validate_cookie_options = requireValidate_cookie_options();
	function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
	const kCookieOptions = Symbol('cookieOptions');
	const kReimplicitHeader = Symbol('reimplicitHeader');
	const kRecreateFirstChunk = Symbol('recreateFirstChunk');
	const kOverrideRequest = Symbol('overrideRequest');
	function createCookieAgent(BaseAgentClass) {
	  // @ts-expect-error -- BaseAgentClass is type definition.
	  class CookieAgent extends BaseAgentClass {
	    constructor(...params) {
	      const {
	        cookies: cookieOptions
	      } = params.find(opt => {
	        return opt != null && typeof opt === 'object' && 'cookies' in opt;
	      }) ?? {};
	      super(...params);
	      if (cookieOptions) {
	        (0, _validate_cookie_options.validateCookieOptions)(cookieOptions);
	      }
	      this[kCookieOptions] = cookieOptions;
	    }
	    [kReimplicitHeader](req) {
	      const _headerSent = req._headerSent;
	      req._header = null;
	      req._implicitHeader();
	      req._headerSent = _headerSent;
	    }
	    [kRecreateFirstChunk](req) {
	      const firstChunk = req.outputData[0];
	      if (req._header == null || firstChunk == null) {
	        return;
	      }
	      const prevData = firstChunk.data;
	      const prevHeaderLength = prevData.indexOf('\r\n\r\n');
	      if (prevHeaderLength === -1) {
	        firstChunk.data = req._header;
	      } else {
	        firstChunk.data = `${req._header}${prevData.slice(prevHeaderLength + 4)}`;
	      }
	      const diffSize = firstChunk.data.length - prevData.length;
	      req.outputSize += diffSize;
	      req._onPendingData(diffSize);
	    }
	    [kOverrideRequest](req, requestUrl, cookieOptions) {
	      const _implicitHeader = req._implicitHeader.bind(req);
	      req._implicitHeader = () => {
	        try {
	          const cookieHeader = (0, _create_cookie_header_value.createCookieHeaderValue)({
	            cookieOptions,
	            passedValues: [req.getHeader('Cookie')].flat(),
	            requestUrl
	          });
	          if (cookieHeader) {
	            req.setHeader('Cookie', cookieHeader);
	          }
	        } catch (err) {
	          req.destroy(err);
	          return;
	        }
	        _implicitHeader();
	      };
	      const emit = req.emit.bind(req);
	      req.emit = (event, ...args) => {
	        if (event === 'response') {
	          try {
	            const res = args[0];
	            (0, _save_cookies_from_header.saveCookiesFromHeader)({
	              cookieOptions,
	              cookies: res.headers['set-cookie'],
	              requestUrl
	            });
	          } catch (err) {
	            req.destroy(err);
	            return false;
	          }
	        }
	        return emit(event, ...args);
	      };
	    }
	    addRequest(req, options) {
	      const cookieOptions = this[kCookieOptions];
	      if (cookieOptions) {
	        try {
	          const requestUrl = _nodeUrl.default.format({
	            host: req.host,
	            pathname: req.path,
	            protocol: req.protocol
	          });
	          this[kOverrideRequest](req, requestUrl, cookieOptions);
	          if (req._header != null) {
	            this[kReimplicitHeader](req);
	          }
	          if (req._headerSent) {
	            this[kRecreateFirstChunk](req);
	          }
	        } catch (err) {
	          req.destroy(err);
	          return;
	        }
	      }
	      super.addRequest(req, options);
	    }
	  }
	  return CookieAgent;
	}
	return create_cookie_agent;
}

var http_cookie_agent = {};

var hasRequiredHttp_cookie_agent;

function requireHttp_cookie_agent () {
	if (hasRequiredHttp_cookie_agent) return http_cookie_agent;
	hasRequiredHttp_cookie_agent = 1;

	Object.defineProperty(http_cookie_agent, "__esModule", {
	  value: true
	});
	http_cookie_agent.HttpCookieAgent = void 0;
	var _nodeHttp = _interopRequireDefault(require$$0$6);
	var _create_cookie_agent = requireCreate_cookie_agent();
	function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
	http_cookie_agent.HttpCookieAgent = (0, _create_cookie_agent.createCookieAgent)(_nodeHttp.default.Agent);
	return http_cookie_agent;
}

var https_cookie_agent = {};

var hasRequiredHttps_cookie_agent;

function requireHttps_cookie_agent () {
	if (hasRequiredHttps_cookie_agent) return https_cookie_agent;
	hasRequiredHttps_cookie_agent = 1;

	Object.defineProperty(https_cookie_agent, "__esModule", {
	  value: true
	});
	https_cookie_agent.HttpsCookieAgent = void 0;
	var _nodeHttps = _interopRequireDefault(require$$0$7);
	var _create_cookie_agent = requireCreate_cookie_agent();
	function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
	https_cookie_agent.HttpsCookieAgent = (0, _create_cookie_agent.createCookieAgent)(_nodeHttps.default.Agent);
	return https_cookie_agent;
}

var mixed_cookie_agent = {};

var dist = {};

var helpers = {};

var hasRequiredHelpers;

function requireHelpers () {
	if (hasRequiredHelpers) return helpers;
	hasRequiredHelpers = 1;
	var __createBinding = (helpers && helpers.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (helpers && helpers.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (helpers && helpers.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(helpers, "__esModule", { value: true });
	helpers.req = helpers.json = helpers.toBuffer = void 0;
	const http = __importStar(require$$0$2);
	const https = __importStar(require$$2);
	async function toBuffer(stream) {
	    let length = 0;
	    const chunks = [];
	    for await (const chunk of stream) {
	        length += chunk.length;
	        chunks.push(chunk);
	    }
	    return Buffer.concat(chunks, length);
	}
	helpers.toBuffer = toBuffer;
	// eslint-disable-next-line @typescript-eslint/no-explicit-any
	async function json(stream) {
	    const buf = await toBuffer(stream);
	    const str = buf.toString('utf8');
	    try {
	        return JSON.parse(str);
	    }
	    catch (_err) {
	        const err = _err;
	        err.message += ` (input: ${str})`;
	        throw err;
	    }
	}
	helpers.json = json;
	function req(url, opts = {}) {
	    const href = typeof url === 'string' ? url : url.href;
	    const req = (href.startsWith('https:') ? https : http).request(url, opts);
	    const promise = new Promise((resolve, reject) => {
	        req
	            .once('response', resolve)
	            .once('error', reject)
	            .end();
	    });
	    req.then = promise.then.bind(promise);
	    return req;
	}
	helpers.req = req;
	
	return helpers;
}

var hasRequiredDist;

function requireDist () {
	if (hasRequiredDist) return dist;
	hasRequiredDist = 1;
	(function (exports) {
		var __createBinding = (dist && dist.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    var desc = Object.getOwnPropertyDescriptor(m, k);
		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		      desc = { enumerable: true, get: function() { return m[k]; } };
		    }
		    Object.defineProperty(o, k2, desc);
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __setModuleDefault = (dist && dist.__setModuleDefault) || (Object.create ? (function(o, v) {
		    Object.defineProperty(o, "default", { enumerable: true, value: v });
		}) : function(o, v) {
		    o["default"] = v;
		});
		var __importStar = (dist && dist.__importStar) || function (mod) {
		    if (mod && mod.__esModule) return mod;
		    var result = {};
		    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
		    __setModuleDefault(result, mod);
		    return result;
		};
		var __exportStar = (dist && dist.__exportStar) || function(m, exports) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.Agent = void 0;
		const net = __importStar(require$$0$8);
		const http = __importStar(require$$0$2);
		const https_1 = require$$2;
		__exportStar(requireHelpers(), exports);
		const INTERNAL = Symbol('AgentBaseInternalState');
		class Agent extends http.Agent {
		    constructor(opts) {
		        super(opts);
		        this[INTERNAL] = {};
		    }
		    /**
		     * Determine whether this is an `http` or `https` request.
		     */
		    isSecureEndpoint(options) {
		        if (options) {
		            // First check the `secureEndpoint` property explicitly, since this
		            // means that a parent `Agent` is "passing through" to this instance.
		            // eslint-disable-next-line @typescript-eslint/no-explicit-any
		            if (typeof options.secureEndpoint === 'boolean') {
		                return options.secureEndpoint;
		            }
		            // If no explicit `secure` endpoint, check if `protocol` property is
		            // set. This will usually be the case since using a full string URL
		            // or `URL` instance should be the most common usage.
		            if (typeof options.protocol === 'string') {
		                return options.protocol === 'https:';
		            }
		        }
		        // Finally, if no `protocol` property was set, then fall back to
		        // checking the stack trace of the current call stack, and try to
		        // detect the "https" module.
		        const { stack } = new Error();
		        if (typeof stack !== 'string')
		            return false;
		        return stack
		            .split('\n')
		            .some((l) => l.indexOf('(https.js:') !== -1 ||
		            l.indexOf('node:https:') !== -1);
		    }
		    // In order to support async signatures in `connect()` and Node's native
		    // connection pooling in `http.Agent`, the array of sockets for each origin
		    // has to be updated synchronously. This is so the length of the array is
		    // accurate when `addRequest()` is next called. We achieve this by creating a
		    // fake socket and adding it to `sockets[origin]` and incrementing
		    // `totalSocketCount`.
		    incrementSockets(name) {
		        // If `maxSockets` and `maxTotalSockets` are both Infinity then there is no
		        // need to create a fake socket because Node.js native connection pooling
		        // will never be invoked.
		        if (this.maxSockets === Infinity && this.maxTotalSockets === Infinity) {
		            return null;
		        }
		        // All instances of `sockets` are expected TypeScript errors. The
		        // alternative is to add it as a private property of this class but that
		        // will break TypeScript subclassing.
		        if (!this.sockets[name]) {
		            // @ts-expect-error `sockets` is readonly in `@types/node`
		            this.sockets[name] = [];
		        }
		        const fakeSocket = new net.Socket({ writable: false });
		        this.sockets[name].push(fakeSocket);
		        // @ts-expect-error `totalSocketCount` isn't defined in `@types/node`
		        this.totalSocketCount++;
		        return fakeSocket;
		    }
		    decrementSockets(name, socket) {
		        if (!this.sockets[name] || socket === null) {
		            return;
		        }
		        const sockets = this.sockets[name];
		        const index = sockets.indexOf(socket);
		        if (index !== -1) {
		            sockets.splice(index, 1);
		            // @ts-expect-error  `totalSocketCount` isn't defined in `@types/node`
		            this.totalSocketCount--;
		            if (sockets.length === 0) {
		                // @ts-expect-error `sockets` is readonly in `@types/node`
		                delete this.sockets[name];
		            }
		        }
		    }
		    // In order to properly update the socket pool, we need to call `getName()` on
		    // the core `https.Agent` if it is a secureEndpoint.
		    getName(options) {
		        const secureEndpoint = typeof options.secureEndpoint === 'boolean'
		            ? options.secureEndpoint
		            : this.isSecureEndpoint(options);
		        if (secureEndpoint) {
		            // @ts-expect-error `getName()` isn't defined in `@types/node`
		            return https_1.Agent.prototype.getName.call(this, options);
		        }
		        // @ts-expect-error `getName()` isn't defined in `@types/node`
		        return super.getName(options);
		    }
		    createSocket(req, options, cb) {
		        const connectOpts = {
		            ...options,
		            secureEndpoint: this.isSecureEndpoint(options),
		        };
		        const name = this.getName(connectOpts);
		        const fakeSocket = this.incrementSockets(name);
		        Promise.resolve()
		            .then(() => this.connect(req, connectOpts))
		            .then((socket) => {
		            this.decrementSockets(name, fakeSocket);
		            if (socket instanceof http.Agent) {
		                // @ts-expect-error `addRequest()` isn't defined in `@types/node`
		                return socket.addRequest(req, connectOpts);
		            }
		            this[INTERNAL].currentSocket = socket;
		            // @ts-expect-error `createSocket()` isn't defined in `@types/node`
		            super.createSocket(req, options, cb);
		        }, (err) => {
		            this.decrementSockets(name, fakeSocket);
		            cb(err);
		        });
		    }
		    createConnection() {
		        const socket = this[INTERNAL].currentSocket;
		        this[INTERNAL].currentSocket = undefined;
		        if (!socket) {
		            throw new Error('No socket was returned in the `connect()` function');
		        }
		        return socket;
		    }
		    get defaultPort() {
		        return (this[INTERNAL].defaultPort ??
		            (this.protocol === 'https:' ? 443 : 80));
		    }
		    set defaultPort(v) {
		        if (this[INTERNAL]) {
		            this[INTERNAL].defaultPort = v;
		        }
		    }
		    get protocol() {
		        return (this[INTERNAL].protocol ??
		            (this.isSecureEndpoint() ? 'https:' : 'http:'));
		    }
		    set protocol(v) {
		        if (this[INTERNAL]) {
		            this[INTERNAL].protocol = v;
		        }
		    }
		}
		exports.Agent = Agent;
		
	} (dist));
	return dist;
}

var hasRequiredMixed_cookie_agent;

function requireMixed_cookie_agent () {
	if (hasRequiredMixed_cookie_agent) return mixed_cookie_agent;
	hasRequiredMixed_cookie_agent = 1;

	Object.defineProperty(mixed_cookie_agent, "__esModule", {
	  value: true
	});
	mixed_cookie_agent.MixedCookieAgent = void 0;
	var _agentBase = requireDist();
	var _http_cookie_agent = requireHttp_cookie_agent();
	var _https_cookie_agent = requireHttps_cookie_agent();
	class MixedCookieAgent extends _agentBase.Agent {
	  constructor(options) {
	    super();
	    this._httpAgent = new _http_cookie_agent.HttpCookieAgent(options);
	    this._httpsAgent = new _https_cookie_agent.HttpsCookieAgent(options);
	  }
	  connect(_req, options) {
	    return options.secureEndpoint ? this._httpsAgent : this._httpAgent;
	  }
	}
	mixed_cookie_agent.MixedCookieAgent = MixedCookieAgent;
	return mixed_cookie_agent;
}

var hasRequiredHttp$1;

function requireHttp$1 () {
	if (hasRequiredHttp$1) return http$1;
	hasRequiredHttp$1 = 1;
	(function (exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		Object.defineProperty(exports, "HttpCookieAgent", {
		  enumerable: true,
		  get: function () {
		    return _http_cookie_agent.HttpCookieAgent;
		  }
		});
		Object.defineProperty(exports, "HttpsCookieAgent", {
		  enumerable: true,
		  get: function () {
		    return _https_cookie_agent.HttpsCookieAgent;
		  }
		});
		Object.defineProperty(exports, "MixedCookieAgent", {
		  enumerable: true,
		  get: function () {
		    return _mixed_cookie_agent.MixedCookieAgent;
		  }
		});
		Object.defineProperty(exports, "createCookieAgent", {
		  enumerable: true,
		  get: function () {
		    return _create_cookie_agent.createCookieAgent;
		  }
		});
		var _create_cookie_agent = requireCreate_cookie_agent();
		var _http_cookie_agent = requireHttp_cookie_agent();
		var _https_cookie_agent = requireHttps_cookie_agent();
		var _mixed_cookie_agent = requireMixed_cookie_agent(); 
	} (http$1));
	return http$1;
}

var http;
var hasRequiredHttp;

function requireHttp () {
	if (hasRequiredHttp) return http;
	hasRequiredHttp = 1;
	http = requireHttp$1();
	return http;
}

var httpExports = requireHttp();

var errors$1;
var hasRequiredErrors$1;

function requireErrors$1 () {
	if (hasRequiredErrors$1) return errors$1;
	hasRequiredErrors$1 = 1;
	const { format } = require$$1;

	class OPError extends Error {
	  constructor({ error_description, error, error_uri, session_state, state, scope }, response) {
	    super(!error_description ? error : `${error} (${error_description})`);

	    Object.assign(
	      this,
	      { error },
	      error_description && { error_description },
	      error_uri && { error_uri },
	      state && { state },
	      scope && { scope },
	      session_state && { session_state },
	    );

	    if (response) {
	      Object.defineProperty(this, 'response', {
	        value: response,
	      });
	    }

	    this.name = this.constructor.name;
	    Error.captureStackTrace(this, this.constructor);
	  }
	}

	class RPError extends Error {
	  constructor(...args) {
	    if (typeof args[0] === 'string') {
	      super(format(...args));
	    } else {
	      const { message, printf, response, ...rest } = args[0];
	      if (printf) {
	        super(format(...printf));
	      } else {
	        super(message);
	      }
	      Object.assign(this, rest);
	      if (response) {
	        Object.defineProperty(this, 'response', {
	          value: response,
	        });
	      }
	    }

	    this.name = this.constructor.name;
	    Error.captureStackTrace(this, this.constructor);
	  }
	}

	errors$1 = {
	  OPError,
	  RPError,
	};
	return errors$1;
}

var client$1 = {exports: {}};

var cjs = {};

var decrypt$4 = {};

var decrypt$3 = {};

var base64url$2 = {};

var buffer_utils = {};

var digest = {};

var hasRequiredDigest;

function requireDigest () {
	if (hasRequiredDigest) return digest;
	hasRequiredDigest = 1;
	Object.defineProperty(digest, "__esModule", { value: true });
	const crypto_1 = require$$0$9;
	const digest$1 = (algorithm, data) => (0, crypto_1.createHash)(algorithm).update(data).digest();
	digest.default = digest$1;
	return digest;
}

var hasRequiredBuffer_utils;

function requireBuffer_utils () {
	if (hasRequiredBuffer_utils) return buffer_utils;
	hasRequiredBuffer_utils = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.concatKdf = exports.lengthAndInput = exports.uint32be = exports.uint64be = exports.p2s = exports.concat = exports.decoder = exports.encoder = void 0;
		const digest_js_1 = /*@__PURE__*/ requireDigest();
		exports.encoder = new TextEncoder();
		exports.decoder = new TextDecoder();
		const MAX_INT32 = 2 ** 32;
		function concat(...buffers) {
		    const size = buffers.reduce((acc, { length }) => acc + length, 0);
		    const buf = new Uint8Array(size);
		    let i = 0;
		    buffers.forEach((buffer) => {
		        buf.set(buffer, i);
		        i += buffer.length;
		    });
		    return buf;
		}
		exports.concat = concat;
		function p2s(alg, p2sInput) {
		    return concat(exports.encoder.encode(alg), new Uint8Array([0]), p2sInput);
		}
		exports.p2s = p2s;
		function writeUInt32BE(buf, value, offset) {
		    if (value < 0 || value >= MAX_INT32) {
		        throw new RangeError(`value must be >= 0 and <= ${MAX_INT32 - 1}. Received ${value}`);
		    }
		    buf.set([value >>> 24, value >>> 16, value >>> 8, value & 0xff], offset);
		}
		function uint64be(value) {
		    const high = Math.floor(value / MAX_INT32);
		    const low = value % MAX_INT32;
		    const buf = new Uint8Array(8);
		    writeUInt32BE(buf, high, 0);
		    writeUInt32BE(buf, low, 4);
		    return buf;
		}
		exports.uint64be = uint64be;
		function uint32be(value) {
		    const buf = new Uint8Array(4);
		    writeUInt32BE(buf, value);
		    return buf;
		}
		exports.uint32be = uint32be;
		function lengthAndInput(input) {
		    return concat(uint32be(input.length), input);
		}
		exports.lengthAndInput = lengthAndInput;
		async function concatKdf(secret, bits, value) {
		    const iterations = Math.ceil((bits >> 3) / 32);
		    const res = new Uint8Array(iterations * 32);
		    for (let iter = 0; iter < iterations; iter++) {
		        const buf = new Uint8Array(4 + secret.length + value.length);
		        buf.set(uint32be(iter + 1));
		        buf.set(secret, 4);
		        buf.set(value, 4 + secret.length);
		        res.set(await (0, digest_js_1.default)('sha256', buf), iter * 32);
		    }
		    return res.slice(0, bits >> 3);
		}
		exports.concatKdf = concatKdf; 
	} (buffer_utils));
	return buffer_utils;
}

var hasRequiredBase64url$2;

function requireBase64url$2 () {
	if (hasRequiredBase64url$2) return base64url$2;
	hasRequiredBase64url$2 = 1;
	Object.defineProperty(base64url$2, "__esModule", { value: true });
	base64url$2.decode = base64url$2.encode = base64url$2.encodeBase64 = base64url$2.decodeBase64 = void 0;
	const buffer_1 = require$$0$a;
	const buffer_utils_js_1 = /*@__PURE__*/ requireBuffer_utils();
	function normalize(input) {
	    let encoded = input;
	    if (encoded instanceof Uint8Array) {
	        encoded = buffer_utils_js_1.decoder.decode(encoded);
	    }
	    return encoded;
	}
	if (buffer_1.Buffer.isEncoding('base64url')) {
	    base64url$2.encode = (input) => buffer_1.Buffer.from(input).toString('base64url');
	}
	else {
	    base64url$2.encode = (input) => buffer_1.Buffer.from(input).toString('base64').replace(/=/g, '').replace(/\+/g, '-').replace(/\//g, '_');
	}
	const decodeBase64 = (input) => buffer_1.Buffer.from(input, 'base64');
	base64url$2.decodeBase64 = decodeBase64;
	const encodeBase64 = (input) => buffer_1.Buffer.from(input).toString('base64');
	base64url$2.encodeBase64 = encodeBase64;
	const decode = (input) => buffer_1.Buffer.from(normalize(input), 'base64');
	base64url$2.decode = decode;
	return base64url$2;
}

var decrypt$2 = {};

var check_iv_length = {};

var errors = {};

var hasRequiredErrors;

function requireErrors () {
	if (hasRequiredErrors) return errors;
	hasRequiredErrors = 1;
	Object.defineProperty(errors, "__esModule", { value: true });
	errors.JWSSignatureVerificationFailed = errors.JWKSTimeout = errors.JWKSMultipleMatchingKeys = errors.JWKSNoMatchingKey = errors.JWKSInvalid = errors.JWKInvalid = errors.JWTInvalid = errors.JWSInvalid = errors.JWEInvalid = errors.JWEDecompressionFailed = errors.JWEDecryptionFailed = errors.JOSENotSupported = errors.JOSEAlgNotAllowed = errors.JWTExpired = errors.JWTClaimValidationFailed = errors.JOSEError = void 0;
	class JOSEError extends Error {
	    static get code() {
	        return 'ERR_JOSE_GENERIC';
	    }
	    constructor(message) {
	        var _a;
	        super(message);
	        this.code = 'ERR_JOSE_GENERIC';
	        this.name = this.constructor.name;
	        (_a = Error.captureStackTrace) === null || _a === void 0 ? void 0 : _a.call(Error, this, this.constructor);
	    }
	}
	errors.JOSEError = JOSEError;
	class JWTClaimValidationFailed extends JOSEError {
	    static get code() {
	        return 'ERR_JWT_CLAIM_VALIDATION_FAILED';
	    }
	    constructor(message, claim = 'unspecified', reason = 'unspecified') {
	        super(message);
	        this.code = 'ERR_JWT_CLAIM_VALIDATION_FAILED';
	        this.claim = claim;
	        this.reason = reason;
	    }
	}
	errors.JWTClaimValidationFailed = JWTClaimValidationFailed;
	class JWTExpired extends JOSEError {
	    static get code() {
	        return 'ERR_JWT_EXPIRED';
	    }
	    constructor(message, claim = 'unspecified', reason = 'unspecified') {
	        super(message);
	        this.code = 'ERR_JWT_EXPIRED';
	        this.claim = claim;
	        this.reason = reason;
	    }
	}
	errors.JWTExpired = JWTExpired;
	class JOSEAlgNotAllowed extends JOSEError {
	    constructor() {
	        super(...arguments);
	        this.code = 'ERR_JOSE_ALG_NOT_ALLOWED';
	    }
	    static get code() {
	        return 'ERR_JOSE_ALG_NOT_ALLOWED';
	    }
	}
	errors.JOSEAlgNotAllowed = JOSEAlgNotAllowed;
	class JOSENotSupported extends JOSEError {
	    constructor() {
	        super(...arguments);
	        this.code = 'ERR_JOSE_NOT_SUPPORTED';
	    }
	    static get code() {
	        return 'ERR_JOSE_NOT_SUPPORTED';
	    }
	}
	errors.JOSENotSupported = JOSENotSupported;
	class JWEDecryptionFailed extends JOSEError {
	    constructor() {
	        super(...arguments);
	        this.code = 'ERR_JWE_DECRYPTION_FAILED';
	        this.message = 'decryption operation failed';
	    }
	    static get code() {
	        return 'ERR_JWE_DECRYPTION_FAILED';
	    }
	}
	errors.JWEDecryptionFailed = JWEDecryptionFailed;
	class JWEDecompressionFailed extends JOSEError {
	    constructor() {
	        super(...arguments);
	        this.code = 'ERR_JWE_DECOMPRESSION_FAILED';
	        this.message = 'decompression operation failed';
	    }
	    static get code() {
	        return 'ERR_JWE_DECOMPRESSION_FAILED';
	    }
	}
	errors.JWEDecompressionFailed = JWEDecompressionFailed;
	class JWEInvalid extends JOSEError {
	    constructor() {
	        super(...arguments);
	        this.code = 'ERR_JWE_INVALID';
	    }
	    static get code() {
	        return 'ERR_JWE_INVALID';
	    }
	}
	errors.JWEInvalid = JWEInvalid;
	class JWSInvalid extends JOSEError {
	    constructor() {
	        super(...arguments);
	        this.code = 'ERR_JWS_INVALID';
	    }
	    static get code() {
	        return 'ERR_JWS_INVALID';
	    }
	}
	errors.JWSInvalid = JWSInvalid;
	class JWTInvalid extends JOSEError {
	    constructor() {
	        super(...arguments);
	        this.code = 'ERR_JWT_INVALID';
	    }
	    static get code() {
	        return 'ERR_JWT_INVALID';
	    }
	}
	errors.JWTInvalid = JWTInvalid;
	class JWKInvalid extends JOSEError {
	    constructor() {
	        super(...arguments);
	        this.code = 'ERR_JWK_INVALID';
	    }
	    static get code() {
	        return 'ERR_JWK_INVALID';
	    }
	}
	errors.JWKInvalid = JWKInvalid;
	class JWKSInvalid extends JOSEError {
	    constructor() {
	        super(...arguments);
	        this.code = 'ERR_JWKS_INVALID';
	    }
	    static get code() {
	        return 'ERR_JWKS_INVALID';
	    }
	}
	errors.JWKSInvalid = JWKSInvalid;
	class JWKSNoMatchingKey extends JOSEError {
	    constructor() {
	        super(...arguments);
	        this.code = 'ERR_JWKS_NO_MATCHING_KEY';
	        this.message = 'no applicable key found in the JSON Web Key Set';
	    }
	    static get code() {
	        return 'ERR_JWKS_NO_MATCHING_KEY';
	    }
	}
	errors.JWKSNoMatchingKey = JWKSNoMatchingKey;
	class JWKSMultipleMatchingKeys extends JOSEError {
	    constructor() {
	        super(...arguments);
	        this.code = 'ERR_JWKS_MULTIPLE_MATCHING_KEYS';
	        this.message = 'multiple matching keys found in the JSON Web Key Set';
	    }
	    static get code() {
	        return 'ERR_JWKS_MULTIPLE_MATCHING_KEYS';
	    }
	}
	errors.JWKSMultipleMatchingKeys = JWKSMultipleMatchingKeys;
	class JWKSTimeout extends JOSEError {
	    constructor() {
	        super(...arguments);
	        this.code = 'ERR_JWKS_TIMEOUT';
	        this.message = 'request timed out';
	    }
	    static get code() {
	        return 'ERR_JWKS_TIMEOUT';
	    }
	}
	errors.JWKSTimeout = JWKSTimeout;
	class JWSSignatureVerificationFailed extends JOSEError {
	    constructor() {
	        super(...arguments);
	        this.code = 'ERR_JWS_SIGNATURE_VERIFICATION_FAILED';
	        this.message = 'signature verification failed';
	    }
	    static get code() {
	        return 'ERR_JWS_SIGNATURE_VERIFICATION_FAILED';
	    }
	}
	errors.JWSSignatureVerificationFailed = JWSSignatureVerificationFailed;
	return errors;
}

var iv = {};

var random = {};

var hasRequiredRandom;

function requireRandom () {
	if (hasRequiredRandom) return random;
	hasRequiredRandom = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.default = void 0;
		var crypto_1 = require$$0$9;
		Object.defineProperty(exports, "default", { enumerable: true, get: function () { return crypto_1.randomFillSync; } }); 
	} (random));
	return random;
}

var hasRequiredIv;

function requireIv () {
	if (hasRequiredIv) return iv;
	hasRequiredIv = 1;
	Object.defineProperty(iv, "__esModule", { value: true });
	iv.bitLength = void 0;
	const errors_js_1 = /*@__PURE__*/ requireErrors();
	const random_js_1 = /*@__PURE__*/ requireRandom();
	function bitLength(alg) {
	    switch (alg) {
	        case 'A128GCM':
	        case 'A128GCMKW':
	        case 'A192GCM':
	        case 'A192GCMKW':
	        case 'A256GCM':
	        case 'A256GCMKW':
	            return 96;
	        case 'A128CBC-HS256':
	        case 'A192CBC-HS384':
	        case 'A256CBC-HS512':
	            return 128;
	        default:
	            throw new errors_js_1.JOSENotSupported(`Unsupported JWE Algorithm: ${alg}`);
	    }
	}
	iv.bitLength = bitLength;
	iv.default = (alg) => (0, random_js_1.default)(new Uint8Array(bitLength(alg) >> 3));
	return iv;
}

var hasRequiredCheck_iv_length;

function requireCheck_iv_length () {
	if (hasRequiredCheck_iv_length) return check_iv_length;
	hasRequiredCheck_iv_length = 1;
	Object.defineProperty(check_iv_length, "__esModule", { value: true });
	const errors_js_1 = /*@__PURE__*/ requireErrors();
	const iv_js_1 = /*@__PURE__*/ requireIv();
	const checkIvLength = (enc, iv) => {
	    if (iv.length << 3 !== (0, iv_js_1.bitLength)(enc)) {
	        throw new errors_js_1.JWEInvalid('Invalid Initialization Vector length');
	    }
	};
	check_iv_length.default = checkIvLength;
	return check_iv_length;
}

var check_cek_length = {};

var is_key_object$1 = {};

var hasRequiredIs_key_object$1;

function requireIs_key_object$1 () {
	if (hasRequiredIs_key_object$1) return is_key_object$1;
	hasRequiredIs_key_object$1 = 1;
	Object.defineProperty(is_key_object$1, "__esModule", { value: true });
	const crypto_1 = require$$0$9;
	const util = require$$1;
	is_key_object$1.default = util.types.isKeyObject
	    ? (obj) => util.types.isKeyObject(obj)
	    : (obj) => obj != null && obj instanceof crypto_1.KeyObject;
	return is_key_object$1;
}

var hasRequiredCheck_cek_length;

function requireCheck_cek_length () {
	if (hasRequiredCheck_cek_length) return check_cek_length;
	hasRequiredCheck_cek_length = 1;
	Object.defineProperty(check_cek_length, "__esModule", { value: true });
	const errors_js_1 = /*@__PURE__*/ requireErrors();
	const is_key_object_js_1 = /*@__PURE__*/ requireIs_key_object$1();
	const checkCekLength = (enc, cek) => {
	    let expected;
	    switch (enc) {
	        case 'A128CBC-HS256':
	        case 'A192CBC-HS384':
	        case 'A256CBC-HS512':
	            expected = parseInt(enc.slice(-3), 10);
	            break;
	        case 'A128GCM':
	        case 'A192GCM':
	        case 'A256GCM':
	            expected = parseInt(enc.slice(1, 4), 10);
	            break;
	        default:
	            throw new errors_js_1.JOSENotSupported(`Content Encryption Algorithm ${enc} is not supported either by JOSE or your javascript runtime`);
	    }
	    if (cek instanceof Uint8Array) {
	        const actual = cek.byteLength << 3;
	        if (actual !== expected) {
	            throw new errors_js_1.JWEInvalid(`Invalid Content Encryption Key length. Expected ${expected} bits, got ${actual} bits`);
	        }
	        return;
	    }
	    if ((0, is_key_object_js_1.default)(cek) && cek.type === 'secret') {
	        const actual = cek.symmetricKeySize << 3;
	        if (actual !== expected) {
	            throw new errors_js_1.JWEInvalid(`Invalid Content Encryption Key length. Expected ${expected} bits, got ${actual} bits`);
	        }
	        return;
	    }
	    throw new TypeError('Invalid Content Encryption Key type');
	};
	check_cek_length.default = checkCekLength;
	return check_cek_length;
}

var timing_safe_equal = {};

var hasRequiredTiming_safe_equal;

function requireTiming_safe_equal () {
	if (hasRequiredTiming_safe_equal) return timing_safe_equal;
	hasRequiredTiming_safe_equal = 1;
	Object.defineProperty(timing_safe_equal, "__esModule", { value: true });
	const crypto_1 = require$$0$9;
	const timingSafeEqual = crypto_1.timingSafeEqual;
	timing_safe_equal.default = timingSafeEqual;
	return timing_safe_equal;
}

var cbc_tag = {};

var hasRequiredCbc_tag;

function requireCbc_tag () {
	if (hasRequiredCbc_tag) return cbc_tag;
	hasRequiredCbc_tag = 1;
	Object.defineProperty(cbc_tag, "__esModule", { value: true });
	const crypto_1 = require$$0$9;
	const buffer_utils_js_1 = /*@__PURE__*/ requireBuffer_utils();
	function cbcTag(aad, iv, ciphertext, macSize, macKey, keySize) {
	    const macData = (0, buffer_utils_js_1.concat)(aad, iv, ciphertext, (0, buffer_utils_js_1.uint64be)(aad.length << 3));
	    const hmac = (0, crypto_1.createHmac)(`sha${macSize}`, macKey);
	    hmac.update(macData);
	    return hmac.digest().slice(0, keySize >> 3);
	}
	cbc_tag.default = cbcTag;
	return cbc_tag;
}

var webcrypto = {};

var hasRequiredWebcrypto;

function requireWebcrypto () {
	if (hasRequiredWebcrypto) return webcrypto;
	hasRequiredWebcrypto = 1;
	Object.defineProperty(webcrypto, "__esModule", { value: true });
	webcrypto.isCryptoKey = void 0;
	const crypto = require$$0$9;
	const util = require$$1;
	const webcrypto$1 = crypto.webcrypto;
	webcrypto.default = webcrypto$1;
	webcrypto.isCryptoKey = util.types.isCryptoKey
	    ? (key) => util.types.isCryptoKey(key)
	    :
	        (key) => false;
	return webcrypto;
}

var crypto_key = {};

var hasRequiredCrypto_key;

function requireCrypto_key () {
	if (hasRequiredCrypto_key) return crypto_key;
	hasRequiredCrypto_key = 1;
	Object.defineProperty(crypto_key, "__esModule", { value: true });
	crypto_key.checkEncCryptoKey = crypto_key.checkSigCryptoKey = void 0;
	function unusable(name, prop = 'algorithm.name') {
	    return new TypeError(`CryptoKey does not support this operation, its ${prop} must be ${name}`);
	}
	function isAlgorithm(algorithm, name) {
	    return algorithm.name === name;
	}
	function getHashLength(hash) {
	    return parseInt(hash.name.slice(4), 10);
	}
	function getNamedCurve(alg) {
	    switch (alg) {
	        case 'ES256':
	            return 'P-256';
	        case 'ES384':
	            return 'P-384';
	        case 'ES512':
	            return 'P-521';
	        default:
	            throw new Error('unreachable');
	    }
	}
	function checkUsage(key, usages) {
	    if (usages.length && !usages.some((expected) => key.usages.includes(expected))) {
	        let msg = 'CryptoKey does not support this operation, its usages must include ';
	        if (usages.length > 2) {
	            const last = usages.pop();
	            msg += `one of ${usages.join(', ')}, or ${last}.`;
	        }
	        else if (usages.length === 2) {
	            msg += `one of ${usages[0]} or ${usages[1]}.`;
	        }
	        else {
	            msg += `${usages[0]}.`;
	        }
	        throw new TypeError(msg);
	    }
	}
	function checkSigCryptoKey(key, alg, ...usages) {
	    switch (alg) {
	        case 'HS256':
	        case 'HS384':
	        case 'HS512': {
	            if (!isAlgorithm(key.algorithm, 'HMAC'))
	                throw unusable('HMAC');
	            const expected = parseInt(alg.slice(2), 10);
	            const actual = getHashLength(key.algorithm.hash);
	            if (actual !== expected)
	                throw unusable(`SHA-${expected}`, 'algorithm.hash');
	            break;
	        }
	        case 'RS256':
	        case 'RS384':
	        case 'RS512': {
	            if (!isAlgorithm(key.algorithm, 'RSASSA-PKCS1-v1_5'))
	                throw unusable('RSASSA-PKCS1-v1_5');
	            const expected = parseInt(alg.slice(2), 10);
	            const actual = getHashLength(key.algorithm.hash);
	            if (actual !== expected)
	                throw unusable(`SHA-${expected}`, 'algorithm.hash');
	            break;
	        }
	        case 'PS256':
	        case 'PS384':
	        case 'PS512': {
	            if (!isAlgorithm(key.algorithm, 'RSA-PSS'))
	                throw unusable('RSA-PSS');
	            const expected = parseInt(alg.slice(2), 10);
	            const actual = getHashLength(key.algorithm.hash);
	            if (actual !== expected)
	                throw unusable(`SHA-${expected}`, 'algorithm.hash');
	            break;
	        }
	        case 'EdDSA': {
	            if (key.algorithm.name !== 'Ed25519' && key.algorithm.name !== 'Ed448') {
	                throw unusable('Ed25519 or Ed448');
	            }
	            break;
	        }
	        case 'ES256':
	        case 'ES384':
	        case 'ES512': {
	            if (!isAlgorithm(key.algorithm, 'ECDSA'))
	                throw unusable('ECDSA');
	            const expected = getNamedCurve(alg);
	            const actual = key.algorithm.namedCurve;
	            if (actual !== expected)
	                throw unusable(expected, 'algorithm.namedCurve');
	            break;
	        }
	        default:
	            throw new TypeError('CryptoKey does not support this operation');
	    }
	    checkUsage(key, usages);
	}
	crypto_key.checkSigCryptoKey = checkSigCryptoKey;
	function checkEncCryptoKey(key, alg, ...usages) {
	    switch (alg) {
	        case 'A128GCM':
	        case 'A192GCM':
	        case 'A256GCM': {
	            if (!isAlgorithm(key.algorithm, 'AES-GCM'))
	                throw unusable('AES-GCM');
	            const expected = parseInt(alg.slice(1, 4), 10);
	            const actual = key.algorithm.length;
	            if (actual !== expected)
	                throw unusable(expected, 'algorithm.length');
	            break;
	        }
	        case 'A128KW':
	        case 'A192KW':
	        case 'A256KW': {
	            if (!isAlgorithm(key.algorithm, 'AES-KW'))
	                throw unusable('AES-KW');
	            const expected = parseInt(alg.slice(1, 4), 10);
	            const actual = key.algorithm.length;
	            if (actual !== expected)
	                throw unusable(expected, 'algorithm.length');
	            break;
	        }
	        case 'ECDH': {
	            switch (key.algorithm.name) {
	                case 'ECDH':
	                case 'X25519':
	                case 'X448':
	                    break;
	                default:
	                    throw unusable('ECDH, X25519, or X448');
	            }
	            break;
	        }
	        case 'PBES2-HS256+A128KW':
	        case 'PBES2-HS384+A192KW':
	        case 'PBES2-HS512+A256KW':
	            if (!isAlgorithm(key.algorithm, 'PBKDF2'))
	                throw unusable('PBKDF2');
	            break;
	        case 'RSA-OAEP':
	        case 'RSA-OAEP-256':
	        case 'RSA-OAEP-384':
	        case 'RSA-OAEP-512': {
	            if (!isAlgorithm(key.algorithm, 'RSA-OAEP'))
	                throw unusable('RSA-OAEP');
	            const expected = parseInt(alg.slice(9), 10) || 1;
	            const actual = getHashLength(key.algorithm.hash);
	            if (actual !== expected)
	                throw unusable(`SHA-${expected}`, 'algorithm.hash');
	            break;
	        }
	        default:
	            throw new TypeError('CryptoKey does not support this operation');
	    }
	    checkUsage(key, usages);
	}
	crypto_key.checkEncCryptoKey = checkEncCryptoKey;
	return crypto_key;
}

var invalid_key_input = {};

var hasRequiredInvalid_key_input;

function requireInvalid_key_input () {
	if (hasRequiredInvalid_key_input) return invalid_key_input;
	hasRequiredInvalid_key_input = 1;
	Object.defineProperty(invalid_key_input, "__esModule", { value: true });
	invalid_key_input.withAlg = void 0;
	function message(msg, actual, ...types) {
	    if (types.length > 2) {
	        const last = types.pop();
	        msg += `one of type ${types.join(', ')}, or ${last}.`;
	    }
	    else if (types.length === 2) {
	        msg += `one of type ${types[0]} or ${types[1]}.`;
	    }
	    else {
	        msg += `of type ${types[0]}.`;
	    }
	    if (actual == null) {
	        msg += ` Received ${actual}`;
	    }
	    else if (typeof actual === 'function' && actual.name) {
	        msg += ` Received function ${actual.name}`;
	    }
	    else if (typeof actual === 'object' && actual != null) {
	        if (actual.constructor && actual.constructor.name) {
	            msg += ` Received an instance of ${actual.constructor.name}`;
	        }
	    }
	    return msg;
	}
	invalid_key_input.default = (actual, ...types) => {
	    return message('Key must be ', actual, ...types);
	};
	function withAlg(alg, actual, ...types) {
	    return message(`Key for the ${alg} algorithm must be `, actual, ...types);
	}
	invalid_key_input.withAlg = withAlg;
	return invalid_key_input;
}

var ciphers = {};

var hasRequiredCiphers;

function requireCiphers () {
	if (hasRequiredCiphers) return ciphers;
	hasRequiredCiphers = 1;
	Object.defineProperty(ciphers, "__esModule", { value: true });
	const crypto_1 = require$$0$9;
	let ciphers$1;
	ciphers.default = (algorithm) => {
	    ciphers$1 || (ciphers$1 = new Set((0, crypto_1.getCiphers)()));
	    return ciphers$1.has(algorithm);
	};
	return ciphers;
}

var is_key_like = {};

var hasRequiredIs_key_like;

function requireIs_key_like () {
	if (hasRequiredIs_key_like) return is_key_like;
	hasRequiredIs_key_like = 1;
	Object.defineProperty(is_key_like, "__esModule", { value: true });
	is_key_like.types = void 0;
	const webcrypto_js_1 = /*@__PURE__*/ requireWebcrypto();
	const is_key_object_js_1 = /*@__PURE__*/ requireIs_key_object$1();
	is_key_like.default = (key) => (0, is_key_object_js_1.default)(key) || (0, webcrypto_js_1.isCryptoKey)(key);
	const types = ['KeyObject'];
	is_key_like.types = types;
	if (globalThis.CryptoKey || (webcrypto_js_1.default === null || webcrypto_js_1.default === void 0 ? void 0 : webcrypto_js_1.default.CryptoKey)) {
	    types.push('CryptoKey');
	}
	return is_key_like;
}

var hasRequiredDecrypt$4;

function requireDecrypt$4 () {
	if (hasRequiredDecrypt$4) return decrypt$2;
	hasRequiredDecrypt$4 = 1;
	Object.defineProperty(decrypt$2, "__esModule", { value: true });
	const crypto_1 = require$$0$9;
	const check_iv_length_js_1 = /*@__PURE__*/ requireCheck_iv_length();
	const check_cek_length_js_1 = /*@__PURE__*/ requireCheck_cek_length();
	const buffer_utils_js_1 = /*@__PURE__*/ requireBuffer_utils();
	const errors_js_1 = /*@__PURE__*/ requireErrors();
	const timing_safe_equal_js_1 = /*@__PURE__*/ requireTiming_safe_equal();
	const cbc_tag_js_1 = /*@__PURE__*/ requireCbc_tag();
	const webcrypto_js_1 = /*@__PURE__*/ requireWebcrypto();
	const crypto_key_js_1 = /*@__PURE__*/ requireCrypto_key();
	const is_key_object_js_1 = /*@__PURE__*/ requireIs_key_object$1();
	const invalid_key_input_js_1 = /*@__PURE__*/ requireInvalid_key_input();
	const ciphers_js_1 = /*@__PURE__*/ requireCiphers();
	const is_key_like_js_1 = /*@__PURE__*/ requireIs_key_like();
	function cbcDecrypt(enc, cek, ciphertext, iv, tag, aad) {
	    const keySize = parseInt(enc.slice(1, 4), 10);
	    if ((0, is_key_object_js_1.default)(cek)) {
	        cek = cek.export();
	    }
	    const encKey = cek.subarray(keySize >> 3);
	    const macKey = cek.subarray(0, keySize >> 3);
	    const macSize = parseInt(enc.slice(-3), 10);
	    const algorithm = `aes-${keySize}-cbc`;
	    if (!(0, ciphers_js_1.default)(algorithm)) {
	        throw new errors_js_1.JOSENotSupported(`alg ${enc} is not supported by your javascript runtime`);
	    }
	    const expectedTag = (0, cbc_tag_js_1.default)(aad, iv, ciphertext, macSize, macKey, keySize);
	    let macCheckPassed;
	    try {
	        macCheckPassed = (0, timing_safe_equal_js_1.default)(tag, expectedTag);
	    }
	    catch {
	    }
	    if (!macCheckPassed) {
	        throw new errors_js_1.JWEDecryptionFailed();
	    }
	    let plaintext;
	    try {
	        const decipher = (0, crypto_1.createDecipheriv)(algorithm, encKey, iv);
	        plaintext = (0, buffer_utils_js_1.concat)(decipher.update(ciphertext), decipher.final());
	    }
	    catch {
	    }
	    if (!plaintext) {
	        throw new errors_js_1.JWEDecryptionFailed();
	    }
	    return plaintext;
	}
	function gcmDecrypt(enc, cek, ciphertext, iv, tag, aad) {
	    const keySize = parseInt(enc.slice(1, 4), 10);
	    const algorithm = `aes-${keySize}-gcm`;
	    if (!(0, ciphers_js_1.default)(algorithm)) {
	        throw new errors_js_1.JOSENotSupported(`alg ${enc} is not supported by your javascript runtime`);
	    }
	    try {
	        const decipher = (0, crypto_1.createDecipheriv)(algorithm, cek, iv, { authTagLength: 16 });
	        decipher.setAuthTag(tag);
	        if (aad.byteLength) {
	            decipher.setAAD(aad, { plaintextLength: ciphertext.length });
	        }
	        const plaintext = decipher.update(ciphertext);
	        decipher.final();
	        return plaintext;
	    }
	    catch {
	        throw new errors_js_1.JWEDecryptionFailed();
	    }
	}
	const decrypt = (enc, cek, ciphertext, iv, tag, aad) => {
	    let key;
	    if ((0, webcrypto_js_1.isCryptoKey)(cek)) {
	        (0, crypto_key_js_1.checkEncCryptoKey)(cek, enc, 'decrypt');
	        key = crypto_1.KeyObject.from(cek);
	    }
	    else if (cek instanceof Uint8Array || (0, is_key_object_js_1.default)(cek)) {
	        key = cek;
	    }
	    else {
	        throw new TypeError((0, invalid_key_input_js_1.default)(cek, ...is_key_like_js_1.types, 'Uint8Array'));
	    }
	    (0, check_cek_length_js_1.default)(enc, key);
	    (0, check_iv_length_js_1.default)(enc, iv);
	    switch (enc) {
	        case 'A128CBC-HS256':
	        case 'A192CBC-HS384':
	        case 'A256CBC-HS512':
	            return cbcDecrypt(enc, key, ciphertext, iv, tag, aad);
	        case 'A128GCM':
	        case 'A192GCM':
	        case 'A256GCM':
	            return gcmDecrypt(enc, key, ciphertext, iv, tag, aad);
	        default:
	            throw new errors_js_1.JOSENotSupported('Unsupported JWE Content Encryption Algorithm');
	    }
	};
	decrypt$2.default = decrypt;
	return decrypt$2;
}

var zlib = {};

var hasRequiredZlib;

function requireZlib () {
	if (hasRequiredZlib) return zlib;
	hasRequiredZlib = 1;
	Object.defineProperty(zlib, "__esModule", { value: true });
	zlib.deflate = zlib.inflate = void 0;
	const util_1 = require$$1;
	const zlib_1 = zlib$1;
	const errors_js_1 = /*@__PURE__*/ requireErrors();
	const inflateRaw = (0, util_1.promisify)(zlib_1.inflateRaw);
	const deflateRaw = (0, util_1.promisify)(zlib_1.deflateRaw);
	const inflate = (input) => inflateRaw(input, { maxOutputLength: 250000 }).catch(() => {
	    throw new errors_js_1.JWEDecompressionFailed();
	});
	zlib.inflate = inflate;
	const deflate = (input) => deflateRaw(input);
	zlib.deflate = deflate;
	return zlib;
}

var is_disjoint = {};

var hasRequiredIs_disjoint;

function requireIs_disjoint () {
	if (hasRequiredIs_disjoint) return is_disjoint;
	hasRequiredIs_disjoint = 1;
	Object.defineProperty(is_disjoint, "__esModule", { value: true });
	const isDisjoint = (...headers) => {
	    const sources = headers.filter(Boolean);
	    if (sources.length === 0 || sources.length === 1) {
	        return true;
	    }
	    let acc;
	    for (const header of sources) {
	        const parameters = Object.keys(header);
	        if (!acc || acc.size === 0) {
	            acc = new Set(parameters);
	            continue;
	        }
	        for (const parameter of parameters) {
	            if (acc.has(parameter)) {
	                return false;
	            }
	            acc.add(parameter);
	        }
	    }
	    return true;
	};
	is_disjoint.default = isDisjoint;
	return is_disjoint;
}

var is_object = {};

var hasRequiredIs_object;

function requireIs_object () {
	if (hasRequiredIs_object) return is_object;
	hasRequiredIs_object = 1;
	Object.defineProperty(is_object, "__esModule", { value: true });
	function isObjectLike(value) {
	    return typeof value === 'object' && value !== null;
	}
	function isObject(input) {
	    if (!isObjectLike(input) || Object.prototype.toString.call(input) !== '[object Object]') {
	        return false;
	    }
	    if (Object.getPrototypeOf(input) === null) {
	        return true;
	    }
	    let proto = input;
	    while (Object.getPrototypeOf(proto) !== null) {
	        proto = Object.getPrototypeOf(proto);
	    }
	    return Object.getPrototypeOf(input) === proto;
	}
	is_object.default = isObject;
	return is_object;
}

var decrypt_key_management = {};

var aeskw = {};

var hasRequiredAeskw;

function requireAeskw () {
	if (hasRequiredAeskw) return aeskw;
	hasRequiredAeskw = 1;
	Object.defineProperty(aeskw, "__esModule", { value: true });
	aeskw.unwrap = aeskw.wrap = void 0;
	const buffer_1 = require$$0$a;
	const crypto_1 = require$$0$9;
	const errors_js_1 = /*@__PURE__*/ requireErrors();
	const buffer_utils_js_1 = /*@__PURE__*/ requireBuffer_utils();
	const webcrypto_js_1 = /*@__PURE__*/ requireWebcrypto();
	const crypto_key_js_1 = /*@__PURE__*/ requireCrypto_key();
	const is_key_object_js_1 = /*@__PURE__*/ requireIs_key_object$1();
	const invalid_key_input_js_1 = /*@__PURE__*/ requireInvalid_key_input();
	const ciphers_js_1 = /*@__PURE__*/ requireCiphers();
	const is_key_like_js_1 = /*@__PURE__*/ requireIs_key_like();
	function checkKeySize(key, alg) {
	    if (key.symmetricKeySize << 3 !== parseInt(alg.slice(1, 4), 10)) {
	        throw new TypeError(`Invalid key size for alg: ${alg}`);
	    }
	}
	function ensureKeyObject(key, alg, usage) {
	    if ((0, is_key_object_js_1.default)(key)) {
	        return key;
	    }
	    if (key instanceof Uint8Array) {
	        return (0, crypto_1.createSecretKey)(key);
	    }
	    if ((0, webcrypto_js_1.isCryptoKey)(key)) {
	        (0, crypto_key_js_1.checkEncCryptoKey)(key, alg, usage);
	        return crypto_1.KeyObject.from(key);
	    }
	    throw new TypeError((0, invalid_key_input_js_1.default)(key, ...is_key_like_js_1.types, 'Uint8Array'));
	}
	const wrap = (alg, key, cek) => {
	    const size = parseInt(alg.slice(1, 4), 10);
	    const algorithm = `aes${size}-wrap`;
	    if (!(0, ciphers_js_1.default)(algorithm)) {
	        throw new errors_js_1.JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
	    }
	    const keyObject = ensureKeyObject(key, alg, 'wrapKey');
	    checkKeySize(keyObject, alg);
	    const cipher = (0, crypto_1.createCipheriv)(algorithm, keyObject, buffer_1.Buffer.alloc(8, 0xa6));
	    return (0, buffer_utils_js_1.concat)(cipher.update(cek), cipher.final());
	};
	aeskw.wrap = wrap;
	const unwrap = (alg, key, encryptedKey) => {
	    const size = parseInt(alg.slice(1, 4), 10);
	    const algorithm = `aes${size}-wrap`;
	    if (!(0, ciphers_js_1.default)(algorithm)) {
	        throw new errors_js_1.JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
	    }
	    const keyObject = ensureKeyObject(key, alg, 'unwrapKey');
	    checkKeySize(keyObject, alg);
	    const cipher = (0, crypto_1.createDecipheriv)(algorithm, keyObject, buffer_1.Buffer.alloc(8, 0xa6));
	    return (0, buffer_utils_js_1.concat)(cipher.update(encryptedKey), cipher.final());
	};
	aeskw.unwrap = unwrap;
	return aeskw;
}

var ecdhes = {};

var get_named_curve = {};

var hasRequiredGet_named_curve;

function requireGet_named_curve () {
	if (hasRequiredGet_named_curve) return get_named_curve;
	hasRequiredGet_named_curve = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.setCurve = exports.weakMap = void 0;
		const buffer_1 = require$$0$a;
		const crypto_1 = require$$0$9;
		const errors_js_1 = /*@__PURE__*/ requireErrors();
		const webcrypto_js_1 = /*@__PURE__*/ requireWebcrypto();
		const is_key_object_js_1 = /*@__PURE__*/ requireIs_key_object$1();
		const invalid_key_input_js_1 = /*@__PURE__*/ requireInvalid_key_input();
		const is_key_like_js_1 = /*@__PURE__*/ requireIs_key_like();
		const p256 = buffer_1.Buffer.from([42, 134, 72, 206, 61, 3, 1, 7]);
		const p384 = buffer_1.Buffer.from([43, 129, 4, 0, 34]);
		const p521 = buffer_1.Buffer.from([43, 129, 4, 0, 35]);
		const secp256k1 = buffer_1.Buffer.from([43, 129, 4, 0, 10]);
		exports.weakMap = new WeakMap();
		const namedCurveToJOSE = (namedCurve) => {
		    switch (namedCurve) {
		        case 'prime256v1':
		            return 'P-256';
		        case 'secp384r1':
		            return 'P-384';
		        case 'secp521r1':
		            return 'P-521';
		        case 'secp256k1':
		            return 'secp256k1';
		        default:
		            throw new errors_js_1.JOSENotSupported('Unsupported key curve for this operation');
		    }
		};
		const getNamedCurve = (kee, raw) => {
		    var _a;
		    let key;
		    if ((0, webcrypto_js_1.isCryptoKey)(kee)) {
		        key = crypto_1.KeyObject.from(kee);
		    }
		    else if ((0, is_key_object_js_1.default)(kee)) {
		        key = kee;
		    }
		    else {
		        throw new TypeError((0, invalid_key_input_js_1.default)(kee, ...is_key_like_js_1.types));
		    }
		    if (key.type === 'secret') {
		        throw new TypeError('only "private" or "public" type keys can be used for this operation');
		    }
		    switch (key.asymmetricKeyType) {
		        case 'ed25519':
		        case 'ed448':
		            return `Ed${key.asymmetricKeyType.slice(2)}`;
		        case 'x25519':
		        case 'x448':
		            return `X${key.asymmetricKeyType.slice(1)}`;
		        case 'ec': {
		            if (exports.weakMap.has(key)) {
		                return exports.weakMap.get(key);
		            }
		            let namedCurve = (_a = key.asymmetricKeyDetails) === null || _a === void 0 ? void 0 : _a.namedCurve;
		            if (!namedCurve && key.type === 'private') {
		                namedCurve = getNamedCurve((0, crypto_1.createPublicKey)(key), true);
		            }
		            else if (!namedCurve) {
		                const buf = key.export({ format: 'der', type: 'spki' });
		                const i = buf[1] < 128 ? 14 : 15;
		                const len = buf[i];
		                const curveOid = buf.slice(i + 1, i + 1 + len);
		                if (curveOid.equals(p256)) {
		                    namedCurve = 'prime256v1';
		                }
		                else if (curveOid.equals(p384)) {
		                    namedCurve = 'secp384r1';
		                }
		                else if (curveOid.equals(p521)) {
		                    namedCurve = 'secp521r1';
		                }
		                else if (curveOid.equals(secp256k1)) {
		                    namedCurve = 'secp256k1';
		                }
		                else {
		                    throw new errors_js_1.JOSENotSupported('Unsupported key curve for this operation');
		                }
		            }
		            if (raw)
		                return namedCurve;
		            const curve = namedCurveToJOSE(namedCurve);
		            exports.weakMap.set(key, curve);
		            return curve;
		        }
		        default:
		            throw new TypeError('Invalid asymmetric key type for this operation');
		    }
		};
		function setCurve(keyObject, curve) {
		    exports.weakMap.set(keyObject, curve);
		}
		exports.setCurve = setCurve;
		exports.default = getNamedCurve; 
	} (get_named_curve));
	return get_named_curve;
}

var hasRequiredEcdhes;

function requireEcdhes () {
	if (hasRequiredEcdhes) return ecdhes;
	hasRequiredEcdhes = 1;
	Object.defineProperty(ecdhes, "__esModule", { value: true });
	ecdhes.ecdhAllowed = ecdhes.generateEpk = ecdhes.deriveKey = void 0;
	const crypto_1 = require$$0$9;
	const util_1 = require$$1;
	const get_named_curve_js_1 = /*@__PURE__*/ requireGet_named_curve();
	const buffer_utils_js_1 = /*@__PURE__*/ requireBuffer_utils();
	const errors_js_1 = /*@__PURE__*/ requireErrors();
	const webcrypto_js_1 = /*@__PURE__*/ requireWebcrypto();
	const crypto_key_js_1 = /*@__PURE__*/ requireCrypto_key();
	const is_key_object_js_1 = /*@__PURE__*/ requireIs_key_object$1();
	const invalid_key_input_js_1 = /*@__PURE__*/ requireInvalid_key_input();
	const is_key_like_js_1 = /*@__PURE__*/ requireIs_key_like();
	const generateKeyPair = (0, util_1.promisify)(crypto_1.generateKeyPair);
	async function deriveKey(publicKee, privateKee, algorithm, keyLength, apu = new Uint8Array(0), apv = new Uint8Array(0)) {
	    let publicKey;
	    if ((0, webcrypto_js_1.isCryptoKey)(publicKee)) {
	        (0, crypto_key_js_1.checkEncCryptoKey)(publicKee, 'ECDH');
	        publicKey = crypto_1.KeyObject.from(publicKee);
	    }
	    else if ((0, is_key_object_js_1.default)(publicKee)) {
	        publicKey = publicKee;
	    }
	    else {
	        throw new TypeError((0, invalid_key_input_js_1.default)(publicKee, ...is_key_like_js_1.types));
	    }
	    let privateKey;
	    if ((0, webcrypto_js_1.isCryptoKey)(privateKee)) {
	        (0, crypto_key_js_1.checkEncCryptoKey)(privateKee, 'ECDH', 'deriveBits');
	        privateKey = crypto_1.KeyObject.from(privateKee);
	    }
	    else if ((0, is_key_object_js_1.default)(privateKee)) {
	        privateKey = privateKee;
	    }
	    else {
	        throw new TypeError((0, invalid_key_input_js_1.default)(privateKee, ...is_key_like_js_1.types));
	    }
	    const value = (0, buffer_utils_js_1.concat)((0, buffer_utils_js_1.lengthAndInput)(buffer_utils_js_1.encoder.encode(algorithm)), (0, buffer_utils_js_1.lengthAndInput)(apu), (0, buffer_utils_js_1.lengthAndInput)(apv), (0, buffer_utils_js_1.uint32be)(keyLength));
	    const sharedSecret = (0, crypto_1.diffieHellman)({ privateKey, publicKey });
	    return (0, buffer_utils_js_1.concatKdf)(sharedSecret, keyLength, value);
	}
	ecdhes.deriveKey = deriveKey;
	async function generateEpk(kee) {
	    let key;
	    if ((0, webcrypto_js_1.isCryptoKey)(kee)) {
	        key = crypto_1.KeyObject.from(kee);
	    }
	    else if ((0, is_key_object_js_1.default)(kee)) {
	        key = kee;
	    }
	    else {
	        throw new TypeError((0, invalid_key_input_js_1.default)(kee, ...is_key_like_js_1.types));
	    }
	    switch (key.asymmetricKeyType) {
	        case 'x25519':
	            return generateKeyPair('x25519');
	        case 'x448': {
	            return generateKeyPair('x448');
	        }
	        case 'ec': {
	            const namedCurve = (0, get_named_curve_js_1.default)(key);
	            return generateKeyPair('ec', { namedCurve });
	        }
	        default:
	            throw new errors_js_1.JOSENotSupported('Invalid or unsupported EPK');
	    }
	}
	ecdhes.generateEpk = generateEpk;
	const ecdhAllowed = (key) => ['P-256', 'P-384', 'P-521', 'X25519', 'X448'].includes((0, get_named_curve_js_1.default)(key));
	ecdhes.ecdhAllowed = ecdhAllowed;
	return ecdhes;
}

var pbes2kw = {};

var check_p2s = {};

var hasRequiredCheck_p2s;

function requireCheck_p2s () {
	if (hasRequiredCheck_p2s) return check_p2s;
	hasRequiredCheck_p2s = 1;
	Object.defineProperty(check_p2s, "__esModule", { value: true });
	const errors_js_1 = /*@__PURE__*/ requireErrors();
	function checkP2s(p2s) {
	    if (!(p2s instanceof Uint8Array) || p2s.length < 8) {
	        throw new errors_js_1.JWEInvalid('PBES2 Salt Input must be 8 or more octets');
	    }
	}
	check_p2s.default = checkP2s;
	return check_p2s;
}

var hasRequiredPbes2kw;

function requirePbes2kw () {
	if (hasRequiredPbes2kw) return pbes2kw;
	hasRequiredPbes2kw = 1;
	Object.defineProperty(pbes2kw, "__esModule", { value: true });
	pbes2kw.decrypt = pbes2kw.encrypt = void 0;
	const util_1 = require$$1;
	const crypto_1 = require$$0$9;
	const random_js_1 = /*@__PURE__*/ requireRandom();
	const buffer_utils_js_1 = /*@__PURE__*/ requireBuffer_utils();
	const base64url_js_1 = /*@__PURE__*/ requireBase64url$2();
	const aeskw_js_1 = /*@__PURE__*/ requireAeskw();
	const check_p2s_js_1 = /*@__PURE__*/ requireCheck_p2s();
	const webcrypto_js_1 = /*@__PURE__*/ requireWebcrypto();
	const crypto_key_js_1 = /*@__PURE__*/ requireCrypto_key();
	const is_key_object_js_1 = /*@__PURE__*/ requireIs_key_object$1();
	const invalid_key_input_js_1 = /*@__PURE__*/ requireInvalid_key_input();
	const is_key_like_js_1 = /*@__PURE__*/ requireIs_key_like();
	const pbkdf2 = (0, util_1.promisify)(crypto_1.pbkdf2);
	function getPassword(key, alg) {
	    if ((0, is_key_object_js_1.default)(key)) {
	        return key.export();
	    }
	    if (key instanceof Uint8Array) {
	        return key;
	    }
	    if ((0, webcrypto_js_1.isCryptoKey)(key)) {
	        (0, crypto_key_js_1.checkEncCryptoKey)(key, alg, 'deriveBits', 'deriveKey');
	        return crypto_1.KeyObject.from(key).export();
	    }
	    throw new TypeError((0, invalid_key_input_js_1.default)(key, ...is_key_like_js_1.types, 'Uint8Array'));
	}
	const encrypt = async (alg, key, cek, p2c = 2048, p2s = (0, random_js_1.default)(new Uint8Array(16))) => {
	    (0, check_p2s_js_1.default)(p2s);
	    const salt = (0, buffer_utils_js_1.p2s)(alg, p2s);
	    const keylen = parseInt(alg.slice(13, 16), 10) >> 3;
	    const password = getPassword(key, alg);
	    const derivedKey = await pbkdf2(password, salt, p2c, keylen, `sha${alg.slice(8, 11)}`);
	    const encryptedKey = await (0, aeskw_js_1.wrap)(alg.slice(-6), derivedKey, cek);
	    return { encryptedKey, p2c, p2s: (0, base64url_js_1.encode)(p2s) };
	};
	pbes2kw.encrypt = encrypt;
	const decrypt = async (alg, key, encryptedKey, p2c, p2s) => {
	    (0, check_p2s_js_1.default)(p2s);
	    const salt = (0, buffer_utils_js_1.p2s)(alg, p2s);
	    const keylen = parseInt(alg.slice(13, 16), 10) >> 3;
	    const password = getPassword(key, alg);
	    const derivedKey = await pbkdf2(password, salt, p2c, keylen, `sha${alg.slice(8, 11)}`);
	    return (0, aeskw_js_1.unwrap)(alg.slice(-6), derivedKey, encryptedKey);
	};
	pbes2kw.decrypt = decrypt;
	return pbes2kw;
}

var rsaes = {};

var check_modulus_length = {};

var hasRequiredCheck_modulus_length;

function requireCheck_modulus_length () {
	if (hasRequiredCheck_modulus_length) return check_modulus_length;
	hasRequiredCheck_modulus_length = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.setModulusLength = exports.weakMap = void 0;
		exports.weakMap = new WeakMap();
		const getLength = (buf, index) => {
		    let len = buf.readUInt8(1);
		    if ((len & 0x80) === 0) {
		        if (index === 0) {
		            return len;
		        }
		        return getLength(buf.subarray(2 + len), index - 1);
		    }
		    const num = len & 0x7f;
		    len = 0;
		    for (let i = 0; i < num; i++) {
		        len <<= 8;
		        const j = buf.readUInt8(2 + i);
		        len |= j;
		    }
		    if (index === 0) {
		        return len;
		    }
		    return getLength(buf.subarray(2 + len), index - 1);
		};
		const getLengthOfSeqIndex = (sequence, index) => {
		    const len = sequence.readUInt8(1);
		    if ((len & 0x80) === 0) {
		        return getLength(sequence.subarray(2), index);
		    }
		    const num = len & 0x7f;
		    return getLength(sequence.subarray(2 + num), index);
		};
		const getModulusLength = (key) => {
		    var _a, _b;
		    if (exports.weakMap.has(key)) {
		        return exports.weakMap.get(key);
		    }
		    const modulusLength = (_b = (_a = key.asymmetricKeyDetails) === null || _a === void 0 ? void 0 : _a.modulusLength) !== null && _b !== void 0 ? _b : (getLengthOfSeqIndex(key.export({ format: 'der', type: 'pkcs1' }), key.type === 'private' ? 1 : 0) -
		        1) <<
		        3;
		    exports.weakMap.set(key, modulusLength);
		    return modulusLength;
		};
		const setModulusLength = (keyObject, modulusLength) => {
		    exports.weakMap.set(keyObject, modulusLength);
		};
		exports.setModulusLength = setModulusLength;
		exports.default = (key, alg) => {
		    if (getModulusLength(key) < 2048) {
		        throw new TypeError(`${alg} requires key modulusLength to be 2048 bits or larger`);
		    }
		}; 
	} (check_modulus_length));
	return check_modulus_length;
}

var hasRequiredRsaes;

function requireRsaes () {
	if (hasRequiredRsaes) return rsaes;
	hasRequiredRsaes = 1;
	Object.defineProperty(rsaes, "__esModule", { value: true });
	rsaes.decrypt = rsaes.encrypt = void 0;
	const crypto_1 = require$$0$9;
	const check_modulus_length_js_1 = /*@__PURE__*/ requireCheck_modulus_length();
	const webcrypto_js_1 = /*@__PURE__*/ requireWebcrypto();
	const crypto_key_js_1 = /*@__PURE__*/ requireCrypto_key();
	const is_key_object_js_1 = /*@__PURE__*/ requireIs_key_object$1();
	const invalid_key_input_js_1 = /*@__PURE__*/ requireInvalid_key_input();
	const is_key_like_js_1 = /*@__PURE__*/ requireIs_key_like();
	const checkKey = (key, alg) => {
	    if (key.asymmetricKeyType !== 'rsa') {
	        throw new TypeError('Invalid key for this operation, its asymmetricKeyType must be rsa');
	    }
	    (0, check_modulus_length_js_1.default)(key, alg);
	};
	const resolvePadding = (alg) => {
	    switch (alg) {
	        case 'RSA-OAEP':
	        case 'RSA-OAEP-256':
	        case 'RSA-OAEP-384':
	        case 'RSA-OAEP-512':
	            return crypto_1.constants.RSA_PKCS1_OAEP_PADDING;
	        case 'RSA1_5':
	            return crypto_1.constants.RSA_PKCS1_PADDING;
	        default:
	            return undefined;
	    }
	};
	const resolveOaepHash = (alg) => {
	    switch (alg) {
	        case 'RSA-OAEP':
	            return 'sha1';
	        case 'RSA-OAEP-256':
	            return 'sha256';
	        case 'RSA-OAEP-384':
	            return 'sha384';
	        case 'RSA-OAEP-512':
	            return 'sha512';
	        default:
	            return undefined;
	    }
	};
	function ensureKeyObject(key, alg, ...usages) {
	    if ((0, is_key_object_js_1.default)(key)) {
	        return key;
	    }
	    if ((0, webcrypto_js_1.isCryptoKey)(key)) {
	        (0, crypto_key_js_1.checkEncCryptoKey)(key, alg, ...usages);
	        return crypto_1.KeyObject.from(key);
	    }
	    throw new TypeError((0, invalid_key_input_js_1.default)(key, ...is_key_like_js_1.types));
	}
	const encrypt = (alg, key, cek) => {
	    const padding = resolvePadding(alg);
	    const oaepHash = resolveOaepHash(alg);
	    const keyObject = ensureKeyObject(key, alg, 'wrapKey', 'encrypt');
	    checkKey(keyObject, alg);
	    return (0, crypto_1.publicEncrypt)({ key: keyObject, oaepHash, padding }, cek);
	};
	rsaes.encrypt = encrypt;
	const decrypt = (alg, key, encryptedKey) => {
	    const padding = resolvePadding(alg);
	    const oaepHash = resolveOaepHash(alg);
	    const keyObject = ensureKeyObject(key, alg, 'unwrapKey', 'decrypt');
	    checkKey(keyObject, alg);
	    return (0, crypto_1.privateDecrypt)({ key: keyObject, oaepHash, padding }, encryptedKey);
	};
	rsaes.decrypt = decrypt;
	return rsaes;
}

var cek = {};

var hasRequiredCek;

function requireCek () {
	if (hasRequiredCek) return cek;
	hasRequiredCek = 1;
	Object.defineProperty(cek, "__esModule", { value: true });
	cek.bitLength = void 0;
	const errors_js_1 = /*@__PURE__*/ requireErrors();
	const random_js_1 = /*@__PURE__*/ requireRandom();
	function bitLength(alg) {
	    switch (alg) {
	        case 'A128GCM':
	            return 128;
	        case 'A192GCM':
	            return 192;
	        case 'A256GCM':
	        case 'A128CBC-HS256':
	            return 256;
	        case 'A192CBC-HS384':
	            return 384;
	        case 'A256CBC-HS512':
	            return 512;
	        default:
	            throw new errors_js_1.JOSENotSupported(`Unsupported JWE Algorithm: ${alg}`);
	    }
	}
	cek.bitLength = bitLength;
	cek.default = (alg) => (0, random_js_1.default)(new Uint8Array(bitLength(alg) >> 3));
	return cek;
}

var _import = {};

var asn1 = {};

var hasRequiredAsn1;

function requireAsn1 () {
	if (hasRequiredAsn1) return asn1;
	hasRequiredAsn1 = 1;
	Object.defineProperty(asn1, "__esModule", { value: true });
	asn1.fromX509 = asn1.fromSPKI = asn1.fromPKCS8 = asn1.toPKCS8 = asn1.toSPKI = void 0;
	const crypto_1 = require$$0$9;
	const buffer_1 = require$$0$a;
	const webcrypto_js_1 = /*@__PURE__*/ requireWebcrypto();
	const is_key_object_js_1 = /*@__PURE__*/ requireIs_key_object$1();
	const invalid_key_input_js_1 = /*@__PURE__*/ requireInvalid_key_input();
	const is_key_like_js_1 = /*@__PURE__*/ requireIs_key_like();
	const genericExport = (keyType, keyFormat, key) => {
	    let keyObject;
	    if ((0, webcrypto_js_1.isCryptoKey)(key)) {
	        if (!key.extractable) {
	            throw new TypeError('CryptoKey is not extractable');
	        }
	        keyObject = crypto_1.KeyObject.from(key);
	    }
	    else if ((0, is_key_object_js_1.default)(key)) {
	        keyObject = key;
	    }
	    else {
	        throw new TypeError((0, invalid_key_input_js_1.default)(key, ...is_key_like_js_1.types));
	    }
	    if (keyObject.type !== keyType) {
	        throw new TypeError(`key is not a ${keyType} key`);
	    }
	    return keyObject.export({ format: 'pem', type: keyFormat });
	};
	const toSPKI = (key) => {
	    return genericExport('public', 'spki', key);
	};
	asn1.toSPKI = toSPKI;
	const toPKCS8 = (key) => {
	    return genericExport('private', 'pkcs8', key);
	};
	asn1.toPKCS8 = toPKCS8;
	const fromPKCS8 = (pem) => (0, crypto_1.createPrivateKey)({
	    key: buffer_1.Buffer.from(pem.replace(/(?:-----(?:BEGIN|END) PRIVATE KEY-----|\s)/g, ''), 'base64'),
	    type: 'pkcs8',
	    format: 'der',
	});
	asn1.fromPKCS8 = fromPKCS8;
	const fromSPKI = (pem) => (0, crypto_1.createPublicKey)({
	    key: buffer_1.Buffer.from(pem.replace(/(?:-----(?:BEGIN|END) PUBLIC KEY-----|\s)/g, ''), 'base64'),
	    type: 'spki',
	    format: 'der',
	});
	asn1.fromSPKI = fromSPKI;
	const fromX509 = (pem) => (0, crypto_1.createPublicKey)({
	    key: pem,
	    type: 'spki',
	    format: 'pem',
	});
	asn1.fromX509 = fromX509;
	return asn1;
}

var jwk_to_key = {};

var asn1_sequence_encoder = {};

var hasRequiredAsn1_sequence_encoder;

function requireAsn1_sequence_encoder () {
	if (hasRequiredAsn1_sequence_encoder) return asn1_sequence_encoder;
	hasRequiredAsn1_sequence_encoder = 1;
	Object.defineProperty(asn1_sequence_encoder, "__esModule", { value: true });
	const buffer_1 = require$$0$a;
	const errors_js_1 = /*@__PURE__*/ requireErrors();
	const tagInteger = 0x02;
	const tagBitStr = 0x03;
	const tagOctStr = 0x04;
	const tagSequence = 0x30;
	const bZero = buffer_1.Buffer.from([0x00]);
	const bTagInteger = buffer_1.Buffer.from([tagInteger]);
	const bTagBitStr = buffer_1.Buffer.from([tagBitStr]);
	const bTagSequence = buffer_1.Buffer.from([tagSequence]);
	const bTagOctStr = buffer_1.Buffer.from([tagOctStr]);
	const encodeLength = (len) => {
	    if (len < 128)
	        return buffer_1.Buffer.from([len]);
	    const buffer = buffer_1.Buffer.alloc(5);
	    buffer.writeUInt32BE(len, 1);
	    let offset = 1;
	    while (buffer[offset] === 0)
	        offset++;
	    buffer[offset - 1] = 0x80 | (5 - offset);
	    return buffer.slice(offset - 1);
	};
	const oids = new Map([
	    ['P-256', buffer_1.Buffer.from('06 08 2A 86 48 CE 3D 03 01 07'.replace(/ /g, ''), 'hex')],
	    ['secp256k1', buffer_1.Buffer.from('06 05 2B 81 04 00 0A'.replace(/ /g, ''), 'hex')],
	    ['P-384', buffer_1.Buffer.from('06 05 2B 81 04 00 22'.replace(/ /g, ''), 'hex')],
	    ['P-521', buffer_1.Buffer.from('06 05 2B 81 04 00 23'.replace(/ /g, ''), 'hex')],
	    ['ecPublicKey', buffer_1.Buffer.from('06 07 2A 86 48 CE 3D 02 01'.replace(/ /g, ''), 'hex')],
	    ['X25519', buffer_1.Buffer.from('06 03 2B 65 6E'.replace(/ /g, ''), 'hex')],
	    ['X448', buffer_1.Buffer.from('06 03 2B 65 6F'.replace(/ /g, ''), 'hex')],
	    ['Ed25519', buffer_1.Buffer.from('06 03 2B 65 70'.replace(/ /g, ''), 'hex')],
	    ['Ed448', buffer_1.Buffer.from('06 03 2B 65 71'.replace(/ /g, ''), 'hex')],
	]);
	class DumbAsn1Encoder {
	    constructor() {
	        this.length = 0;
	        this.elements = [];
	    }
	    oidFor(oid) {
	        const bOid = oids.get(oid);
	        if (!bOid) {
	            throw new errors_js_1.JOSENotSupported('Invalid or unsupported OID');
	        }
	        this.elements.push(bOid);
	        this.length += bOid.length;
	    }
	    zero() {
	        this.elements.push(bTagInteger, buffer_1.Buffer.from([0x01]), bZero);
	        this.length += 3;
	    }
	    one() {
	        this.elements.push(bTagInteger, buffer_1.Buffer.from([0x01]), buffer_1.Buffer.from([0x01]));
	        this.length += 3;
	    }
	    unsignedInteger(integer) {
	        if (integer[0] & 0x80) {
	            const len = encodeLength(integer.length + 1);
	            this.elements.push(bTagInteger, len, bZero, integer);
	            this.length += 2 + len.length + integer.length;
	        }
	        else {
	            let i = 0;
	            while (integer[i] === 0 && (integer[i + 1] & 0x80) === 0)
	                i++;
	            const len = encodeLength(integer.length - i);
	            this.elements.push(bTagInteger, encodeLength(integer.length - i), integer.slice(i));
	            this.length += 1 + len.length + integer.length - i;
	        }
	    }
	    octStr(octStr) {
	        const len = encodeLength(octStr.length);
	        this.elements.push(bTagOctStr, encodeLength(octStr.length), octStr);
	        this.length += 1 + len.length + octStr.length;
	    }
	    bitStr(bitS) {
	        const len = encodeLength(bitS.length + 1);
	        this.elements.push(bTagBitStr, encodeLength(bitS.length + 1), bZero, bitS);
	        this.length += 1 + len.length + bitS.length + 1;
	    }
	    add(seq) {
	        this.elements.push(seq);
	        this.length += seq.length;
	    }
	    end(tag = bTagSequence) {
	        const len = encodeLength(this.length);
	        return buffer_1.Buffer.concat([tag, len, ...this.elements], 1 + len.length + this.length);
	    }
	}
	asn1_sequence_encoder.default = DumbAsn1Encoder;
	return asn1_sequence_encoder;
}

var flags = {};

var hasRequiredFlags;

function requireFlags () {
	if (hasRequiredFlags) return flags;
	hasRequiredFlags = 1;
	Object.defineProperty(flags, "__esModule", { value: true });
	flags.jwkImport = flags.jwkExport = flags.rsaPssParams = flags.oneShotCallback = void 0;
	const [major, minor] = process.versions.node.split('.').map((str) => parseInt(str, 10));
	flags.oneShotCallback = major >= 16 || (major === 15 && minor >= 13);
	flags.rsaPssParams = !('electron' in process.versions) && (major >= 17 || (major === 16 && minor >= 9));
	flags.jwkExport = major >= 16 || (major === 15 && minor >= 9);
	flags.jwkImport = major >= 16 || (major === 15 && minor >= 12);
	return flags;
}

var hasRequiredJwk_to_key;

function requireJwk_to_key () {
	if (hasRequiredJwk_to_key) return jwk_to_key;
	hasRequiredJwk_to_key = 1;
	Object.defineProperty(jwk_to_key, "__esModule", { value: true });
	const buffer_1 = require$$0$a;
	const crypto_1 = require$$0$9;
	const base64url_js_1 = /*@__PURE__*/ requireBase64url$2();
	const errors_js_1 = /*@__PURE__*/ requireErrors();
	const get_named_curve_js_1 = /*@__PURE__*/ requireGet_named_curve();
	const check_modulus_length_js_1 = /*@__PURE__*/ requireCheck_modulus_length();
	const asn1_sequence_encoder_js_1 = /*@__PURE__*/ requireAsn1_sequence_encoder();
	const flags_js_1 = /*@__PURE__*/ requireFlags();
	const parse = (jwk) => {
	    if (flags_js_1.jwkImport && jwk.kty !== 'oct') {
	        return jwk.d
	            ? (0, crypto_1.createPrivateKey)({ format: 'jwk', key: jwk })
	            : (0, crypto_1.createPublicKey)({ format: 'jwk', key: jwk });
	    }
	    switch (jwk.kty) {
	        case 'oct': {
	            return (0, crypto_1.createSecretKey)((0, base64url_js_1.decode)(jwk.k));
	        }
	        case 'RSA': {
	            const enc = new asn1_sequence_encoder_js_1.default();
	            const isPrivate = jwk.d !== undefined;
	            const modulus = buffer_1.Buffer.from(jwk.n, 'base64');
	            const exponent = buffer_1.Buffer.from(jwk.e, 'base64');
	            if (isPrivate) {
	                enc.zero();
	                enc.unsignedInteger(modulus);
	                enc.unsignedInteger(exponent);
	                enc.unsignedInteger(buffer_1.Buffer.from(jwk.d, 'base64'));
	                enc.unsignedInteger(buffer_1.Buffer.from(jwk.p, 'base64'));
	                enc.unsignedInteger(buffer_1.Buffer.from(jwk.q, 'base64'));
	                enc.unsignedInteger(buffer_1.Buffer.from(jwk.dp, 'base64'));
	                enc.unsignedInteger(buffer_1.Buffer.from(jwk.dq, 'base64'));
	                enc.unsignedInteger(buffer_1.Buffer.from(jwk.qi, 'base64'));
	            }
	            else {
	                enc.unsignedInteger(modulus);
	                enc.unsignedInteger(exponent);
	            }
	            const der = enc.end();
	            const createInput = {
	                key: der,
	                format: 'der',
	                type: 'pkcs1',
	            };
	            const keyObject = isPrivate ? (0, crypto_1.createPrivateKey)(createInput) : (0, crypto_1.createPublicKey)(createInput);
	            (0, check_modulus_length_js_1.setModulusLength)(keyObject, modulus.length << 3);
	            return keyObject;
	        }
	        case 'EC': {
	            const enc = new asn1_sequence_encoder_js_1.default();
	            const isPrivate = jwk.d !== undefined;
	            const pub = buffer_1.Buffer.concat([
	                buffer_1.Buffer.alloc(1, 4),
	                buffer_1.Buffer.from(jwk.x, 'base64'),
	                buffer_1.Buffer.from(jwk.y, 'base64'),
	            ]);
	            if (isPrivate) {
	                enc.zero();
	                const enc$1 = new asn1_sequence_encoder_js_1.default();
	                enc$1.oidFor('ecPublicKey');
	                enc$1.oidFor(jwk.crv);
	                enc.add(enc$1.end());
	                const enc$2 = new asn1_sequence_encoder_js_1.default();
	                enc$2.one();
	                enc$2.octStr(buffer_1.Buffer.from(jwk.d, 'base64'));
	                const enc$3 = new asn1_sequence_encoder_js_1.default();
	                enc$3.bitStr(pub);
	                const f2 = enc$3.end(buffer_1.Buffer.from([0xa1]));
	                enc$2.add(f2);
	                const f = enc$2.end();
	                const enc$4 = new asn1_sequence_encoder_js_1.default();
	                enc$4.add(f);
	                const f3 = enc$4.end(buffer_1.Buffer.from([0x04]));
	                enc.add(f3);
	                const der = enc.end();
	                const keyObject = (0, crypto_1.createPrivateKey)({ key: der, format: 'der', type: 'pkcs8' });
	                (0, get_named_curve_js_1.setCurve)(keyObject, jwk.crv);
	                return keyObject;
	            }
	            const enc$1 = new asn1_sequence_encoder_js_1.default();
	            enc$1.oidFor('ecPublicKey');
	            enc$1.oidFor(jwk.crv);
	            enc.add(enc$1.end());
	            enc.bitStr(pub);
	            const der = enc.end();
	            const keyObject = (0, crypto_1.createPublicKey)({ key: der, format: 'der', type: 'spki' });
	            (0, get_named_curve_js_1.setCurve)(keyObject, jwk.crv);
	            return keyObject;
	        }
	        case 'OKP': {
	            const enc = new asn1_sequence_encoder_js_1.default();
	            const isPrivate = jwk.d !== undefined;
	            if (isPrivate) {
	                enc.zero();
	                const enc$1 = new asn1_sequence_encoder_js_1.default();
	                enc$1.oidFor(jwk.crv);
	                enc.add(enc$1.end());
	                const enc$2 = new asn1_sequence_encoder_js_1.default();
	                enc$2.octStr(buffer_1.Buffer.from(jwk.d, 'base64'));
	                const f = enc$2.end(buffer_1.Buffer.from([0x04]));
	                enc.add(f);
	                const der = enc.end();
	                return (0, crypto_1.createPrivateKey)({ key: der, format: 'der', type: 'pkcs8' });
	            }
	            const enc$1 = new asn1_sequence_encoder_js_1.default();
	            enc$1.oidFor(jwk.crv);
	            enc.add(enc$1.end());
	            enc.bitStr(buffer_1.Buffer.from(jwk.x, 'base64'));
	            const der = enc.end();
	            return (0, crypto_1.createPublicKey)({ key: der, format: 'der', type: 'spki' });
	        }
	        default:
	            throw new errors_js_1.JOSENotSupported('Invalid or unsupported JWK "kty" (Key Type) Parameter value');
	    }
	};
	jwk_to_key.default = parse;
	return jwk_to_key;
}

var hasRequired_import;

function require_import () {
	if (hasRequired_import) return _import;
	hasRequired_import = 1;
	Object.defineProperty(_import, "__esModule", { value: true });
	_import.importJWK = _import.importPKCS8 = _import.importX509 = _import.importSPKI = void 0;
	const base64url_js_1 = /*@__PURE__*/ requireBase64url$2();
	const asn1_js_1 = /*@__PURE__*/ requireAsn1();
	const jwk_to_key_js_1 = /*@__PURE__*/ requireJwk_to_key();
	const errors_js_1 = /*@__PURE__*/ requireErrors();
	const is_object_js_1 = /*@__PURE__*/ requireIs_object();
	async function importSPKI(spki, alg, options) {
	    if (typeof spki !== 'string' || spki.indexOf('-----BEGIN PUBLIC KEY-----') !== 0) {
	        throw new TypeError('"spki" must be SPKI formatted string');
	    }
	    return (0, asn1_js_1.fromSPKI)(spki, alg, options);
	}
	_import.importSPKI = importSPKI;
	async function importX509(x509, alg, options) {
	    if (typeof x509 !== 'string' || x509.indexOf('-----BEGIN CERTIFICATE-----') !== 0) {
	        throw new TypeError('"x509" must be X.509 formatted string');
	    }
	    return (0, asn1_js_1.fromX509)(x509, alg, options);
	}
	_import.importX509 = importX509;
	async function importPKCS8(pkcs8, alg, options) {
	    if (typeof pkcs8 !== 'string' || pkcs8.indexOf('-----BEGIN PRIVATE KEY-----') !== 0) {
	        throw new TypeError('"pkcs8" must be PKCS#8 formatted string');
	    }
	    return (0, asn1_js_1.fromPKCS8)(pkcs8, alg, options);
	}
	_import.importPKCS8 = importPKCS8;
	async function importJWK(jwk, alg, octAsKeyObject) {
	    var _a;
	    if (!(0, is_object_js_1.default)(jwk)) {
	        throw new TypeError('JWK must be an object');
	    }
	    alg || (alg = jwk.alg);
	    switch (jwk.kty) {
	        case 'oct':
	            if (typeof jwk.k !== 'string' || !jwk.k) {
	                throw new TypeError('missing "k" (Key Value) Parameter value');
	            }
	            octAsKeyObject !== null && octAsKeyObject !== void 0 ? octAsKeyObject : (octAsKeyObject = jwk.ext !== true);
	            if (octAsKeyObject) {
	                return (0, jwk_to_key_js_1.default)({ ...jwk, alg, ext: (_a = jwk.ext) !== null && _a !== void 0 ? _a : false });
	            }
	            return (0, base64url_js_1.decode)(jwk.k);
	        case 'RSA':
	            if (jwk.oth !== undefined) {
	                throw new errors_js_1.JOSENotSupported('RSA JWK "oth" (Other Primes Info) Parameter value is not supported');
	            }
	        case 'EC':
	        case 'OKP':
	            return (0, jwk_to_key_js_1.default)({ ...jwk, alg });
	        default:
	            throw new errors_js_1.JOSENotSupported('Unsupported "kty" (Key Type) Parameter value');
	    }
	}
	_import.importJWK = importJWK;
	return _import;
}

var check_key_type = {};

var hasRequiredCheck_key_type;

function requireCheck_key_type () {
	if (hasRequiredCheck_key_type) return check_key_type;
	hasRequiredCheck_key_type = 1;
	Object.defineProperty(check_key_type, "__esModule", { value: true });
	const invalid_key_input_js_1 = /*@__PURE__*/ requireInvalid_key_input();
	const is_key_like_js_1 = /*@__PURE__*/ requireIs_key_like();
	const symmetricTypeCheck = (alg, key) => {
	    if (key instanceof Uint8Array)
	        return;
	    if (!(0, is_key_like_js_1.default)(key)) {
	        throw new TypeError((0, invalid_key_input_js_1.withAlg)(alg, key, ...is_key_like_js_1.types, 'Uint8Array'));
	    }
	    if (key.type !== 'secret') {
	        throw new TypeError(`${is_key_like_js_1.types.join(' or ')} instances for symmetric algorithms must be of type "secret"`);
	    }
	};
	const asymmetricTypeCheck = (alg, key, usage) => {
	    if (!(0, is_key_like_js_1.default)(key)) {
	        throw new TypeError((0, invalid_key_input_js_1.withAlg)(alg, key, ...is_key_like_js_1.types));
	    }
	    if (key.type === 'secret') {
	        throw new TypeError(`${is_key_like_js_1.types.join(' or ')} instances for asymmetric algorithms must not be of type "secret"`);
	    }
	    if (usage === 'sign' && key.type === 'public') {
	        throw new TypeError(`${is_key_like_js_1.types.join(' or ')} instances for asymmetric algorithm signing must be of type "private"`);
	    }
	    if (usage === 'decrypt' && key.type === 'public') {
	        throw new TypeError(`${is_key_like_js_1.types.join(' or ')} instances for asymmetric algorithm decryption must be of type "private"`);
	    }
	    if (key.algorithm && usage === 'verify' && key.type === 'private') {
	        throw new TypeError(`${is_key_like_js_1.types.join(' or ')} instances for asymmetric algorithm verifying must be of type "public"`);
	    }
	    if (key.algorithm && usage === 'encrypt' && key.type === 'private') {
	        throw new TypeError(`${is_key_like_js_1.types.join(' or ')} instances for asymmetric algorithm encryption must be of type "public"`);
	    }
	};
	const checkKeyType = (alg, key, usage) => {
	    const symmetric = alg.startsWith('HS') ||
	        alg === 'dir' ||
	        alg.startsWith('PBES2') ||
	        /^A\d{3}(?:GCM)?KW$/.test(alg);
	    if (symmetric) {
	        symmetricTypeCheck(alg, key);
	    }
	    else {
	        asymmetricTypeCheck(alg, key, usage);
	    }
	};
	check_key_type.default = checkKeyType;
	return check_key_type;
}

var aesgcmkw = {};

var encrypt$4 = {};

var hasRequiredEncrypt$4;

function requireEncrypt$4 () {
	if (hasRequiredEncrypt$4) return encrypt$4;
	hasRequiredEncrypt$4 = 1;
	Object.defineProperty(encrypt$4, "__esModule", { value: true });
	const crypto_1 = require$$0$9;
	const check_iv_length_js_1 = /*@__PURE__*/ requireCheck_iv_length();
	const check_cek_length_js_1 = /*@__PURE__*/ requireCheck_cek_length();
	const buffer_utils_js_1 = /*@__PURE__*/ requireBuffer_utils();
	const cbc_tag_js_1 = /*@__PURE__*/ requireCbc_tag();
	const webcrypto_js_1 = /*@__PURE__*/ requireWebcrypto();
	const crypto_key_js_1 = /*@__PURE__*/ requireCrypto_key();
	const is_key_object_js_1 = /*@__PURE__*/ requireIs_key_object$1();
	const invalid_key_input_js_1 = /*@__PURE__*/ requireInvalid_key_input();
	const errors_js_1 = /*@__PURE__*/ requireErrors();
	const ciphers_js_1 = /*@__PURE__*/ requireCiphers();
	const is_key_like_js_1 = /*@__PURE__*/ requireIs_key_like();
	function cbcEncrypt(enc, plaintext, cek, iv, aad) {
	    const keySize = parseInt(enc.slice(1, 4), 10);
	    if ((0, is_key_object_js_1.default)(cek)) {
	        cek = cek.export();
	    }
	    const encKey = cek.subarray(keySize >> 3);
	    const macKey = cek.subarray(0, keySize >> 3);
	    const algorithm = `aes-${keySize}-cbc`;
	    if (!(0, ciphers_js_1.default)(algorithm)) {
	        throw new errors_js_1.JOSENotSupported(`alg ${enc} is not supported by your javascript runtime`);
	    }
	    const cipher = (0, crypto_1.createCipheriv)(algorithm, encKey, iv);
	    const ciphertext = (0, buffer_utils_js_1.concat)(cipher.update(plaintext), cipher.final());
	    const macSize = parseInt(enc.slice(-3), 10);
	    const tag = (0, cbc_tag_js_1.default)(aad, iv, ciphertext, macSize, macKey, keySize);
	    return { ciphertext, tag };
	}
	function gcmEncrypt(enc, plaintext, cek, iv, aad) {
	    const keySize = parseInt(enc.slice(1, 4), 10);
	    const algorithm = `aes-${keySize}-gcm`;
	    if (!(0, ciphers_js_1.default)(algorithm)) {
	        throw new errors_js_1.JOSENotSupported(`alg ${enc} is not supported by your javascript runtime`);
	    }
	    const cipher = (0, crypto_1.createCipheriv)(algorithm, cek, iv, { authTagLength: 16 });
	    if (aad.byteLength) {
	        cipher.setAAD(aad, { plaintextLength: plaintext.length });
	    }
	    const ciphertext = cipher.update(plaintext);
	    cipher.final();
	    const tag = cipher.getAuthTag();
	    return { ciphertext, tag };
	}
	const encrypt = (enc, plaintext, cek, iv, aad) => {
	    let key;
	    if ((0, webcrypto_js_1.isCryptoKey)(cek)) {
	        (0, crypto_key_js_1.checkEncCryptoKey)(cek, enc, 'encrypt');
	        key = crypto_1.KeyObject.from(cek);
	    }
	    else if (cek instanceof Uint8Array || (0, is_key_object_js_1.default)(cek)) {
	        key = cek;
	    }
	    else {
	        throw new TypeError((0, invalid_key_input_js_1.default)(cek, ...is_key_like_js_1.types, 'Uint8Array'));
	    }
	    (0, check_cek_length_js_1.default)(enc, key);
	    (0, check_iv_length_js_1.default)(enc, iv);
	    switch (enc) {
	        case 'A128CBC-HS256':
	        case 'A192CBC-HS384':
	        case 'A256CBC-HS512':
	            return cbcEncrypt(enc, plaintext, key, iv, aad);
	        case 'A128GCM':
	        case 'A192GCM':
	        case 'A256GCM':
	            return gcmEncrypt(enc, plaintext, key, iv, aad);
	        default:
	            throw new errors_js_1.JOSENotSupported('Unsupported JWE Content Encryption Algorithm');
	    }
	};
	encrypt$4.default = encrypt;
	return encrypt$4;
}

var hasRequiredAesgcmkw;

function requireAesgcmkw () {
	if (hasRequiredAesgcmkw) return aesgcmkw;
	hasRequiredAesgcmkw = 1;
	Object.defineProperty(aesgcmkw, "__esModule", { value: true });
	aesgcmkw.unwrap = aesgcmkw.wrap = void 0;
	const encrypt_js_1 = /*@__PURE__*/ requireEncrypt$4();
	const decrypt_js_1 = /*@__PURE__*/ requireDecrypt$4();
	const iv_js_1 = /*@__PURE__*/ requireIv();
	const base64url_js_1 = /*@__PURE__*/ requireBase64url$2();
	async function wrap(alg, key, cek, iv) {
	    const jweAlgorithm = alg.slice(0, 7);
	    iv || (iv = (0, iv_js_1.default)(jweAlgorithm));
	    const { ciphertext: encryptedKey, tag } = await (0, encrypt_js_1.default)(jweAlgorithm, cek, key, iv, new Uint8Array(0));
	    return { encryptedKey, iv: (0, base64url_js_1.encode)(iv), tag: (0, base64url_js_1.encode)(tag) };
	}
	aesgcmkw.wrap = wrap;
	async function unwrap(alg, key, encryptedKey, iv, tag) {
	    const jweAlgorithm = alg.slice(0, 7);
	    return (0, decrypt_js_1.default)(jweAlgorithm, key, encryptedKey, iv, tag, new Uint8Array(0));
	}
	aesgcmkw.unwrap = unwrap;
	return aesgcmkw;
}

var hasRequiredDecrypt_key_management;

function requireDecrypt_key_management () {
	if (hasRequiredDecrypt_key_management) return decrypt_key_management;
	hasRequiredDecrypt_key_management = 1;
	Object.defineProperty(decrypt_key_management, "__esModule", { value: true });
	const aeskw_js_1 = /*@__PURE__*/ requireAeskw();
	const ECDH = /*@__PURE__*/ requireEcdhes();
	const pbes2kw_js_1 = /*@__PURE__*/ requirePbes2kw();
	const rsaes_js_1 = /*@__PURE__*/ requireRsaes();
	const base64url_js_1 = /*@__PURE__*/ requireBase64url$2();
	const errors_js_1 = /*@__PURE__*/ requireErrors();
	const cek_js_1 = /*@__PURE__*/ requireCek();
	const import_js_1 = /*@__PURE__*/ require_import();
	const check_key_type_js_1 = /*@__PURE__*/ requireCheck_key_type();
	const is_object_js_1 = /*@__PURE__*/ requireIs_object();
	const aesgcmkw_js_1 = /*@__PURE__*/ requireAesgcmkw();
	async function decryptKeyManagement(alg, key, encryptedKey, joseHeader, options) {
	    (0, check_key_type_js_1.default)(alg, key, 'decrypt');
	    switch (alg) {
	        case 'dir': {
	            if (encryptedKey !== undefined)
	                throw new errors_js_1.JWEInvalid('Encountered unexpected JWE Encrypted Key');
	            return key;
	        }
	        case 'ECDH-ES':
	            if (encryptedKey !== undefined)
	                throw new errors_js_1.JWEInvalid('Encountered unexpected JWE Encrypted Key');
	        case 'ECDH-ES+A128KW':
	        case 'ECDH-ES+A192KW':
	        case 'ECDH-ES+A256KW': {
	            if (!(0, is_object_js_1.default)(joseHeader.epk))
	                throw new errors_js_1.JWEInvalid(`JOSE Header "epk" (Ephemeral Public Key) missing or invalid`);
	            if (!ECDH.ecdhAllowed(key))
	                throw new errors_js_1.JOSENotSupported('ECDH with the provided key is not allowed or not supported by your javascript runtime');
	            const epk = await (0, import_js_1.importJWK)(joseHeader.epk, alg);
	            let partyUInfo;
	            let partyVInfo;
	            if (joseHeader.apu !== undefined) {
	                if (typeof joseHeader.apu !== 'string')
	                    throw new errors_js_1.JWEInvalid(`JOSE Header "apu" (Agreement PartyUInfo) invalid`);
	                try {
	                    partyUInfo = (0, base64url_js_1.decode)(joseHeader.apu);
	                }
	                catch {
	                    throw new errors_js_1.JWEInvalid('Failed to base64url decode the apu');
	                }
	            }
	            if (joseHeader.apv !== undefined) {
	                if (typeof joseHeader.apv !== 'string')
	                    throw new errors_js_1.JWEInvalid(`JOSE Header "apv" (Agreement PartyVInfo) invalid`);
	                try {
	                    partyVInfo = (0, base64url_js_1.decode)(joseHeader.apv);
	                }
	                catch {
	                    throw new errors_js_1.JWEInvalid('Failed to base64url decode the apv');
	                }
	            }
	            const sharedSecret = await ECDH.deriveKey(epk, key, alg === 'ECDH-ES' ? joseHeader.enc : alg, alg === 'ECDH-ES' ? (0, cek_js_1.bitLength)(joseHeader.enc) : parseInt(alg.slice(-5, -2), 10), partyUInfo, partyVInfo);
	            if (alg === 'ECDH-ES')
	                return sharedSecret;
	            if (encryptedKey === undefined)
	                throw new errors_js_1.JWEInvalid('JWE Encrypted Key missing');
	            return (0, aeskw_js_1.unwrap)(alg.slice(-6), sharedSecret, encryptedKey);
	        }
	        case 'RSA1_5':
	        case 'RSA-OAEP':
	        case 'RSA-OAEP-256':
	        case 'RSA-OAEP-384':
	        case 'RSA-OAEP-512': {
	            if (encryptedKey === undefined)
	                throw new errors_js_1.JWEInvalid('JWE Encrypted Key missing');
	            return (0, rsaes_js_1.decrypt)(alg, key, encryptedKey);
	        }
	        case 'PBES2-HS256+A128KW':
	        case 'PBES2-HS384+A192KW':
	        case 'PBES2-HS512+A256KW': {
	            if (encryptedKey === undefined)
	                throw new errors_js_1.JWEInvalid('JWE Encrypted Key missing');
	            if (typeof joseHeader.p2c !== 'number')
	                throw new errors_js_1.JWEInvalid(`JOSE Header "p2c" (PBES2 Count) missing or invalid`);
	            const p2cLimit = (options === null || options === void 0 ? void 0 : options.maxPBES2Count) || 10000;
	            if (joseHeader.p2c > p2cLimit)
	                throw new errors_js_1.JWEInvalid(`JOSE Header "p2c" (PBES2 Count) out is of acceptable bounds`);
	            if (typeof joseHeader.p2s !== 'string')
	                throw new errors_js_1.JWEInvalid(`JOSE Header "p2s" (PBES2 Salt) missing or invalid`);
	            let p2s;
	            try {
	                p2s = (0, base64url_js_1.decode)(joseHeader.p2s);
	            }
	            catch {
	                throw new errors_js_1.JWEInvalid('Failed to base64url decode the p2s');
	            }
	            return (0, pbes2kw_js_1.decrypt)(alg, key, encryptedKey, joseHeader.p2c, p2s);
	        }
	        case 'A128KW':
	        case 'A192KW':
	        case 'A256KW': {
	            if (encryptedKey === undefined)
	                throw new errors_js_1.JWEInvalid('JWE Encrypted Key missing');
	            return (0, aeskw_js_1.unwrap)(alg, key, encryptedKey);
	        }
	        case 'A128GCMKW':
	        case 'A192GCMKW':
	        case 'A256GCMKW': {
	            if (encryptedKey === undefined)
	                throw new errors_js_1.JWEInvalid('JWE Encrypted Key missing');
	            if (typeof joseHeader.iv !== 'string')
	                throw new errors_js_1.JWEInvalid(`JOSE Header "iv" (Initialization Vector) missing or invalid`);
	            if (typeof joseHeader.tag !== 'string')
	                throw new errors_js_1.JWEInvalid(`JOSE Header "tag" (Authentication Tag) missing or invalid`);
	            let iv;
	            try {
	                iv = (0, base64url_js_1.decode)(joseHeader.iv);
	            }
	            catch {
	                throw new errors_js_1.JWEInvalid('Failed to base64url decode the iv');
	            }
	            let tag;
	            try {
	                tag = (0, base64url_js_1.decode)(joseHeader.tag);
	            }
	            catch {
	                throw new errors_js_1.JWEInvalid('Failed to base64url decode the tag');
	            }
	            return (0, aesgcmkw_js_1.unwrap)(alg, key, encryptedKey, iv, tag);
	        }
	        default: {
	            throw new errors_js_1.JOSENotSupported('Invalid or unsupported "alg" (JWE Algorithm) header value');
	        }
	    }
	}
	decrypt_key_management.default = decryptKeyManagement;
	return decrypt_key_management;
}

var validate_crit = {};

var hasRequiredValidate_crit;

function requireValidate_crit () {
	if (hasRequiredValidate_crit) return validate_crit;
	hasRequiredValidate_crit = 1;
	Object.defineProperty(validate_crit, "__esModule", { value: true });
	const errors_js_1 = /*@__PURE__*/ requireErrors();
	function validateCrit(Err, recognizedDefault, recognizedOption, protectedHeader, joseHeader) {
	    if (joseHeader.crit !== undefined && protectedHeader.crit === undefined) {
	        throw new Err('"crit" (Critical) Header Parameter MUST be integrity protected');
	    }
	    if (!protectedHeader || protectedHeader.crit === undefined) {
	        return new Set();
	    }
	    if (!Array.isArray(protectedHeader.crit) ||
	        protectedHeader.crit.length === 0 ||
	        protectedHeader.crit.some((input) => typeof input !== 'string' || input.length === 0)) {
	        throw new Err('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');
	    }
	    let recognized;
	    if (recognizedOption !== undefined) {
	        recognized = new Map([...Object.entries(recognizedOption), ...recognizedDefault.entries()]);
	    }
	    else {
	        recognized = recognizedDefault;
	    }
	    for (const parameter of protectedHeader.crit) {
	        if (!recognized.has(parameter)) {
	            throw new errors_js_1.JOSENotSupported(`Extension Header Parameter "${parameter}" is not recognized`);
	        }
	        if (joseHeader[parameter] === undefined) {
	            throw new Err(`Extension Header Parameter "${parameter}" is missing`);
	        }
	        else if (recognized.get(parameter) && protectedHeader[parameter] === undefined) {
	            throw new Err(`Extension Header Parameter "${parameter}" MUST be integrity protected`);
	        }
	    }
	    return new Set(protectedHeader.crit);
	}
	validate_crit.default = validateCrit;
	return validate_crit;
}

var validate_algorithms = {};

var hasRequiredValidate_algorithms;

function requireValidate_algorithms () {
	if (hasRequiredValidate_algorithms) return validate_algorithms;
	hasRequiredValidate_algorithms = 1;
	Object.defineProperty(validate_algorithms, "__esModule", { value: true });
	const validateAlgorithms = (option, algorithms) => {
	    if (algorithms !== undefined &&
	        (!Array.isArray(algorithms) || algorithms.some((s) => typeof s !== 'string'))) {
	        throw new TypeError(`"${option}" option must be an array of strings`);
	    }
	    if (!algorithms) {
	        return undefined;
	    }
	    return new Set(algorithms);
	};
	validate_algorithms.default = validateAlgorithms;
	return validate_algorithms;
}

var hasRequiredDecrypt$3;

function requireDecrypt$3 () {
	if (hasRequiredDecrypt$3) return decrypt$3;
	hasRequiredDecrypt$3 = 1;
	Object.defineProperty(decrypt$3, "__esModule", { value: true });
	decrypt$3.flattenedDecrypt = void 0;
	const base64url_js_1 = /*@__PURE__*/ requireBase64url$2();
	const decrypt_js_1 = /*@__PURE__*/ requireDecrypt$4();
	const zlib_js_1 = /*@__PURE__*/ requireZlib();
	const errors_js_1 = /*@__PURE__*/ requireErrors();
	const is_disjoint_js_1 = /*@__PURE__*/ requireIs_disjoint();
	const is_object_js_1 = /*@__PURE__*/ requireIs_object();
	const decrypt_key_management_js_1 = /*@__PURE__*/ requireDecrypt_key_management();
	const buffer_utils_js_1 = /*@__PURE__*/ requireBuffer_utils();
	const cek_js_1 = /*@__PURE__*/ requireCek();
	const validate_crit_js_1 = /*@__PURE__*/ requireValidate_crit();
	const validate_algorithms_js_1 = /*@__PURE__*/ requireValidate_algorithms();
	async function flattenedDecrypt(jwe, key, options) {
	    var _a;
	    if (!(0, is_object_js_1.default)(jwe)) {
	        throw new errors_js_1.JWEInvalid('Flattened JWE must be an object');
	    }
	    if (jwe.protected === undefined && jwe.header === undefined && jwe.unprotected === undefined) {
	        throw new errors_js_1.JWEInvalid('JOSE Header missing');
	    }
	    if (typeof jwe.iv !== 'string') {
	        throw new errors_js_1.JWEInvalid('JWE Initialization Vector missing or incorrect type');
	    }
	    if (typeof jwe.ciphertext !== 'string') {
	        throw new errors_js_1.JWEInvalid('JWE Ciphertext missing or incorrect type');
	    }
	    if (typeof jwe.tag !== 'string') {
	        throw new errors_js_1.JWEInvalid('JWE Authentication Tag missing or incorrect type');
	    }
	    if (jwe.protected !== undefined && typeof jwe.protected !== 'string') {
	        throw new errors_js_1.JWEInvalid('JWE Protected Header incorrect type');
	    }
	    if (jwe.encrypted_key !== undefined && typeof jwe.encrypted_key !== 'string') {
	        throw new errors_js_1.JWEInvalid('JWE Encrypted Key incorrect type');
	    }
	    if (jwe.aad !== undefined && typeof jwe.aad !== 'string') {
	        throw new errors_js_1.JWEInvalid('JWE AAD incorrect type');
	    }
	    if (jwe.header !== undefined && !(0, is_object_js_1.default)(jwe.header)) {
	        throw new errors_js_1.JWEInvalid('JWE Shared Unprotected Header incorrect type');
	    }
	    if (jwe.unprotected !== undefined && !(0, is_object_js_1.default)(jwe.unprotected)) {
	        throw new errors_js_1.JWEInvalid('JWE Per-Recipient Unprotected Header incorrect type');
	    }
	    let parsedProt;
	    if (jwe.protected) {
	        try {
	            const protectedHeader = (0, base64url_js_1.decode)(jwe.protected);
	            parsedProt = JSON.parse(buffer_utils_js_1.decoder.decode(protectedHeader));
	        }
	        catch {
	            throw new errors_js_1.JWEInvalid('JWE Protected Header is invalid');
	        }
	    }
	    if (!(0, is_disjoint_js_1.default)(parsedProt, jwe.header, jwe.unprotected)) {
	        throw new errors_js_1.JWEInvalid('JWE Protected, JWE Unprotected Header, and JWE Per-Recipient Unprotected Header Parameter names must be disjoint');
	    }
	    const joseHeader = {
	        ...parsedProt,
	        ...jwe.header,
	        ...jwe.unprotected,
	    };
	    (0, validate_crit_js_1.default)(errors_js_1.JWEInvalid, new Map(), options === null || options === void 0 ? void 0 : options.crit, parsedProt, joseHeader);
	    if (joseHeader.zip !== undefined) {
	        if (!parsedProt || !parsedProt.zip) {
	            throw new errors_js_1.JWEInvalid('JWE "zip" (Compression Algorithm) Header MUST be integrity protected');
	        }
	        if (joseHeader.zip !== 'DEF') {
	            throw new errors_js_1.JOSENotSupported('Unsupported JWE "zip" (Compression Algorithm) Header Parameter value');
	        }
	    }
	    const { alg, enc } = joseHeader;
	    if (typeof alg !== 'string' || !alg) {
	        throw new errors_js_1.JWEInvalid('missing JWE Algorithm (alg) in JWE Header');
	    }
	    if (typeof enc !== 'string' || !enc) {
	        throw new errors_js_1.JWEInvalid('missing JWE Encryption Algorithm (enc) in JWE Header');
	    }
	    const keyManagementAlgorithms = options && (0, validate_algorithms_js_1.default)('keyManagementAlgorithms', options.keyManagementAlgorithms);
	    const contentEncryptionAlgorithms = options &&
	        (0, validate_algorithms_js_1.default)('contentEncryptionAlgorithms', options.contentEncryptionAlgorithms);
	    if (keyManagementAlgorithms && !keyManagementAlgorithms.has(alg)) {
	        throw new errors_js_1.JOSEAlgNotAllowed('"alg" (Algorithm) Header Parameter not allowed');
	    }
	    if (contentEncryptionAlgorithms && !contentEncryptionAlgorithms.has(enc)) {
	        throw new errors_js_1.JOSEAlgNotAllowed('"enc" (Encryption Algorithm) Header Parameter not allowed');
	    }
	    let encryptedKey;
	    if (jwe.encrypted_key !== undefined) {
	        try {
	            encryptedKey = (0, base64url_js_1.decode)(jwe.encrypted_key);
	        }
	        catch {
	            throw new errors_js_1.JWEInvalid('Failed to base64url decode the encrypted_key');
	        }
	    }
	    let resolvedKey = false;
	    if (typeof key === 'function') {
	        key = await key(parsedProt, jwe);
	        resolvedKey = true;
	    }
	    let cek;
	    try {
	        cek = await (0, decrypt_key_management_js_1.default)(alg, key, encryptedKey, joseHeader, options);
	    }
	    catch (err) {
	        if (err instanceof TypeError || err instanceof errors_js_1.JWEInvalid || err instanceof errors_js_1.JOSENotSupported) {
	            throw err;
	        }
	        cek = (0, cek_js_1.default)(enc);
	    }
	    let iv;
	    let tag;
	    try {
	        iv = (0, base64url_js_1.decode)(jwe.iv);
	    }
	    catch {
	        throw new errors_js_1.JWEInvalid('Failed to base64url decode the iv');
	    }
	    try {
	        tag = (0, base64url_js_1.decode)(jwe.tag);
	    }
	    catch {
	        throw new errors_js_1.JWEInvalid('Failed to base64url decode the tag');
	    }
	    const protectedHeader = buffer_utils_js_1.encoder.encode((_a = jwe.protected) !== null && _a !== void 0 ? _a : '');
	    let additionalData;
	    if (jwe.aad !== undefined) {
	        additionalData = (0, buffer_utils_js_1.concat)(protectedHeader, buffer_utils_js_1.encoder.encode('.'), buffer_utils_js_1.encoder.encode(jwe.aad));
	    }
	    else {
	        additionalData = protectedHeader;
	    }
	    let ciphertext;
	    try {
	        ciphertext = (0, base64url_js_1.decode)(jwe.ciphertext);
	    }
	    catch {
	        throw new errors_js_1.JWEInvalid('Failed to base64url decode the ciphertext');
	    }
	    let plaintext = await (0, decrypt_js_1.default)(enc, cek, ciphertext, iv, tag, additionalData);
	    if (joseHeader.zip === 'DEF') {
	        plaintext = await ((options === null || options === void 0 ? void 0 : options.inflateRaw) || zlib_js_1.inflate)(plaintext);
	    }
	    const result = { plaintext };
	    if (jwe.protected !== undefined) {
	        result.protectedHeader = parsedProt;
	    }
	    if (jwe.aad !== undefined) {
	        try {
	            result.additionalAuthenticatedData = (0, base64url_js_1.decode)(jwe.aad);
	        }
	        catch {
	            throw new errors_js_1.JWEInvalid('Failed to base64url decode the aad');
	        }
	    }
	    if (jwe.unprotected !== undefined) {
	        result.sharedUnprotectedHeader = jwe.unprotected;
	    }
	    if (jwe.header !== undefined) {
	        result.unprotectedHeader = jwe.header;
	    }
	    if (resolvedKey) {
	        return { ...result, key };
	    }
	    return result;
	}
	decrypt$3.flattenedDecrypt = flattenedDecrypt;
	return decrypt$3;
}

var hasRequiredDecrypt$2;

function requireDecrypt$2 () {
	if (hasRequiredDecrypt$2) return decrypt$4;
	hasRequiredDecrypt$2 = 1;
	Object.defineProperty(decrypt$4, "__esModule", { value: true });
	decrypt$4.compactDecrypt = void 0;
	const decrypt_js_1 = /*@__PURE__*/ requireDecrypt$3();
	const errors_js_1 = /*@__PURE__*/ requireErrors();
	const buffer_utils_js_1 = /*@__PURE__*/ requireBuffer_utils();
	async function compactDecrypt(jwe, key, options) {
	    if (jwe instanceof Uint8Array) {
	        jwe = buffer_utils_js_1.decoder.decode(jwe);
	    }
	    if (typeof jwe !== 'string') {
	        throw new errors_js_1.JWEInvalid('Compact JWE must be a string or Uint8Array');
	    }
	    const { 0: protectedHeader, 1: encryptedKey, 2: iv, 3: ciphertext, 4: tag, length, } = jwe.split('.');
	    if (length !== 5) {
	        throw new errors_js_1.JWEInvalid('Invalid Compact JWE');
	    }
	    const decrypted = await (0, decrypt_js_1.flattenedDecrypt)({
	        ciphertext,
	        iv: (iv || undefined),
	        protected: protectedHeader || undefined,
	        tag: (tag || undefined),
	        encrypted_key: encryptedKey || undefined,
	    }, key, options);
	    const result = { plaintext: decrypted.plaintext, protectedHeader: decrypted.protectedHeader };
	    if (typeof key === 'function') {
	        return { ...result, key: decrypted.key };
	    }
	    return result;
	}
	decrypt$4.compactDecrypt = compactDecrypt;
	return decrypt$4;
}

var decrypt$1 = {};

var hasRequiredDecrypt$1;

function requireDecrypt$1 () {
	if (hasRequiredDecrypt$1) return decrypt$1;
	hasRequiredDecrypt$1 = 1;
	Object.defineProperty(decrypt$1, "__esModule", { value: true });
	decrypt$1.generalDecrypt = void 0;
	const decrypt_js_1 = /*@__PURE__*/ requireDecrypt$3();
	const errors_js_1 = /*@__PURE__*/ requireErrors();
	const is_object_js_1 = /*@__PURE__*/ requireIs_object();
	async function generalDecrypt(jwe, key, options) {
	    if (!(0, is_object_js_1.default)(jwe)) {
	        throw new errors_js_1.JWEInvalid('General JWE must be an object');
	    }
	    if (!Array.isArray(jwe.recipients) || !jwe.recipients.every(is_object_js_1.default)) {
	        throw new errors_js_1.JWEInvalid('JWE Recipients missing or incorrect type');
	    }
	    if (!jwe.recipients.length) {
	        throw new errors_js_1.JWEInvalid('JWE Recipients has no members');
	    }
	    for (const recipient of jwe.recipients) {
	        try {
	            return await (0, decrypt_js_1.flattenedDecrypt)({
	                aad: jwe.aad,
	                ciphertext: jwe.ciphertext,
	                encrypted_key: recipient.encrypted_key,
	                header: recipient.header,
	                iv: jwe.iv,
	                protected: jwe.protected,
	                tag: jwe.tag,
	                unprotected: jwe.unprotected,
	            }, key, options);
	        }
	        catch {
	        }
	    }
	    throw new errors_js_1.JWEDecryptionFailed();
	}
	decrypt$1.generalDecrypt = generalDecrypt;
	return decrypt$1;
}

var encrypt$3 = {};

var encrypt$2 = {};

var encrypt_key_management = {};

var _export = {};

var key_to_jwk = {};

var asn1_sequence_decoder = {};

var hasRequiredAsn1_sequence_decoder;

function requireAsn1_sequence_decoder () {
	if (hasRequiredAsn1_sequence_decoder) return asn1_sequence_decoder;
	hasRequiredAsn1_sequence_decoder = 1;
	Object.defineProperty(asn1_sequence_decoder, "__esModule", { value: true });
	const tagInteger = 0x02;
	const tagSequence = 0x30;
	class Asn1SequenceDecoder {
	    constructor(buffer) {
	        if (buffer[0] !== tagSequence) {
	            throw new TypeError();
	        }
	        this.buffer = buffer;
	        this.offset = 1;
	        const len = this.decodeLength();
	        if (len !== buffer.length - this.offset) {
	            throw new TypeError();
	        }
	    }
	    decodeLength() {
	        let length = this.buffer[this.offset++];
	        if (length & 0x80) {
	            const nBytes = length & ~0x80;
	            length = 0;
	            for (let i = 0; i < nBytes; i++)
	                length = (length << 8) | this.buffer[this.offset + i];
	            this.offset += nBytes;
	        }
	        return length;
	    }
	    unsignedInteger() {
	        if (this.buffer[this.offset++] !== tagInteger) {
	            throw new TypeError();
	        }
	        let length = this.decodeLength();
	        if (this.buffer[this.offset] === 0) {
	            this.offset++;
	            length--;
	        }
	        const result = this.buffer.slice(this.offset, this.offset + length);
	        this.offset += length;
	        return result;
	    }
	    end() {
	        if (this.offset !== this.buffer.length) {
	            throw new TypeError();
	        }
	    }
	}
	asn1_sequence_decoder.default = Asn1SequenceDecoder;
	return asn1_sequence_decoder;
}

var hasRequiredKey_to_jwk;

function requireKey_to_jwk () {
	if (hasRequiredKey_to_jwk) return key_to_jwk;
	hasRequiredKey_to_jwk = 1;
	Object.defineProperty(key_to_jwk, "__esModule", { value: true });
	const crypto_1 = require$$0$9;
	const base64url_js_1 = /*@__PURE__*/ requireBase64url$2();
	const asn1_sequence_decoder_js_1 = /*@__PURE__*/ requireAsn1_sequence_decoder();
	const errors_js_1 = /*@__PURE__*/ requireErrors();
	const get_named_curve_js_1 = /*@__PURE__*/ requireGet_named_curve();
	const webcrypto_js_1 = /*@__PURE__*/ requireWebcrypto();
	const is_key_object_js_1 = /*@__PURE__*/ requireIs_key_object$1();
	const invalid_key_input_js_1 = /*@__PURE__*/ requireInvalid_key_input();
	const is_key_like_js_1 = /*@__PURE__*/ requireIs_key_like();
	const flags_js_1 = /*@__PURE__*/ requireFlags();
	const keyToJWK = (key) => {
	    let keyObject;
	    if ((0, webcrypto_js_1.isCryptoKey)(key)) {
	        if (!key.extractable) {
	            throw new TypeError('CryptoKey is not extractable');
	        }
	        keyObject = crypto_1.KeyObject.from(key);
	    }
	    else if ((0, is_key_object_js_1.default)(key)) {
	        keyObject = key;
	    }
	    else if (key instanceof Uint8Array) {
	        return {
	            kty: 'oct',
	            k: (0, base64url_js_1.encode)(key),
	        };
	    }
	    else {
	        throw new TypeError((0, invalid_key_input_js_1.default)(key, ...is_key_like_js_1.types, 'Uint8Array'));
	    }
	    if (flags_js_1.jwkExport) {
	        if (keyObject.type !== 'secret' &&
	            !['rsa', 'ec', 'ed25519', 'x25519', 'ed448', 'x448'].includes(keyObject.asymmetricKeyType)) {
	            throw new errors_js_1.JOSENotSupported('Unsupported key asymmetricKeyType');
	        }
	        return keyObject.export({ format: 'jwk' });
	    }
	    switch (keyObject.type) {
	        case 'secret':
	            return {
	                kty: 'oct',
	                k: (0, base64url_js_1.encode)(keyObject.export()),
	            };
	        case 'private':
	        case 'public': {
	            switch (keyObject.asymmetricKeyType) {
	                case 'rsa': {
	                    const der = keyObject.export({ format: 'der', type: 'pkcs1' });
	                    const dec = new asn1_sequence_decoder_js_1.default(der);
	                    if (keyObject.type === 'private') {
	                        dec.unsignedInteger();
	                    }
	                    const n = (0, base64url_js_1.encode)(dec.unsignedInteger());
	                    const e = (0, base64url_js_1.encode)(dec.unsignedInteger());
	                    let jwk;
	                    if (keyObject.type === 'private') {
	                        jwk = {
	                            d: (0, base64url_js_1.encode)(dec.unsignedInteger()),
	                            p: (0, base64url_js_1.encode)(dec.unsignedInteger()),
	                            q: (0, base64url_js_1.encode)(dec.unsignedInteger()),
	                            dp: (0, base64url_js_1.encode)(dec.unsignedInteger()),
	                            dq: (0, base64url_js_1.encode)(dec.unsignedInteger()),
	                            qi: (0, base64url_js_1.encode)(dec.unsignedInteger()),
	                        };
	                    }
	                    dec.end();
	                    return { kty: 'RSA', n, e, ...jwk };
	                }
	                case 'ec': {
	                    const crv = (0, get_named_curve_js_1.default)(keyObject);
	                    let len;
	                    let offset;
	                    let correction;
	                    switch (crv) {
	                        case 'secp256k1':
	                            len = 64;
	                            offset = 31 + 2;
	                            correction = -1;
	                            break;
	                        case 'P-256':
	                            len = 64;
	                            offset = 34 + 2;
	                            correction = -1;
	                            break;
	                        case 'P-384':
	                            len = 96;
	                            offset = 33 + 2;
	                            correction = -3;
	                            break;
	                        case 'P-521':
	                            len = 132;
	                            offset = 33 + 2;
	                            correction = -3;
	                            break;
	                        default:
	                            throw new errors_js_1.JOSENotSupported('Unsupported curve');
	                    }
	                    if (keyObject.type === 'public') {
	                        const der = keyObject.export({ type: 'spki', format: 'der' });
	                        return {
	                            kty: 'EC',
	                            crv,
	                            x: (0, base64url_js_1.encode)(der.subarray(-len, -len / 2)),
	                            y: (0, base64url_js_1.encode)(der.subarray(-len / 2)),
	                        };
	                    }
	                    const der = keyObject.export({ type: 'pkcs8', format: 'der' });
	                    if (der.length < 100) {
	                        offset += correction;
	                    }
	                    return {
	                        ...keyToJWK((0, crypto_1.createPublicKey)(keyObject)),
	                        d: (0, base64url_js_1.encode)(der.subarray(offset, offset + len / 2)),
	                    };
	                }
	                case 'ed25519':
	                case 'x25519': {
	                    const crv = (0, get_named_curve_js_1.default)(keyObject);
	                    if (keyObject.type === 'public') {
	                        const der = keyObject.export({ type: 'spki', format: 'der' });
	                        return {
	                            kty: 'OKP',
	                            crv,
	                            x: (0, base64url_js_1.encode)(der.subarray(-32)),
	                        };
	                    }
	                    const der = keyObject.export({ type: 'pkcs8', format: 'der' });
	                    return {
	                        ...keyToJWK((0, crypto_1.createPublicKey)(keyObject)),
	                        d: (0, base64url_js_1.encode)(der.subarray(-32)),
	                    };
	                }
	                case 'ed448':
	                case 'x448': {
	                    const crv = (0, get_named_curve_js_1.default)(keyObject);
	                    if (keyObject.type === 'public') {
	                        const der = keyObject.export({ type: 'spki', format: 'der' });
	                        return {
	                            kty: 'OKP',
	                            crv,
	                            x: (0, base64url_js_1.encode)(der.subarray(crv === 'Ed448' ? -57 : -56)),
	                        };
	                    }
	                    const der = keyObject.export({ type: 'pkcs8', format: 'der' });
	                    return {
	                        ...keyToJWK((0, crypto_1.createPublicKey)(keyObject)),
	                        d: (0, base64url_js_1.encode)(der.subarray(crv === 'Ed448' ? -57 : -56)),
	                    };
	                }
	                default:
	                    throw new errors_js_1.JOSENotSupported('Unsupported key asymmetricKeyType');
	            }
	        }
	        default:
	            throw new errors_js_1.JOSENotSupported('Unsupported key type');
	    }
	};
	key_to_jwk.default = keyToJWK;
	return key_to_jwk;
}

var hasRequired_export;

function require_export () {
	if (hasRequired_export) return _export;
	hasRequired_export = 1;
	Object.defineProperty(_export, "__esModule", { value: true });
	_export.exportJWK = _export.exportPKCS8 = _export.exportSPKI = void 0;
	const asn1_js_1 = /*@__PURE__*/ requireAsn1();
	const asn1_js_2 = /*@__PURE__*/ requireAsn1();
	const key_to_jwk_js_1 = /*@__PURE__*/ requireKey_to_jwk();
	async function exportSPKI(key) {
	    return (0, asn1_js_1.toSPKI)(key);
	}
	_export.exportSPKI = exportSPKI;
	async function exportPKCS8(key) {
	    return (0, asn1_js_2.toPKCS8)(key);
	}
	_export.exportPKCS8 = exportPKCS8;
	async function exportJWK(key) {
	    return (0, key_to_jwk_js_1.default)(key);
	}
	_export.exportJWK = exportJWK;
	return _export;
}

var hasRequiredEncrypt_key_management;

function requireEncrypt_key_management () {
	if (hasRequiredEncrypt_key_management) return encrypt_key_management;
	hasRequiredEncrypt_key_management = 1;
	Object.defineProperty(encrypt_key_management, "__esModule", { value: true });
	const aeskw_js_1 = /*@__PURE__*/ requireAeskw();
	const ECDH = /*@__PURE__*/ requireEcdhes();
	const pbes2kw_js_1 = /*@__PURE__*/ requirePbes2kw();
	const rsaes_js_1 = /*@__PURE__*/ requireRsaes();
	const base64url_js_1 = /*@__PURE__*/ requireBase64url$2();
	const cek_js_1 = /*@__PURE__*/ requireCek();
	const errors_js_1 = /*@__PURE__*/ requireErrors();
	const export_js_1 = /*@__PURE__*/ require_export();
	const check_key_type_js_1 = /*@__PURE__*/ requireCheck_key_type();
	const aesgcmkw_js_1 = /*@__PURE__*/ requireAesgcmkw();
	async function encryptKeyManagement(alg, enc, key, providedCek, providedParameters = {}) {
	    let encryptedKey;
	    let parameters;
	    let cek;
	    (0, check_key_type_js_1.default)(alg, key, 'encrypt');
	    switch (alg) {
	        case 'dir': {
	            cek = key;
	            break;
	        }
	        case 'ECDH-ES':
	        case 'ECDH-ES+A128KW':
	        case 'ECDH-ES+A192KW':
	        case 'ECDH-ES+A256KW': {
	            if (!ECDH.ecdhAllowed(key)) {
	                throw new errors_js_1.JOSENotSupported('ECDH with the provided key is not allowed or not supported by your javascript runtime');
	            }
	            const { apu, apv } = providedParameters;
	            let { epk: ephemeralKey } = providedParameters;
	            ephemeralKey || (ephemeralKey = (await ECDH.generateEpk(key)).privateKey);
	            const { x, y, crv, kty } = await (0, export_js_1.exportJWK)(ephemeralKey);
	            const sharedSecret = await ECDH.deriveKey(key, ephemeralKey, alg === 'ECDH-ES' ? enc : alg, alg === 'ECDH-ES' ? (0, cek_js_1.bitLength)(enc) : parseInt(alg.slice(-5, -2), 10), apu, apv);
	            parameters = { epk: { x, crv, kty } };
	            if (kty === 'EC')
	                parameters.epk.y = y;
	            if (apu)
	                parameters.apu = (0, base64url_js_1.encode)(apu);
	            if (apv)
	                parameters.apv = (0, base64url_js_1.encode)(apv);
	            if (alg === 'ECDH-ES') {
	                cek = sharedSecret;
	                break;
	            }
	            cek = providedCek || (0, cek_js_1.default)(enc);
	            const kwAlg = alg.slice(-6);
	            encryptedKey = await (0, aeskw_js_1.wrap)(kwAlg, sharedSecret, cek);
	            break;
	        }
	        case 'RSA1_5':
	        case 'RSA-OAEP':
	        case 'RSA-OAEP-256':
	        case 'RSA-OAEP-384':
	        case 'RSA-OAEP-512': {
	            cek = providedCek || (0, cek_js_1.default)(enc);
	            encryptedKey = await (0, rsaes_js_1.encrypt)(alg, key, cek);
	            break;
	        }
	        case 'PBES2-HS256+A128KW':
	        case 'PBES2-HS384+A192KW':
	        case 'PBES2-HS512+A256KW': {
	            cek = providedCek || (0, cek_js_1.default)(enc);
	            const { p2c, p2s } = providedParameters;
	            ({ encryptedKey, ...parameters } = await (0, pbes2kw_js_1.encrypt)(alg, key, cek, p2c, p2s));
	            break;
	        }
	        case 'A128KW':
	        case 'A192KW':
	        case 'A256KW': {
	            cek = providedCek || (0, cek_js_1.default)(enc);
	            encryptedKey = await (0, aeskw_js_1.wrap)(alg, key, cek);
	            break;
	        }
	        case 'A128GCMKW':
	        case 'A192GCMKW':
	        case 'A256GCMKW': {
	            cek = providedCek || (0, cek_js_1.default)(enc);
	            const { iv } = providedParameters;
	            ({ encryptedKey, ...parameters } = await (0, aesgcmkw_js_1.wrap)(alg, key, cek, iv));
	            break;
	        }
	        default: {
	            throw new errors_js_1.JOSENotSupported('Invalid or unsupported "alg" (JWE Algorithm) header value');
	        }
	    }
	    return { cek, encryptedKey, parameters };
	}
	encrypt_key_management.default = encryptKeyManagement;
	return encrypt_key_management;
}

var hasRequiredEncrypt$3;

function requireEncrypt$3 () {
	if (hasRequiredEncrypt$3) return encrypt$2;
	hasRequiredEncrypt$3 = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.FlattenedEncrypt = exports.unprotected = void 0;
		const base64url_js_1 = /*@__PURE__*/ requireBase64url$2();
		const encrypt_js_1 = /*@__PURE__*/ requireEncrypt$4();
		const zlib_js_1 = /*@__PURE__*/ requireZlib();
		const iv_js_1 = /*@__PURE__*/ requireIv();
		const encrypt_key_management_js_1 = /*@__PURE__*/ requireEncrypt_key_management();
		const errors_js_1 = /*@__PURE__*/ requireErrors();
		const is_disjoint_js_1 = /*@__PURE__*/ requireIs_disjoint();
		const buffer_utils_js_1 = /*@__PURE__*/ requireBuffer_utils();
		const validate_crit_js_1 = /*@__PURE__*/ requireValidate_crit();
		exports.unprotected = Symbol();
		class FlattenedEncrypt {
		    constructor(plaintext) {
		        if (!(plaintext instanceof Uint8Array)) {
		            throw new TypeError('plaintext must be an instance of Uint8Array');
		        }
		        this._plaintext = plaintext;
		    }
		    setKeyManagementParameters(parameters) {
		        if (this._keyManagementParameters) {
		            throw new TypeError('setKeyManagementParameters can only be called once');
		        }
		        this._keyManagementParameters = parameters;
		        return this;
		    }
		    setProtectedHeader(protectedHeader) {
		        if (this._protectedHeader) {
		            throw new TypeError('setProtectedHeader can only be called once');
		        }
		        this._protectedHeader = protectedHeader;
		        return this;
		    }
		    setSharedUnprotectedHeader(sharedUnprotectedHeader) {
		        if (this._sharedUnprotectedHeader) {
		            throw new TypeError('setSharedUnprotectedHeader can only be called once');
		        }
		        this._sharedUnprotectedHeader = sharedUnprotectedHeader;
		        return this;
		    }
		    setUnprotectedHeader(unprotectedHeader) {
		        if (this._unprotectedHeader) {
		            throw new TypeError('setUnprotectedHeader can only be called once');
		        }
		        this._unprotectedHeader = unprotectedHeader;
		        return this;
		    }
		    setAdditionalAuthenticatedData(aad) {
		        this._aad = aad;
		        return this;
		    }
		    setContentEncryptionKey(cek) {
		        if (this._cek) {
		            throw new TypeError('setContentEncryptionKey can only be called once');
		        }
		        this._cek = cek;
		        return this;
		    }
		    setInitializationVector(iv) {
		        if (this._iv) {
		            throw new TypeError('setInitializationVector can only be called once');
		        }
		        this._iv = iv;
		        return this;
		    }
		    async encrypt(key, options) {
		        if (!this._protectedHeader && !this._unprotectedHeader && !this._sharedUnprotectedHeader) {
		            throw new errors_js_1.JWEInvalid('either setProtectedHeader, setUnprotectedHeader, or sharedUnprotectedHeader must be called before #encrypt()');
		        }
		        if (!(0, is_disjoint_js_1.default)(this._protectedHeader, this._unprotectedHeader, this._sharedUnprotectedHeader)) {
		            throw new errors_js_1.JWEInvalid('JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint');
		        }
		        const joseHeader = {
		            ...this._protectedHeader,
		            ...this._unprotectedHeader,
		            ...this._sharedUnprotectedHeader,
		        };
		        (0, validate_crit_js_1.default)(errors_js_1.JWEInvalid, new Map(), options === null || options === void 0 ? void 0 : options.crit, this._protectedHeader, joseHeader);
		        if (joseHeader.zip !== undefined) {
		            if (!this._protectedHeader || !this._protectedHeader.zip) {
		                throw new errors_js_1.JWEInvalid('JWE "zip" (Compression Algorithm) Header MUST be integrity protected');
		            }
		            if (joseHeader.zip !== 'DEF') {
		                throw new errors_js_1.JOSENotSupported('Unsupported JWE "zip" (Compression Algorithm) Header Parameter value');
		            }
		        }
		        const { alg, enc } = joseHeader;
		        if (typeof alg !== 'string' || !alg) {
		            throw new errors_js_1.JWEInvalid('JWE "alg" (Algorithm) Header Parameter missing or invalid');
		        }
		        if (typeof enc !== 'string' || !enc) {
		            throw new errors_js_1.JWEInvalid('JWE "enc" (Encryption Algorithm) Header Parameter missing or invalid');
		        }
		        let encryptedKey;
		        if (alg === 'dir') {
		            if (this._cek) {
		                throw new TypeError('setContentEncryptionKey cannot be called when using Direct Encryption');
		            }
		        }
		        else if (alg === 'ECDH-ES') {
		            if (this._cek) {
		                throw new TypeError('setContentEncryptionKey cannot be called when using Direct Key Agreement');
		            }
		        }
		        let cek;
		        {
		            let parameters;
		            ({ cek, encryptedKey, parameters } = await (0, encrypt_key_management_js_1.default)(alg, enc, key, this._cek, this._keyManagementParameters));
		            if (parameters) {
		                if (options && exports.unprotected in options) {
		                    if (!this._unprotectedHeader) {
		                        this.setUnprotectedHeader(parameters);
		                    }
		                    else {
		                        this._unprotectedHeader = { ...this._unprotectedHeader, ...parameters };
		                    }
		                }
		                else {
		                    if (!this._protectedHeader) {
		                        this.setProtectedHeader(parameters);
		                    }
		                    else {
		                        this._protectedHeader = { ...this._protectedHeader, ...parameters };
		                    }
		                }
		            }
		        }
		        this._iv || (this._iv = (0, iv_js_1.default)(enc));
		        let additionalData;
		        let protectedHeader;
		        let aadMember;
		        if (this._protectedHeader) {
		            protectedHeader = buffer_utils_js_1.encoder.encode((0, base64url_js_1.encode)(JSON.stringify(this._protectedHeader)));
		        }
		        else {
		            protectedHeader = buffer_utils_js_1.encoder.encode('');
		        }
		        if (this._aad) {
		            aadMember = (0, base64url_js_1.encode)(this._aad);
		            additionalData = (0, buffer_utils_js_1.concat)(protectedHeader, buffer_utils_js_1.encoder.encode('.'), buffer_utils_js_1.encoder.encode(aadMember));
		        }
		        else {
		            additionalData = protectedHeader;
		        }
		        let ciphertext;
		        let tag;
		        if (joseHeader.zip === 'DEF') {
		            const deflated = await ((options === null || options === void 0 ? void 0 : options.deflateRaw) || zlib_js_1.deflate)(this._plaintext);
		            ({ ciphertext, tag } = await (0, encrypt_js_1.default)(enc, deflated, cek, this._iv, additionalData));
		        }
		        else {
		            ({ ciphertext, tag } = await (0, encrypt_js_1.default)(enc, this._plaintext, cek, this._iv, additionalData));
		        }
		        const jwe = {
		            ciphertext: (0, base64url_js_1.encode)(ciphertext),
		            iv: (0, base64url_js_1.encode)(this._iv),
		            tag: (0, base64url_js_1.encode)(tag),
		        };
		        if (encryptedKey) {
		            jwe.encrypted_key = (0, base64url_js_1.encode)(encryptedKey);
		        }
		        if (aadMember) {
		            jwe.aad = aadMember;
		        }
		        if (this._protectedHeader) {
		            jwe.protected = buffer_utils_js_1.decoder.decode(protectedHeader);
		        }
		        if (this._sharedUnprotectedHeader) {
		            jwe.unprotected = this._sharedUnprotectedHeader;
		        }
		        if (this._unprotectedHeader) {
		            jwe.header = this._unprotectedHeader;
		        }
		        return jwe;
		    }
		}
		exports.FlattenedEncrypt = FlattenedEncrypt; 
	} (encrypt$2));
	return encrypt$2;
}

var hasRequiredEncrypt$2;

function requireEncrypt$2 () {
	if (hasRequiredEncrypt$2) return encrypt$3;
	hasRequiredEncrypt$2 = 1;
	Object.defineProperty(encrypt$3, "__esModule", { value: true });
	encrypt$3.GeneralEncrypt = void 0;
	const encrypt_js_1 = /*@__PURE__*/ requireEncrypt$3();
	const errors_js_1 = /*@__PURE__*/ requireErrors();
	const cek_js_1 = /*@__PURE__*/ requireCek();
	const is_disjoint_js_1 = /*@__PURE__*/ requireIs_disjoint();
	const encrypt_key_management_js_1 = /*@__PURE__*/ requireEncrypt_key_management();
	const base64url_js_1 = /*@__PURE__*/ requireBase64url$2();
	const validate_crit_js_1 = /*@__PURE__*/ requireValidate_crit();
	class IndividualRecipient {
	    constructor(enc, key, options) {
	        this.parent = enc;
	        this.key = key;
	        this.options = options;
	    }
	    setUnprotectedHeader(unprotectedHeader) {
	        if (this.unprotectedHeader) {
	            throw new TypeError('setUnprotectedHeader can only be called once');
	        }
	        this.unprotectedHeader = unprotectedHeader;
	        return this;
	    }
	    addRecipient(...args) {
	        return this.parent.addRecipient(...args);
	    }
	    encrypt(...args) {
	        return this.parent.encrypt(...args);
	    }
	    done() {
	        return this.parent;
	    }
	}
	class GeneralEncrypt {
	    constructor(plaintext) {
	        this._recipients = [];
	        this._plaintext = plaintext;
	    }
	    addRecipient(key, options) {
	        const recipient = new IndividualRecipient(this, key, { crit: options === null || options === void 0 ? void 0 : options.crit });
	        this._recipients.push(recipient);
	        return recipient;
	    }
	    setProtectedHeader(protectedHeader) {
	        if (this._protectedHeader) {
	            throw new TypeError('setProtectedHeader can only be called once');
	        }
	        this._protectedHeader = protectedHeader;
	        return this;
	    }
	    setSharedUnprotectedHeader(sharedUnprotectedHeader) {
	        if (this._unprotectedHeader) {
	            throw new TypeError('setSharedUnprotectedHeader can only be called once');
	        }
	        this._unprotectedHeader = sharedUnprotectedHeader;
	        return this;
	    }
	    setAdditionalAuthenticatedData(aad) {
	        this._aad = aad;
	        return this;
	    }
	    async encrypt(options) {
	        var _a, _b, _c;
	        if (!this._recipients.length) {
	            throw new errors_js_1.JWEInvalid('at least one recipient must be added');
	        }
	        options = { deflateRaw: options === null || options === void 0 ? void 0 : options.deflateRaw };
	        if (this._recipients.length === 1) {
	            const [recipient] = this._recipients;
	            const flattened = await new encrypt_js_1.FlattenedEncrypt(this._plaintext)
	                .setAdditionalAuthenticatedData(this._aad)
	                .setProtectedHeader(this._protectedHeader)
	                .setSharedUnprotectedHeader(this._unprotectedHeader)
	                .setUnprotectedHeader(recipient.unprotectedHeader)
	                .encrypt(recipient.key, { ...recipient.options, ...options });
	            let jwe = {
	                ciphertext: flattened.ciphertext,
	                iv: flattened.iv,
	                recipients: [{}],
	                tag: flattened.tag,
	            };
	            if (flattened.aad)
	                jwe.aad = flattened.aad;
	            if (flattened.protected)
	                jwe.protected = flattened.protected;
	            if (flattened.unprotected)
	                jwe.unprotected = flattened.unprotected;
	            if (flattened.encrypted_key)
	                jwe.recipients[0].encrypted_key = flattened.encrypted_key;
	            if (flattened.header)
	                jwe.recipients[0].header = flattened.header;
	            return jwe;
	        }
	        let enc;
	        for (let i = 0; i < this._recipients.length; i++) {
	            const recipient = this._recipients[i];
	            if (!(0, is_disjoint_js_1.default)(this._protectedHeader, this._unprotectedHeader, recipient.unprotectedHeader)) {
	                throw new errors_js_1.JWEInvalid('JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint');
	            }
	            const joseHeader = {
	                ...this._protectedHeader,
	                ...this._unprotectedHeader,
	                ...recipient.unprotectedHeader,
	            };
	            const { alg } = joseHeader;
	            if (typeof alg !== 'string' || !alg) {
	                throw new errors_js_1.JWEInvalid('JWE "alg" (Algorithm) Header Parameter missing or invalid');
	            }
	            if (alg === 'dir' || alg === 'ECDH-ES') {
	                throw new errors_js_1.JWEInvalid('"dir" and "ECDH-ES" alg may only be used with a single recipient');
	            }
	            if (typeof joseHeader.enc !== 'string' || !joseHeader.enc) {
	                throw new errors_js_1.JWEInvalid('JWE "enc" (Encryption Algorithm) Header Parameter missing or invalid');
	            }
	            if (!enc) {
	                enc = joseHeader.enc;
	            }
	            else if (enc !== joseHeader.enc) {
	                throw new errors_js_1.JWEInvalid('JWE "enc" (Encryption Algorithm) Header Parameter must be the same for all recipients');
	            }
	            (0, validate_crit_js_1.default)(errors_js_1.JWEInvalid, new Map(), recipient.options.crit, this._protectedHeader, joseHeader);
	            if (joseHeader.zip !== undefined) {
	                if (!this._protectedHeader || !this._protectedHeader.zip) {
	                    throw new errors_js_1.JWEInvalid('JWE "zip" (Compression Algorithm) Header MUST be integrity protected');
	                }
	            }
	        }
	        const cek = (0, cek_js_1.default)(enc);
	        let jwe = {
	            ciphertext: '',
	            iv: '',
	            recipients: [],
	            tag: '',
	        };
	        for (let i = 0; i < this._recipients.length; i++) {
	            const recipient = this._recipients[i];
	            const target = {};
	            jwe.recipients.push(target);
	            const joseHeader = {
	                ...this._protectedHeader,
	                ...this._unprotectedHeader,
	                ...recipient.unprotectedHeader,
	            };
	            const p2c = joseHeader.alg.startsWith('PBES2') ? 2048 + i : undefined;
	            if (i === 0) {
	                const flattened = await new encrypt_js_1.FlattenedEncrypt(this._plaintext)
	                    .setAdditionalAuthenticatedData(this._aad)
	                    .setContentEncryptionKey(cek)
	                    .setProtectedHeader(this._protectedHeader)
	                    .setSharedUnprotectedHeader(this._unprotectedHeader)
	                    .setUnprotectedHeader(recipient.unprotectedHeader)
	                    .setKeyManagementParameters({ p2c })
	                    .encrypt(recipient.key, {
	                    ...recipient.options,
	                    ...options,
	                    [encrypt_js_1.unprotected]: true,
	                });
	                jwe.ciphertext = flattened.ciphertext;
	                jwe.iv = flattened.iv;
	                jwe.tag = flattened.tag;
	                if (flattened.aad)
	                    jwe.aad = flattened.aad;
	                if (flattened.protected)
	                    jwe.protected = flattened.protected;
	                if (flattened.unprotected)
	                    jwe.unprotected = flattened.unprotected;
	                target.encrypted_key = flattened.encrypted_key;
	                if (flattened.header)
	                    target.header = flattened.header;
	                continue;
	            }
	            const { encryptedKey, parameters } = await (0, encrypt_key_management_js_1.default)(((_a = recipient.unprotectedHeader) === null || _a === void 0 ? void 0 : _a.alg) ||
	                ((_b = this._protectedHeader) === null || _b === void 0 ? void 0 : _b.alg) ||
	                ((_c = this._unprotectedHeader) === null || _c === void 0 ? void 0 : _c.alg), enc, recipient.key, cek, { p2c });
	            target.encrypted_key = (0, base64url_js_1.encode)(encryptedKey);
	            if (recipient.unprotectedHeader || parameters)
	                target.header = { ...recipient.unprotectedHeader, ...parameters };
	        }
	        return jwe;
	    }
	}
	encrypt$3.GeneralEncrypt = GeneralEncrypt;
	return encrypt$3;
}

var verify$4 = {};

var verify$3 = {};

var verify$2 = {};

var dsa_digest = {};

var hasRequiredDsa_digest;

function requireDsa_digest () {
	if (hasRequiredDsa_digest) return dsa_digest;
	hasRequiredDsa_digest = 1;
	Object.defineProperty(dsa_digest, "__esModule", { value: true });
	const errors_js_1 = /*@__PURE__*/ requireErrors();
	function dsaDigest(alg) {
	    switch (alg) {
	        case 'PS256':
	        case 'RS256':
	        case 'ES256':
	        case 'ES256K':
	            return 'sha256';
	        case 'PS384':
	        case 'RS384':
	        case 'ES384':
	            return 'sha384';
	        case 'PS512':
	        case 'RS512':
	        case 'ES512':
	            return 'sha512';
	        case 'EdDSA':
	            return undefined;
	        default:
	            throw new errors_js_1.JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
	    }
	}
	dsa_digest.default = dsaDigest;
	return dsa_digest;
}

var node_key = {};

var hasRequiredNode_key;

function requireNode_key () {
	if (hasRequiredNode_key) return node_key;
	hasRequiredNode_key = 1;
	Object.defineProperty(node_key, "__esModule", { value: true });
	const crypto_1 = require$$0$9;
	const get_named_curve_js_1 = /*@__PURE__*/ requireGet_named_curve();
	const errors_js_1 = /*@__PURE__*/ requireErrors();
	const check_modulus_length_js_1 = /*@__PURE__*/ requireCheck_modulus_length();
	const flags_js_1 = /*@__PURE__*/ requireFlags();
	const PSS = {
	    padding: crypto_1.constants.RSA_PKCS1_PSS_PADDING,
	    saltLength: crypto_1.constants.RSA_PSS_SALTLEN_DIGEST,
	};
	const ecCurveAlgMap = new Map([
	    ['ES256', 'P-256'],
	    ['ES256K', 'secp256k1'],
	    ['ES384', 'P-384'],
	    ['ES512', 'P-521'],
	]);
	function keyForCrypto(alg, key) {
	    switch (alg) {
	        case 'EdDSA':
	            if (!['ed25519', 'ed448'].includes(key.asymmetricKeyType)) {
	                throw new TypeError('Invalid key for this operation, its asymmetricKeyType must be ed25519 or ed448');
	            }
	            return key;
	        case 'RS256':
	        case 'RS384':
	        case 'RS512':
	            if (key.asymmetricKeyType !== 'rsa') {
	                throw new TypeError('Invalid key for this operation, its asymmetricKeyType must be rsa');
	            }
	            (0, check_modulus_length_js_1.default)(key, alg);
	            return key;
	        case flags_js_1.rsaPssParams && 'PS256':
	        case flags_js_1.rsaPssParams && 'PS384':
	        case flags_js_1.rsaPssParams && 'PS512':
	            if (key.asymmetricKeyType === 'rsa-pss') {
	                const { hashAlgorithm, mgf1HashAlgorithm, saltLength } = key.asymmetricKeyDetails;
	                const length = parseInt(alg.slice(-3), 10);
	                if (hashAlgorithm !== undefined &&
	                    (hashAlgorithm !== `sha${length}` || mgf1HashAlgorithm !== hashAlgorithm)) {
	                    throw new TypeError(`Invalid key for this operation, its RSA-PSS parameters do not meet the requirements of "alg" ${alg}`);
	                }
	                if (saltLength !== undefined && saltLength > length >> 3) {
	                    throw new TypeError(`Invalid key for this operation, its RSA-PSS parameter saltLength does not meet the requirements of "alg" ${alg}`);
	                }
	            }
	            else if (key.asymmetricKeyType !== 'rsa') {
	                throw new TypeError('Invalid key for this operation, its asymmetricKeyType must be rsa or rsa-pss');
	            }
	            (0, check_modulus_length_js_1.default)(key, alg);
	            return { key, ...PSS };
	        case !flags_js_1.rsaPssParams && 'PS256':
	        case !flags_js_1.rsaPssParams && 'PS384':
	        case !flags_js_1.rsaPssParams && 'PS512':
	            if (key.asymmetricKeyType !== 'rsa') {
	                throw new TypeError('Invalid key for this operation, its asymmetricKeyType must be rsa');
	            }
	            (0, check_modulus_length_js_1.default)(key, alg);
	            return { key, ...PSS };
	        case 'ES256':
	        case 'ES256K':
	        case 'ES384':
	        case 'ES512': {
	            if (key.asymmetricKeyType !== 'ec') {
	                throw new TypeError('Invalid key for this operation, its asymmetricKeyType must be ec');
	            }
	            const actual = (0, get_named_curve_js_1.default)(key);
	            const expected = ecCurveAlgMap.get(alg);
	            if (actual !== expected) {
	                throw new TypeError(`Invalid key curve for the algorithm, its curve must be ${expected}, got ${actual}`);
	            }
	            return { dsaEncoding: 'ieee-p1363', key };
	        }
	        default:
	            throw new errors_js_1.JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
	    }
	}
	node_key.default = keyForCrypto;
	return node_key;
}

var sign$4 = {};

var hmac_digest = {};

var hasRequiredHmac_digest;

function requireHmac_digest () {
	if (hasRequiredHmac_digest) return hmac_digest;
	hasRequiredHmac_digest = 1;
	Object.defineProperty(hmac_digest, "__esModule", { value: true });
	const errors_js_1 = /*@__PURE__*/ requireErrors();
	function hmacDigest(alg) {
	    switch (alg) {
	        case 'HS256':
	            return 'sha256';
	        case 'HS384':
	            return 'sha384';
	        case 'HS512':
	            return 'sha512';
	        default:
	            throw new errors_js_1.JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
	    }
	}
	hmac_digest.default = hmacDigest;
	return hmac_digest;
}

var get_sign_verify_key = {};

var hasRequiredGet_sign_verify_key;

function requireGet_sign_verify_key () {
	if (hasRequiredGet_sign_verify_key) return get_sign_verify_key;
	hasRequiredGet_sign_verify_key = 1;
	Object.defineProperty(get_sign_verify_key, "__esModule", { value: true });
	const crypto_1 = require$$0$9;
	const webcrypto_js_1 = /*@__PURE__*/ requireWebcrypto();
	const crypto_key_js_1 = /*@__PURE__*/ requireCrypto_key();
	const invalid_key_input_js_1 = /*@__PURE__*/ requireInvalid_key_input();
	const is_key_like_js_1 = /*@__PURE__*/ requireIs_key_like();
	function getSignVerifyKey(alg, key, usage) {
	    if (key instanceof Uint8Array) {
	        if (!alg.startsWith('HS')) {
	            throw new TypeError((0, invalid_key_input_js_1.default)(key, ...is_key_like_js_1.types));
	        }
	        return (0, crypto_1.createSecretKey)(key);
	    }
	    if (key instanceof crypto_1.KeyObject) {
	        return key;
	    }
	    if ((0, webcrypto_js_1.isCryptoKey)(key)) {
	        (0, crypto_key_js_1.checkSigCryptoKey)(key, alg, usage);
	        return crypto_1.KeyObject.from(key);
	    }
	    throw new TypeError((0, invalid_key_input_js_1.default)(key, ...is_key_like_js_1.types, 'Uint8Array'));
	}
	get_sign_verify_key.default = getSignVerifyKey;
	return get_sign_verify_key;
}

var hasRequiredSign$4;

function requireSign$4 () {
	if (hasRequiredSign$4) return sign$4;
	hasRequiredSign$4 = 1;
	Object.defineProperty(sign$4, "__esModule", { value: true });
	const crypto = require$$0$9;
	const util_1 = require$$1;
	const dsa_digest_js_1 = /*@__PURE__*/ requireDsa_digest();
	const hmac_digest_js_1 = /*@__PURE__*/ requireHmac_digest();
	const node_key_js_1 = /*@__PURE__*/ requireNode_key();
	const get_sign_verify_key_js_1 = /*@__PURE__*/ requireGet_sign_verify_key();
	let oneShotSign;
	if (crypto.sign.length > 3) {
	    oneShotSign = (0, util_1.promisify)(crypto.sign);
	}
	else {
	    oneShotSign = crypto.sign;
	}
	const sign = async (alg, key, data) => {
	    const keyObject = (0, get_sign_verify_key_js_1.default)(alg, key, 'sign');
	    if (alg.startsWith('HS')) {
	        const hmac = crypto.createHmac((0, hmac_digest_js_1.default)(alg), keyObject);
	        hmac.update(data);
	        return hmac.digest();
	    }
	    return oneShotSign((0, dsa_digest_js_1.default)(alg), data, (0, node_key_js_1.default)(alg, keyObject));
	};
	sign$4.default = sign;
	return sign$4;
}

var hasRequiredVerify$4;

function requireVerify$4 () {
	if (hasRequiredVerify$4) return verify$2;
	hasRequiredVerify$4 = 1;
	Object.defineProperty(verify$2, "__esModule", { value: true });
	const crypto = require$$0$9;
	const util_1 = require$$1;
	const dsa_digest_js_1 = /*@__PURE__*/ requireDsa_digest();
	const node_key_js_1 = /*@__PURE__*/ requireNode_key();
	const sign_js_1 = /*@__PURE__*/ requireSign$4();
	const get_sign_verify_key_js_1 = /*@__PURE__*/ requireGet_sign_verify_key();
	const flags_js_1 = /*@__PURE__*/ requireFlags();
	let oneShotVerify;
	if (crypto.verify.length > 4 && flags_js_1.oneShotCallback) {
	    oneShotVerify = (0, util_1.promisify)(crypto.verify);
	}
	else {
	    oneShotVerify = crypto.verify;
	}
	const verify = async (alg, key, signature, data) => {
	    const keyObject = (0, get_sign_verify_key_js_1.default)(alg, key, 'verify');
	    if (alg.startsWith('HS')) {
	        const expected = await (0, sign_js_1.default)(alg, keyObject, data);
	        const actual = signature;
	        try {
	            return crypto.timingSafeEqual(actual, expected);
	        }
	        catch {
	            return false;
	        }
	    }
	    const algorithm = (0, dsa_digest_js_1.default)(alg);
	    const keyInput = (0, node_key_js_1.default)(alg, keyObject);
	    try {
	        return await oneShotVerify(algorithm, data, keyInput, signature);
	    }
	    catch {
	        return false;
	    }
	};
	verify$2.default = verify;
	return verify$2;
}

var hasRequiredVerify$3;

function requireVerify$3 () {
	if (hasRequiredVerify$3) return verify$3;
	hasRequiredVerify$3 = 1;
	Object.defineProperty(verify$3, "__esModule", { value: true });
	verify$3.flattenedVerify = void 0;
	const base64url_js_1 = /*@__PURE__*/ requireBase64url$2();
	const verify_js_1 = /*@__PURE__*/ requireVerify$4();
	const errors_js_1 = /*@__PURE__*/ requireErrors();
	const buffer_utils_js_1 = /*@__PURE__*/ requireBuffer_utils();
	const is_disjoint_js_1 = /*@__PURE__*/ requireIs_disjoint();
	const is_object_js_1 = /*@__PURE__*/ requireIs_object();
	const check_key_type_js_1 = /*@__PURE__*/ requireCheck_key_type();
	const validate_crit_js_1 = /*@__PURE__*/ requireValidate_crit();
	const validate_algorithms_js_1 = /*@__PURE__*/ requireValidate_algorithms();
	async function flattenedVerify(jws, key, options) {
	    var _a;
	    if (!(0, is_object_js_1.default)(jws)) {
	        throw new errors_js_1.JWSInvalid('Flattened JWS must be an object');
	    }
	    if (jws.protected === undefined && jws.header === undefined) {
	        throw new errors_js_1.JWSInvalid('Flattened JWS must have either of the "protected" or "header" members');
	    }
	    if (jws.protected !== undefined && typeof jws.protected !== 'string') {
	        throw new errors_js_1.JWSInvalid('JWS Protected Header incorrect type');
	    }
	    if (jws.payload === undefined) {
	        throw new errors_js_1.JWSInvalid('JWS Payload missing');
	    }
	    if (typeof jws.signature !== 'string') {
	        throw new errors_js_1.JWSInvalid('JWS Signature missing or incorrect type');
	    }
	    if (jws.header !== undefined && !(0, is_object_js_1.default)(jws.header)) {
	        throw new errors_js_1.JWSInvalid('JWS Unprotected Header incorrect type');
	    }
	    let parsedProt = {};
	    if (jws.protected) {
	        try {
	            const protectedHeader = (0, base64url_js_1.decode)(jws.protected);
	            parsedProt = JSON.parse(buffer_utils_js_1.decoder.decode(protectedHeader));
	        }
	        catch {
	            throw new errors_js_1.JWSInvalid('JWS Protected Header is invalid');
	        }
	    }
	    if (!(0, is_disjoint_js_1.default)(parsedProt, jws.header)) {
	        throw new errors_js_1.JWSInvalid('JWS Protected and JWS Unprotected Header Parameter names must be disjoint');
	    }
	    const joseHeader = {
	        ...parsedProt,
	        ...jws.header,
	    };
	    const extensions = (0, validate_crit_js_1.default)(errors_js_1.JWSInvalid, new Map([['b64', true]]), options === null || options === void 0 ? void 0 : options.crit, parsedProt, joseHeader);
	    let b64 = true;
	    if (extensions.has('b64')) {
	        b64 = parsedProt.b64;
	        if (typeof b64 !== 'boolean') {
	            throw new errors_js_1.JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
	        }
	    }
	    const { alg } = joseHeader;
	    if (typeof alg !== 'string' || !alg) {
	        throw new errors_js_1.JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
	    }
	    const algorithms = options && (0, validate_algorithms_js_1.default)('algorithms', options.algorithms);
	    if (algorithms && !algorithms.has(alg)) {
	        throw new errors_js_1.JOSEAlgNotAllowed('"alg" (Algorithm) Header Parameter not allowed');
	    }
	    if (b64) {
	        if (typeof jws.payload !== 'string') {
	            throw new errors_js_1.JWSInvalid('JWS Payload must be a string');
	        }
	    }
	    else if (typeof jws.payload !== 'string' && !(jws.payload instanceof Uint8Array)) {
	        throw new errors_js_1.JWSInvalid('JWS Payload must be a string or an Uint8Array instance');
	    }
	    let resolvedKey = false;
	    if (typeof key === 'function') {
	        key = await key(parsedProt, jws);
	        resolvedKey = true;
	    }
	    (0, check_key_type_js_1.default)(alg, key, 'verify');
	    const data = (0, buffer_utils_js_1.concat)(buffer_utils_js_1.encoder.encode((_a = jws.protected) !== null && _a !== void 0 ? _a : ''), buffer_utils_js_1.encoder.encode('.'), typeof jws.payload === 'string' ? buffer_utils_js_1.encoder.encode(jws.payload) : jws.payload);
	    let signature;
	    try {
	        signature = (0, base64url_js_1.decode)(jws.signature);
	    }
	    catch {
	        throw new errors_js_1.JWSInvalid('Failed to base64url decode the signature');
	    }
	    const verified = await (0, verify_js_1.default)(alg, key, signature, data);
	    if (!verified) {
	        throw new errors_js_1.JWSSignatureVerificationFailed();
	    }
	    let payload;
	    if (b64) {
	        try {
	            payload = (0, base64url_js_1.decode)(jws.payload);
	        }
	        catch {
	            throw new errors_js_1.JWSInvalid('Failed to base64url decode the payload');
	        }
	    }
	    else if (typeof jws.payload === 'string') {
	        payload = buffer_utils_js_1.encoder.encode(jws.payload);
	    }
	    else {
	        payload = jws.payload;
	    }
	    const result = { payload };
	    if (jws.protected !== undefined) {
	        result.protectedHeader = parsedProt;
	    }
	    if (jws.header !== undefined) {
	        result.unprotectedHeader = jws.header;
	    }
	    if (resolvedKey) {
	        return { ...result, key };
	    }
	    return result;
	}
	verify$3.flattenedVerify = flattenedVerify;
	return verify$3;
}

var hasRequiredVerify$2;

function requireVerify$2 () {
	if (hasRequiredVerify$2) return verify$4;
	hasRequiredVerify$2 = 1;
	Object.defineProperty(verify$4, "__esModule", { value: true });
	verify$4.compactVerify = void 0;
	const verify_js_1 = /*@__PURE__*/ requireVerify$3();
	const errors_js_1 = /*@__PURE__*/ requireErrors();
	const buffer_utils_js_1 = /*@__PURE__*/ requireBuffer_utils();
	async function compactVerify(jws, key, options) {
	    if (jws instanceof Uint8Array) {
	        jws = buffer_utils_js_1.decoder.decode(jws);
	    }
	    if (typeof jws !== 'string') {
	        throw new errors_js_1.JWSInvalid('Compact JWS must be a string or Uint8Array');
	    }
	    const { 0: protectedHeader, 1: payload, 2: signature, length } = jws.split('.');
	    if (length !== 3) {
	        throw new errors_js_1.JWSInvalid('Invalid Compact JWS');
	    }
	    const verified = await (0, verify_js_1.flattenedVerify)({ payload, protected: protectedHeader, signature }, key, options);
	    const result = { payload: verified.payload, protectedHeader: verified.protectedHeader };
	    if (typeof key === 'function') {
	        return { ...result, key: verified.key };
	    }
	    return result;
	}
	verify$4.compactVerify = compactVerify;
	return verify$4;
}

var verify$1 = {};

var hasRequiredVerify$1;

function requireVerify$1 () {
	if (hasRequiredVerify$1) return verify$1;
	hasRequiredVerify$1 = 1;
	Object.defineProperty(verify$1, "__esModule", { value: true });
	verify$1.generalVerify = void 0;
	const verify_js_1 = /*@__PURE__*/ requireVerify$3();
	const errors_js_1 = /*@__PURE__*/ requireErrors();
	const is_object_js_1 = /*@__PURE__*/ requireIs_object();
	async function generalVerify(jws, key, options) {
	    if (!(0, is_object_js_1.default)(jws)) {
	        throw new errors_js_1.JWSInvalid('General JWS must be an object');
	    }
	    if (!Array.isArray(jws.signatures) || !jws.signatures.every(is_object_js_1.default)) {
	        throw new errors_js_1.JWSInvalid('JWS Signatures missing or incorrect type');
	    }
	    for (const signature of jws.signatures) {
	        try {
	            return await (0, verify_js_1.flattenedVerify)({
	                header: signature.header,
	                payload: jws.payload,
	                protected: signature.protected,
	                signature: signature.signature,
	            }, key, options);
	        }
	        catch {
	        }
	    }
	    throw new errors_js_1.JWSSignatureVerificationFailed();
	}
	verify$1.generalVerify = generalVerify;
	return verify$1;
}

var verify = {};

var jwt_claims_set = {};

var epoch = {};

var hasRequiredEpoch;

function requireEpoch () {
	if (hasRequiredEpoch) return epoch;
	hasRequiredEpoch = 1;
	Object.defineProperty(epoch, "__esModule", { value: true });
	epoch.default = (date) => Math.floor(date.getTime() / 1000);
	return epoch;
}

var secs = {};

var hasRequiredSecs;

function requireSecs () {
	if (hasRequiredSecs) return secs;
	hasRequiredSecs = 1;
	Object.defineProperty(secs, "__esModule", { value: true });
	const minute = 60;
	const hour = minute * 60;
	const day = hour * 24;
	const week = day * 7;
	const year = day * 365.25;
	const REGEX = /^(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)$/i;
	secs.default = (str) => {
	    const matched = REGEX.exec(str);
	    if (!matched) {
	        throw new TypeError('Invalid time period format');
	    }
	    const value = parseFloat(matched[1]);
	    const unit = matched[2].toLowerCase();
	    switch (unit) {
	        case 'sec':
	        case 'secs':
	        case 'second':
	        case 'seconds':
	        case 's':
	            return Math.round(value);
	        case 'minute':
	        case 'minutes':
	        case 'min':
	        case 'mins':
	        case 'm':
	            return Math.round(value * minute);
	        case 'hour':
	        case 'hours':
	        case 'hr':
	        case 'hrs':
	        case 'h':
	            return Math.round(value * hour);
	        case 'day':
	        case 'days':
	        case 'd':
	            return Math.round(value * day);
	        case 'week':
	        case 'weeks':
	        case 'w':
	            return Math.round(value * week);
	        default:
	            return Math.round(value * year);
	    }
	};
	return secs;
}

var hasRequiredJwt_claims_set;

function requireJwt_claims_set () {
	if (hasRequiredJwt_claims_set) return jwt_claims_set;
	hasRequiredJwt_claims_set = 1;
	Object.defineProperty(jwt_claims_set, "__esModule", { value: true });
	const errors_js_1 = /*@__PURE__*/ requireErrors();
	const buffer_utils_js_1 = /*@__PURE__*/ requireBuffer_utils();
	const epoch_js_1 = /*@__PURE__*/ requireEpoch();
	const secs_js_1 = /*@__PURE__*/ requireSecs();
	const is_object_js_1 = /*@__PURE__*/ requireIs_object();
	const normalizeTyp = (value) => value.toLowerCase().replace(/^application\//, '');
	const checkAudiencePresence = (audPayload, audOption) => {
	    if (typeof audPayload === 'string') {
	        return audOption.includes(audPayload);
	    }
	    if (Array.isArray(audPayload)) {
	        return audOption.some(Set.prototype.has.bind(new Set(audPayload)));
	    }
	    return false;
	};
	jwt_claims_set.default = (protectedHeader, encodedPayload, options = {}) => {
	    const { typ } = options;
	    if (typ &&
	        (typeof protectedHeader.typ !== 'string' ||
	            normalizeTyp(protectedHeader.typ) !== normalizeTyp(typ))) {
	        throw new errors_js_1.JWTClaimValidationFailed('unexpected "typ" JWT header value', 'typ', 'check_failed');
	    }
	    let payload;
	    try {
	        payload = JSON.parse(buffer_utils_js_1.decoder.decode(encodedPayload));
	    }
	    catch {
	    }
	    if (!(0, is_object_js_1.default)(payload)) {
	        throw new errors_js_1.JWTInvalid('JWT Claims Set must be a top-level JSON object');
	    }
	    const { requiredClaims = [], issuer, subject, audience, maxTokenAge } = options;
	    if (maxTokenAge !== undefined)
	        requiredClaims.push('iat');
	    if (audience !== undefined)
	        requiredClaims.push('aud');
	    if (subject !== undefined)
	        requiredClaims.push('sub');
	    if (issuer !== undefined)
	        requiredClaims.push('iss');
	    for (const claim of new Set(requiredClaims.reverse())) {
	        if (!(claim in payload)) {
	            throw new errors_js_1.JWTClaimValidationFailed(`missing required "${claim}" claim`, claim, 'missing');
	        }
	    }
	    if (issuer && !(Array.isArray(issuer) ? issuer : [issuer]).includes(payload.iss)) {
	        throw new errors_js_1.JWTClaimValidationFailed('unexpected "iss" claim value', 'iss', 'check_failed');
	    }
	    if (subject && payload.sub !== subject) {
	        throw new errors_js_1.JWTClaimValidationFailed('unexpected "sub" claim value', 'sub', 'check_failed');
	    }
	    if (audience &&
	        !checkAudiencePresence(payload.aud, typeof audience === 'string' ? [audience] : audience)) {
	        throw new errors_js_1.JWTClaimValidationFailed('unexpected "aud" claim value', 'aud', 'check_failed');
	    }
	    let tolerance;
	    switch (typeof options.clockTolerance) {
	        case 'string':
	            tolerance = (0, secs_js_1.default)(options.clockTolerance);
	            break;
	        case 'number':
	            tolerance = options.clockTolerance;
	            break;
	        case 'undefined':
	            tolerance = 0;
	            break;
	        default:
	            throw new TypeError('Invalid clockTolerance option type');
	    }
	    const { currentDate } = options;
	    const now = (0, epoch_js_1.default)(currentDate || new Date());
	    if ((payload.iat !== undefined || maxTokenAge) && typeof payload.iat !== 'number') {
	        throw new errors_js_1.JWTClaimValidationFailed('"iat" claim must be a number', 'iat', 'invalid');
	    }
	    if (payload.nbf !== undefined) {
	        if (typeof payload.nbf !== 'number') {
	            throw new errors_js_1.JWTClaimValidationFailed('"nbf" claim must be a number', 'nbf', 'invalid');
	        }
	        if (payload.nbf > now + tolerance) {
	            throw new errors_js_1.JWTClaimValidationFailed('"nbf" claim timestamp check failed', 'nbf', 'check_failed');
	        }
	    }
	    if (payload.exp !== undefined) {
	        if (typeof payload.exp !== 'number') {
	            throw new errors_js_1.JWTClaimValidationFailed('"exp" claim must be a number', 'exp', 'invalid');
	        }
	        if (payload.exp <= now - tolerance) {
	            throw new errors_js_1.JWTExpired('"exp" claim timestamp check failed', 'exp', 'check_failed');
	        }
	    }
	    if (maxTokenAge) {
	        const age = now - payload.iat;
	        const max = typeof maxTokenAge === 'number' ? maxTokenAge : (0, secs_js_1.default)(maxTokenAge);
	        if (age - tolerance > max) {
	            throw new errors_js_1.JWTExpired('"iat" claim timestamp check failed (too far in the past)', 'iat', 'check_failed');
	        }
	        if (age < 0 - tolerance) {
	            throw new errors_js_1.JWTClaimValidationFailed('"iat" claim timestamp check failed (it should be in the past)', 'iat', 'check_failed');
	        }
	    }
	    return payload;
	};
	return jwt_claims_set;
}

var hasRequiredVerify;

function requireVerify () {
	if (hasRequiredVerify) return verify;
	hasRequiredVerify = 1;
	Object.defineProperty(verify, "__esModule", { value: true });
	verify.jwtVerify = void 0;
	const verify_js_1 = /*@__PURE__*/ requireVerify$2();
	const jwt_claims_set_js_1 = /*@__PURE__*/ requireJwt_claims_set();
	const errors_js_1 = /*@__PURE__*/ requireErrors();
	async function jwtVerify(jwt, key, options) {
	    var _a;
	    const verified = await (0, verify_js_1.compactVerify)(jwt, key, options);
	    if (((_a = verified.protectedHeader.crit) === null || _a === void 0 ? void 0 : _a.includes('b64')) && verified.protectedHeader.b64 === false) {
	        throw new errors_js_1.JWTInvalid('JWTs MUST NOT use unencoded payload');
	    }
	    const payload = (0, jwt_claims_set_js_1.default)(verified.protectedHeader, verified.payload, options);
	    const result = { payload, protectedHeader: verified.protectedHeader };
	    if (typeof key === 'function') {
	        return { ...result, key: verified.key };
	    }
	    return result;
	}
	verify.jwtVerify = jwtVerify;
	return verify;
}

var decrypt = {};

var hasRequiredDecrypt;

function requireDecrypt () {
	if (hasRequiredDecrypt) return decrypt;
	hasRequiredDecrypt = 1;
	Object.defineProperty(decrypt, "__esModule", { value: true });
	decrypt.jwtDecrypt = void 0;
	const decrypt_js_1 = /*@__PURE__*/ requireDecrypt$2();
	const jwt_claims_set_js_1 = /*@__PURE__*/ requireJwt_claims_set();
	const errors_js_1 = /*@__PURE__*/ requireErrors();
	async function jwtDecrypt(jwt, key, options) {
	    const decrypted = await (0, decrypt_js_1.compactDecrypt)(jwt, key, options);
	    const payload = (0, jwt_claims_set_js_1.default)(decrypted.protectedHeader, decrypted.plaintext, options);
	    const { protectedHeader } = decrypted;
	    if (protectedHeader.iss !== undefined && protectedHeader.iss !== payload.iss) {
	        throw new errors_js_1.JWTClaimValidationFailed('replicated "iss" claim header parameter mismatch', 'iss', 'mismatch');
	    }
	    if (protectedHeader.sub !== undefined && protectedHeader.sub !== payload.sub) {
	        throw new errors_js_1.JWTClaimValidationFailed('replicated "sub" claim header parameter mismatch', 'sub', 'mismatch');
	    }
	    if (protectedHeader.aud !== undefined &&
	        JSON.stringify(protectedHeader.aud) !== JSON.stringify(payload.aud)) {
	        throw new errors_js_1.JWTClaimValidationFailed('replicated "aud" claim header parameter mismatch', 'aud', 'mismatch');
	    }
	    const result = { payload, protectedHeader };
	    if (typeof key === 'function') {
	        return { ...result, key: decrypted.key };
	    }
	    return result;
	}
	decrypt.jwtDecrypt = jwtDecrypt;
	return decrypt;
}

var encrypt$1 = {};

var hasRequiredEncrypt$1;

function requireEncrypt$1 () {
	if (hasRequiredEncrypt$1) return encrypt$1;
	hasRequiredEncrypt$1 = 1;
	Object.defineProperty(encrypt$1, "__esModule", { value: true });
	encrypt$1.CompactEncrypt = void 0;
	const encrypt_js_1 = /*@__PURE__*/ requireEncrypt$3();
	class CompactEncrypt {
	    constructor(plaintext) {
	        this._flattened = new encrypt_js_1.FlattenedEncrypt(plaintext);
	    }
	    setContentEncryptionKey(cek) {
	        this._flattened.setContentEncryptionKey(cek);
	        return this;
	    }
	    setInitializationVector(iv) {
	        this._flattened.setInitializationVector(iv);
	        return this;
	    }
	    setProtectedHeader(protectedHeader) {
	        this._flattened.setProtectedHeader(protectedHeader);
	        return this;
	    }
	    setKeyManagementParameters(parameters) {
	        this._flattened.setKeyManagementParameters(parameters);
	        return this;
	    }
	    async encrypt(key, options) {
	        const jwe = await this._flattened.encrypt(key, options);
	        return [jwe.protected, jwe.encrypted_key, jwe.iv, jwe.ciphertext, jwe.tag].join('.');
	    }
	}
	encrypt$1.CompactEncrypt = CompactEncrypt;
	return encrypt$1;
}

var sign$3 = {};

var sign$2 = {};

var hasRequiredSign$3;

function requireSign$3 () {
	if (hasRequiredSign$3) return sign$2;
	hasRequiredSign$3 = 1;
	Object.defineProperty(sign$2, "__esModule", { value: true });
	sign$2.FlattenedSign = void 0;
	const base64url_js_1 = /*@__PURE__*/ requireBase64url$2();
	const sign_js_1 = /*@__PURE__*/ requireSign$4();
	const is_disjoint_js_1 = /*@__PURE__*/ requireIs_disjoint();
	const errors_js_1 = /*@__PURE__*/ requireErrors();
	const buffer_utils_js_1 = /*@__PURE__*/ requireBuffer_utils();
	const check_key_type_js_1 = /*@__PURE__*/ requireCheck_key_type();
	const validate_crit_js_1 = /*@__PURE__*/ requireValidate_crit();
	class FlattenedSign {
	    constructor(payload) {
	        if (!(payload instanceof Uint8Array)) {
	            throw new TypeError('payload must be an instance of Uint8Array');
	        }
	        this._payload = payload;
	    }
	    setProtectedHeader(protectedHeader) {
	        if (this._protectedHeader) {
	            throw new TypeError('setProtectedHeader can only be called once');
	        }
	        this._protectedHeader = protectedHeader;
	        return this;
	    }
	    setUnprotectedHeader(unprotectedHeader) {
	        if (this._unprotectedHeader) {
	            throw new TypeError('setUnprotectedHeader can only be called once');
	        }
	        this._unprotectedHeader = unprotectedHeader;
	        return this;
	    }
	    async sign(key, options) {
	        if (!this._protectedHeader && !this._unprotectedHeader) {
	            throw new errors_js_1.JWSInvalid('either setProtectedHeader or setUnprotectedHeader must be called before #sign()');
	        }
	        if (!(0, is_disjoint_js_1.default)(this._protectedHeader, this._unprotectedHeader)) {
	            throw new errors_js_1.JWSInvalid('JWS Protected and JWS Unprotected Header Parameter names must be disjoint');
	        }
	        const joseHeader = {
	            ...this._protectedHeader,
	            ...this._unprotectedHeader,
	        };
	        const extensions = (0, validate_crit_js_1.default)(errors_js_1.JWSInvalid, new Map([['b64', true]]), options === null || options === void 0 ? void 0 : options.crit, this._protectedHeader, joseHeader);
	        let b64 = true;
	        if (extensions.has('b64')) {
	            b64 = this._protectedHeader.b64;
	            if (typeof b64 !== 'boolean') {
	                throw new errors_js_1.JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
	            }
	        }
	        const { alg } = joseHeader;
	        if (typeof alg !== 'string' || !alg) {
	            throw new errors_js_1.JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
	        }
	        (0, check_key_type_js_1.default)(alg, key, 'sign');
	        let payload = this._payload;
	        if (b64) {
	            payload = buffer_utils_js_1.encoder.encode((0, base64url_js_1.encode)(payload));
	        }
	        let protectedHeader;
	        if (this._protectedHeader) {
	            protectedHeader = buffer_utils_js_1.encoder.encode((0, base64url_js_1.encode)(JSON.stringify(this._protectedHeader)));
	        }
	        else {
	            protectedHeader = buffer_utils_js_1.encoder.encode('');
	        }
	        const data = (0, buffer_utils_js_1.concat)(protectedHeader, buffer_utils_js_1.encoder.encode('.'), payload);
	        const signature = await (0, sign_js_1.default)(alg, key, data);
	        const jws = {
	            signature: (0, base64url_js_1.encode)(signature),
	            payload: '',
	        };
	        if (b64) {
	            jws.payload = buffer_utils_js_1.decoder.decode(payload);
	        }
	        if (this._unprotectedHeader) {
	            jws.header = this._unprotectedHeader;
	        }
	        if (this._protectedHeader) {
	            jws.protected = buffer_utils_js_1.decoder.decode(protectedHeader);
	        }
	        return jws;
	    }
	}
	sign$2.FlattenedSign = FlattenedSign;
	return sign$2;
}

var hasRequiredSign$2;

function requireSign$2 () {
	if (hasRequiredSign$2) return sign$3;
	hasRequiredSign$2 = 1;
	Object.defineProperty(sign$3, "__esModule", { value: true });
	sign$3.CompactSign = void 0;
	const sign_js_1 = /*@__PURE__*/ requireSign$3();
	class CompactSign {
	    constructor(payload) {
	        this._flattened = new sign_js_1.FlattenedSign(payload);
	    }
	    setProtectedHeader(protectedHeader) {
	        this._flattened.setProtectedHeader(protectedHeader);
	        return this;
	    }
	    async sign(key, options) {
	        const jws = await this._flattened.sign(key, options);
	        if (jws.payload === undefined) {
	            throw new TypeError('use the flattened module for creating JWS with b64: false');
	        }
	        return `${jws.protected}.${jws.payload}.${jws.signature}`;
	    }
	}
	sign$3.CompactSign = CompactSign;
	return sign$3;
}

var sign$1 = {};

var hasRequiredSign$1;

function requireSign$1 () {
	if (hasRequiredSign$1) return sign$1;
	hasRequiredSign$1 = 1;
	Object.defineProperty(sign$1, "__esModule", { value: true });
	sign$1.GeneralSign = void 0;
	const sign_js_1 = /*@__PURE__*/ requireSign$3();
	const errors_js_1 = /*@__PURE__*/ requireErrors();
	class IndividualSignature {
	    constructor(sig, key, options) {
	        this.parent = sig;
	        this.key = key;
	        this.options = options;
	    }
	    setProtectedHeader(protectedHeader) {
	        if (this.protectedHeader) {
	            throw new TypeError('setProtectedHeader can only be called once');
	        }
	        this.protectedHeader = protectedHeader;
	        return this;
	    }
	    setUnprotectedHeader(unprotectedHeader) {
	        if (this.unprotectedHeader) {
	            throw new TypeError('setUnprotectedHeader can only be called once');
	        }
	        this.unprotectedHeader = unprotectedHeader;
	        return this;
	    }
	    addSignature(...args) {
	        return this.parent.addSignature(...args);
	    }
	    sign(...args) {
	        return this.parent.sign(...args);
	    }
	    done() {
	        return this.parent;
	    }
	}
	class GeneralSign {
	    constructor(payload) {
	        this._signatures = [];
	        this._payload = payload;
	    }
	    addSignature(key, options) {
	        const signature = new IndividualSignature(this, key, options);
	        this._signatures.push(signature);
	        return signature;
	    }
	    async sign() {
	        if (!this._signatures.length) {
	            throw new errors_js_1.JWSInvalid('at least one signature must be added');
	        }
	        const jws = {
	            signatures: [],
	            payload: '',
	        };
	        for (let i = 0; i < this._signatures.length; i++) {
	            const signature = this._signatures[i];
	            const flattened = new sign_js_1.FlattenedSign(this._payload);
	            flattened.setProtectedHeader(signature.protectedHeader);
	            flattened.setUnprotectedHeader(signature.unprotectedHeader);
	            const { payload, ...rest } = await flattened.sign(signature.key, signature.options);
	            if (i === 0) {
	                jws.payload = payload;
	            }
	            else if (jws.payload !== payload) {
	                throw new errors_js_1.JWSInvalid('inconsistent use of JWS Unencoded Payload (RFC7797)');
	            }
	            jws.signatures.push(rest);
	        }
	        return jws;
	    }
	}
	sign$1.GeneralSign = GeneralSign;
	return sign$1;
}

var sign = {};

var produce = {};

var hasRequiredProduce;

function requireProduce () {
	if (hasRequiredProduce) return produce;
	hasRequiredProduce = 1;
	Object.defineProperty(produce, "__esModule", { value: true });
	produce.ProduceJWT = void 0;
	const epoch_js_1 = /*@__PURE__*/ requireEpoch();
	const is_object_js_1 = /*@__PURE__*/ requireIs_object();
	const secs_js_1 = /*@__PURE__*/ requireSecs();
	class ProduceJWT {
	    constructor(payload) {
	        if (!(0, is_object_js_1.default)(payload)) {
	            throw new TypeError('JWT Claims Set MUST be an object');
	        }
	        this._payload = payload;
	    }
	    setIssuer(issuer) {
	        this._payload = { ...this._payload, iss: issuer };
	        return this;
	    }
	    setSubject(subject) {
	        this._payload = { ...this._payload, sub: subject };
	        return this;
	    }
	    setAudience(audience) {
	        this._payload = { ...this._payload, aud: audience };
	        return this;
	    }
	    setJti(jwtId) {
	        this._payload = { ...this._payload, jti: jwtId };
	        return this;
	    }
	    setNotBefore(input) {
	        if (typeof input === 'number') {
	            this._payload = { ...this._payload, nbf: input };
	        }
	        else {
	            this._payload = { ...this._payload, nbf: (0, epoch_js_1.default)(new Date()) + (0, secs_js_1.default)(input) };
	        }
	        return this;
	    }
	    setExpirationTime(input) {
	        if (typeof input === 'number') {
	            this._payload = { ...this._payload, exp: input };
	        }
	        else {
	            this._payload = { ...this._payload, exp: (0, epoch_js_1.default)(new Date()) + (0, secs_js_1.default)(input) };
	        }
	        return this;
	    }
	    setIssuedAt(input) {
	        if (typeof input === 'undefined') {
	            this._payload = { ...this._payload, iat: (0, epoch_js_1.default)(new Date()) };
	        }
	        else {
	            this._payload = { ...this._payload, iat: input };
	        }
	        return this;
	    }
	}
	produce.ProduceJWT = ProduceJWT;
	return produce;
}

var hasRequiredSign;

function requireSign () {
	if (hasRequiredSign) return sign;
	hasRequiredSign = 1;
	Object.defineProperty(sign, "__esModule", { value: true });
	sign.SignJWT = void 0;
	const sign_js_1 = /*@__PURE__*/ requireSign$2();
	const errors_js_1 = /*@__PURE__*/ requireErrors();
	const buffer_utils_js_1 = /*@__PURE__*/ requireBuffer_utils();
	const produce_js_1 = /*@__PURE__*/ requireProduce();
	class SignJWT extends produce_js_1.ProduceJWT {
	    setProtectedHeader(protectedHeader) {
	        this._protectedHeader = protectedHeader;
	        return this;
	    }
	    async sign(key, options) {
	        var _a;
	        const sig = new sign_js_1.CompactSign(buffer_utils_js_1.encoder.encode(JSON.stringify(this._payload)));
	        sig.setProtectedHeader(this._protectedHeader);
	        if (Array.isArray((_a = this._protectedHeader) === null || _a === void 0 ? void 0 : _a.crit) &&
	            this._protectedHeader.crit.includes('b64') &&
	            this._protectedHeader.b64 === false) {
	            throw new errors_js_1.JWTInvalid('JWTs MUST NOT use unencoded payload');
	        }
	        return sig.sign(key, options);
	    }
	}
	sign.SignJWT = SignJWT;
	return sign;
}

var encrypt = {};

var hasRequiredEncrypt;

function requireEncrypt () {
	if (hasRequiredEncrypt) return encrypt;
	hasRequiredEncrypt = 1;
	Object.defineProperty(encrypt, "__esModule", { value: true });
	encrypt.EncryptJWT = void 0;
	const encrypt_js_1 = /*@__PURE__*/ requireEncrypt$1();
	const buffer_utils_js_1 = /*@__PURE__*/ requireBuffer_utils();
	const produce_js_1 = /*@__PURE__*/ requireProduce();
	class EncryptJWT extends produce_js_1.ProduceJWT {
	    setProtectedHeader(protectedHeader) {
	        if (this._protectedHeader) {
	            throw new TypeError('setProtectedHeader can only be called once');
	        }
	        this._protectedHeader = protectedHeader;
	        return this;
	    }
	    setKeyManagementParameters(parameters) {
	        if (this._keyManagementParameters) {
	            throw new TypeError('setKeyManagementParameters can only be called once');
	        }
	        this._keyManagementParameters = parameters;
	        return this;
	    }
	    setContentEncryptionKey(cek) {
	        if (this._cek) {
	            throw new TypeError('setContentEncryptionKey can only be called once');
	        }
	        this._cek = cek;
	        return this;
	    }
	    setInitializationVector(iv) {
	        if (this._iv) {
	            throw new TypeError('setInitializationVector can only be called once');
	        }
	        this._iv = iv;
	        return this;
	    }
	    replicateIssuerAsHeader() {
	        this._replicateIssuerAsHeader = true;
	        return this;
	    }
	    replicateSubjectAsHeader() {
	        this._replicateSubjectAsHeader = true;
	        return this;
	    }
	    replicateAudienceAsHeader() {
	        this._replicateAudienceAsHeader = true;
	        return this;
	    }
	    async encrypt(key, options) {
	        const enc = new encrypt_js_1.CompactEncrypt(buffer_utils_js_1.encoder.encode(JSON.stringify(this._payload)));
	        if (this._replicateIssuerAsHeader) {
	            this._protectedHeader = { ...this._protectedHeader, iss: this._payload.iss };
	        }
	        if (this._replicateSubjectAsHeader) {
	            this._protectedHeader = { ...this._protectedHeader, sub: this._payload.sub };
	        }
	        if (this._replicateAudienceAsHeader) {
	            this._protectedHeader = { ...this._protectedHeader, aud: this._payload.aud };
	        }
	        enc.setProtectedHeader(this._protectedHeader);
	        if (this._iv) {
	            enc.setInitializationVector(this._iv);
	        }
	        if (this._cek) {
	            enc.setContentEncryptionKey(this._cek);
	        }
	        if (this._keyManagementParameters) {
	            enc.setKeyManagementParameters(this._keyManagementParameters);
	        }
	        return enc.encrypt(key, options);
	    }
	}
	encrypt.EncryptJWT = EncryptJWT;
	return encrypt;
}

var thumbprint = {};

var hasRequiredThumbprint;

function requireThumbprint () {
	if (hasRequiredThumbprint) return thumbprint;
	hasRequiredThumbprint = 1;
	Object.defineProperty(thumbprint, "__esModule", { value: true });
	thumbprint.calculateJwkThumbprintUri = thumbprint.calculateJwkThumbprint = void 0;
	const digest_js_1 = /*@__PURE__*/ requireDigest();
	const base64url_js_1 = /*@__PURE__*/ requireBase64url$2();
	const errors_js_1 = /*@__PURE__*/ requireErrors();
	const buffer_utils_js_1 = /*@__PURE__*/ requireBuffer_utils();
	const is_object_js_1 = /*@__PURE__*/ requireIs_object();
	const check = (value, description) => {
	    if (typeof value !== 'string' || !value) {
	        throw new errors_js_1.JWKInvalid(`${description} missing or invalid`);
	    }
	};
	async function calculateJwkThumbprint(jwk, digestAlgorithm) {
	    if (!(0, is_object_js_1.default)(jwk)) {
	        throw new TypeError('JWK must be an object');
	    }
	    digestAlgorithm !== null && digestAlgorithm !== void 0 ? digestAlgorithm : (digestAlgorithm = 'sha256');
	    if (digestAlgorithm !== 'sha256' &&
	        digestAlgorithm !== 'sha384' &&
	        digestAlgorithm !== 'sha512') {
	        throw new TypeError('digestAlgorithm must one of "sha256", "sha384", or "sha512"');
	    }
	    let components;
	    switch (jwk.kty) {
	        case 'EC':
	            check(jwk.crv, '"crv" (Curve) Parameter');
	            check(jwk.x, '"x" (X Coordinate) Parameter');
	            check(jwk.y, '"y" (Y Coordinate) Parameter');
	            components = { crv: jwk.crv, kty: jwk.kty, x: jwk.x, y: jwk.y };
	            break;
	        case 'OKP':
	            check(jwk.crv, '"crv" (Subtype of Key Pair) Parameter');
	            check(jwk.x, '"x" (Public Key) Parameter');
	            components = { crv: jwk.crv, kty: jwk.kty, x: jwk.x };
	            break;
	        case 'RSA':
	            check(jwk.e, '"e" (Exponent) Parameter');
	            check(jwk.n, '"n" (Modulus) Parameter');
	            components = { e: jwk.e, kty: jwk.kty, n: jwk.n };
	            break;
	        case 'oct':
	            check(jwk.k, '"k" (Key Value) Parameter');
	            components = { k: jwk.k, kty: jwk.kty };
	            break;
	        default:
	            throw new errors_js_1.JOSENotSupported('"kty" (Key Type) Parameter missing or unsupported');
	    }
	    const data = buffer_utils_js_1.encoder.encode(JSON.stringify(components));
	    return (0, base64url_js_1.encode)(await (0, digest_js_1.default)(digestAlgorithm, data));
	}
	thumbprint.calculateJwkThumbprint = calculateJwkThumbprint;
	async function calculateJwkThumbprintUri(jwk, digestAlgorithm) {
	    digestAlgorithm !== null && digestAlgorithm !== void 0 ? digestAlgorithm : (digestAlgorithm = 'sha256');
	    const thumbprint = await calculateJwkThumbprint(jwk, digestAlgorithm);
	    return `urn:ietf:params:oauth:jwk-thumbprint:sha-${digestAlgorithm.slice(-3)}:${thumbprint}`;
	}
	thumbprint.calculateJwkThumbprintUri = calculateJwkThumbprintUri;
	return thumbprint;
}

var embedded = {};

var hasRequiredEmbedded;

function requireEmbedded () {
	if (hasRequiredEmbedded) return embedded;
	hasRequiredEmbedded = 1;
	Object.defineProperty(embedded, "__esModule", { value: true });
	embedded.EmbeddedJWK = void 0;
	const import_js_1 = /*@__PURE__*/ require_import();
	const is_object_js_1 = /*@__PURE__*/ requireIs_object();
	const errors_js_1 = /*@__PURE__*/ requireErrors();
	async function EmbeddedJWK(protectedHeader, token) {
	    const joseHeader = {
	        ...protectedHeader,
	        ...token === null || token === void 0 ? void 0 : token.header,
	    };
	    if (!(0, is_object_js_1.default)(joseHeader.jwk)) {
	        throw new errors_js_1.JWSInvalid('"jwk" (JSON Web Key) Header Parameter must be a JSON object');
	    }
	    const key = await (0, import_js_1.importJWK)({ ...joseHeader.jwk, ext: true }, joseHeader.alg, true);
	    if (key instanceof Uint8Array || key.type !== 'public') {
	        throw new errors_js_1.JWSInvalid('"jwk" (JSON Web Key) Header Parameter must be a public key');
	    }
	    return key;
	}
	embedded.EmbeddedJWK = EmbeddedJWK;
	return embedded;
}

var local = {};

var hasRequiredLocal;

function requireLocal () {
	if (hasRequiredLocal) return local;
	hasRequiredLocal = 1;
	Object.defineProperty(local, "__esModule", { value: true });
	local.createLocalJWKSet = local.LocalJWKSet = local.isJWKSLike = void 0;
	const import_js_1 = /*@__PURE__*/ require_import();
	const errors_js_1 = /*@__PURE__*/ requireErrors();
	const is_object_js_1 = /*@__PURE__*/ requireIs_object();
	function getKtyFromAlg(alg) {
	    switch (typeof alg === 'string' && alg.slice(0, 2)) {
	        case 'RS':
	        case 'PS':
	            return 'RSA';
	        case 'ES':
	            return 'EC';
	        case 'Ed':
	            return 'OKP';
	        default:
	            throw new errors_js_1.JOSENotSupported('Unsupported "alg" value for a JSON Web Key Set');
	    }
	}
	function isJWKSLike(jwks) {
	    return (jwks &&
	        typeof jwks === 'object' &&
	        Array.isArray(jwks.keys) &&
	        jwks.keys.every(isJWKLike));
	}
	local.isJWKSLike = isJWKSLike;
	function isJWKLike(key) {
	    return (0, is_object_js_1.default)(key);
	}
	function clone(obj) {
	    if (typeof structuredClone === 'function') {
	        return structuredClone(obj);
	    }
	    return JSON.parse(JSON.stringify(obj));
	}
	class LocalJWKSet {
	    constructor(jwks) {
	        this._cached = new WeakMap();
	        if (!isJWKSLike(jwks)) {
	            throw new errors_js_1.JWKSInvalid('JSON Web Key Set malformed');
	        }
	        this._jwks = clone(jwks);
	    }
	    async getKey(protectedHeader, token) {
	        const { alg, kid } = { ...protectedHeader, ...token === null || token === void 0 ? void 0 : token.header };
	        const kty = getKtyFromAlg(alg);
	        const candidates = this._jwks.keys.filter((jwk) => {
	            let candidate = kty === jwk.kty;
	            if (candidate && typeof kid === 'string') {
	                candidate = kid === jwk.kid;
	            }
	            if (candidate && typeof jwk.alg === 'string') {
	                candidate = alg === jwk.alg;
	            }
	            if (candidate && typeof jwk.use === 'string') {
	                candidate = jwk.use === 'sig';
	            }
	            if (candidate && Array.isArray(jwk.key_ops)) {
	                candidate = jwk.key_ops.includes('verify');
	            }
	            if (candidate && alg === 'EdDSA') {
	                candidate = jwk.crv === 'Ed25519' || jwk.crv === 'Ed448';
	            }
	            if (candidate) {
	                switch (alg) {
	                    case 'ES256':
	                        candidate = jwk.crv === 'P-256';
	                        break;
	                    case 'ES256K':
	                        candidate = jwk.crv === 'secp256k1';
	                        break;
	                    case 'ES384':
	                        candidate = jwk.crv === 'P-384';
	                        break;
	                    case 'ES512':
	                        candidate = jwk.crv === 'P-521';
	                        break;
	                }
	            }
	            return candidate;
	        });
	        const { 0: jwk, length } = candidates;
	        if (length === 0) {
	            throw new errors_js_1.JWKSNoMatchingKey();
	        }
	        else if (length !== 1) {
	            const error = new errors_js_1.JWKSMultipleMatchingKeys();
	            const { _cached } = this;
	            error[Symbol.asyncIterator] = async function* () {
	                for (const jwk of candidates) {
	                    try {
	                        yield await importWithAlgCache(_cached, jwk, alg);
	                    }
	                    catch {
	                        continue;
	                    }
	                }
	            };
	            throw error;
	        }
	        return importWithAlgCache(this._cached, jwk, alg);
	    }
	}
	local.LocalJWKSet = LocalJWKSet;
	async function importWithAlgCache(cache, jwk, alg) {
	    const cached = cache.get(jwk) || cache.set(jwk, {}).get(jwk);
	    if (cached[alg] === undefined) {
	        const key = await (0, import_js_1.importJWK)({ ...jwk, ext: true }, alg);
	        if (key instanceof Uint8Array || key.type !== 'public') {
	            throw new errors_js_1.JWKSInvalid('JSON Web Key Set members must be public keys');
	        }
	        cached[alg] = key;
	    }
	    return cached[alg];
	}
	function createLocalJWKSet(jwks) {
	    const set = new LocalJWKSet(jwks);
	    return async function (protectedHeader, token) {
	        return set.getKey(protectedHeader, token);
	    };
	}
	local.createLocalJWKSet = createLocalJWKSet;
	return local;
}

var remote = {};

var fetch_jwks = {};

var hasRequiredFetch_jwks;

function requireFetch_jwks () {
	if (hasRequiredFetch_jwks) return fetch_jwks;
	hasRequiredFetch_jwks = 1;
	Object.defineProperty(fetch_jwks, "__esModule", { value: true });
	const http = require$$0$2;
	const https = require$$2;
	const events_1 = require$$2$1;
	const errors_js_1 = /*@__PURE__*/ requireErrors();
	const buffer_utils_js_1 = /*@__PURE__*/ requireBuffer_utils();
	const fetchJwks = async (url, timeout, options) => {
	    let get;
	    switch (url.protocol) {
	        case 'https:':
	            get = https.get;
	            break;
	        case 'http:':
	            get = http.get;
	            break;
	        default:
	            throw new TypeError('Unsupported URL protocol.');
	    }
	    const { agent, headers } = options;
	    const req = get(url.href, {
	        agent,
	        timeout,
	        headers,
	    });
	    const [response] = (await Promise.race([(0, events_1.once)(req, 'response'), (0, events_1.once)(req, 'timeout')]));
	    if (!response) {
	        req.destroy();
	        throw new errors_js_1.JWKSTimeout();
	    }
	    if (response.statusCode !== 200) {
	        throw new errors_js_1.JOSEError('Expected 200 OK from the JSON Web Key Set HTTP response');
	    }
	    const parts = [];
	    for await (const part of response) {
	        parts.push(part);
	    }
	    try {
	        return JSON.parse(buffer_utils_js_1.decoder.decode((0, buffer_utils_js_1.concat)(...parts)));
	    }
	    catch {
	        throw new errors_js_1.JOSEError('Failed to parse the JSON Web Key Set HTTP response as JSON');
	    }
	};
	fetch_jwks.default = fetchJwks;
	return fetch_jwks;
}

var hasRequiredRemote;

function requireRemote () {
	if (hasRequiredRemote) return remote;
	hasRequiredRemote = 1;
	Object.defineProperty(remote, "__esModule", { value: true });
	remote.createRemoteJWKSet = void 0;
	const fetch_jwks_js_1 = /*@__PURE__*/ requireFetch_jwks();
	const errors_js_1 = /*@__PURE__*/ requireErrors();
	const local_js_1 = /*@__PURE__*/ requireLocal();
	function isCloudflareWorkers() {
	    return (typeof WebSocketPair !== 'undefined' ||
	        (typeof navigator !== 'undefined' && navigator.userAgent === 'Cloudflare-Workers') ||
	        (typeof EdgeRuntime !== 'undefined' && EdgeRuntime === 'vercel'));
	}
	class RemoteJWKSet extends local_js_1.LocalJWKSet {
	    constructor(url, options) {
	        super({ keys: [] });
	        this._jwks = undefined;
	        if (!(url instanceof URL)) {
	            throw new TypeError('url must be an instance of URL');
	        }
	        this._url = new URL(url.href);
	        this._options = { agent: options === null || options === void 0 ? void 0 : options.agent, headers: options === null || options === void 0 ? void 0 : options.headers };
	        this._timeoutDuration =
	            typeof (options === null || options === void 0 ? void 0 : options.timeoutDuration) === 'number' ? options === null || options === void 0 ? void 0 : options.timeoutDuration : 5000;
	        this._cooldownDuration =
	            typeof (options === null || options === void 0 ? void 0 : options.cooldownDuration) === 'number' ? options === null || options === void 0 ? void 0 : options.cooldownDuration : 30000;
	        this._cacheMaxAge = typeof (options === null || options === void 0 ? void 0 : options.cacheMaxAge) === 'number' ? options === null || options === void 0 ? void 0 : options.cacheMaxAge : 600000;
	    }
	    coolingDown() {
	        return typeof this._jwksTimestamp === 'number'
	            ? Date.now() < this._jwksTimestamp + this._cooldownDuration
	            : false;
	    }
	    fresh() {
	        return typeof this._jwksTimestamp === 'number'
	            ? Date.now() < this._jwksTimestamp + this._cacheMaxAge
	            : false;
	    }
	    async getKey(protectedHeader, token) {
	        if (!this._jwks || !this.fresh()) {
	            await this.reload();
	        }
	        try {
	            return await super.getKey(protectedHeader, token);
	        }
	        catch (err) {
	            if (err instanceof errors_js_1.JWKSNoMatchingKey) {
	                if (this.coolingDown() === false) {
	                    await this.reload();
	                    return super.getKey(protectedHeader, token);
	                }
	            }
	            throw err;
	        }
	    }
	    async reload() {
	        if (this._pendingFetch && isCloudflareWorkers()) {
	            this._pendingFetch = undefined;
	        }
	        this._pendingFetch || (this._pendingFetch = (0, fetch_jwks_js_1.default)(this._url, this._timeoutDuration, this._options)
	            .then((json) => {
	            if (!(0, local_js_1.isJWKSLike)(json)) {
	                throw new errors_js_1.JWKSInvalid('JSON Web Key Set malformed');
	            }
	            this._jwks = { keys: json.keys };
	            this._jwksTimestamp = Date.now();
	            this._pendingFetch = undefined;
	        })
	            .catch((err) => {
	            this._pendingFetch = undefined;
	            throw err;
	        }));
	        await this._pendingFetch;
	    }
	}
	function createRemoteJWKSet(url, options) {
	    const set = new RemoteJWKSet(url, options);
	    return async function (protectedHeader, token) {
	        return set.getKey(protectedHeader, token);
	    };
	}
	remote.createRemoteJWKSet = createRemoteJWKSet;
	return remote;
}

var unsecured = {};

var hasRequiredUnsecured;

function requireUnsecured () {
	if (hasRequiredUnsecured) return unsecured;
	hasRequiredUnsecured = 1;
	Object.defineProperty(unsecured, "__esModule", { value: true });
	unsecured.UnsecuredJWT = void 0;
	const base64url = /*@__PURE__*/ requireBase64url$2();
	const buffer_utils_js_1 = /*@__PURE__*/ requireBuffer_utils();
	const errors_js_1 = /*@__PURE__*/ requireErrors();
	const jwt_claims_set_js_1 = /*@__PURE__*/ requireJwt_claims_set();
	const produce_js_1 = /*@__PURE__*/ requireProduce();
	class UnsecuredJWT extends produce_js_1.ProduceJWT {
	    encode() {
	        const header = base64url.encode(JSON.stringify({ alg: 'none' }));
	        const payload = base64url.encode(JSON.stringify(this._payload));
	        return `${header}.${payload}.`;
	    }
	    static decode(jwt, options) {
	        if (typeof jwt !== 'string') {
	            throw new errors_js_1.JWTInvalid('Unsecured JWT must be a string');
	        }
	        const { 0: encodedHeader, 1: encodedPayload, 2: signature, length } = jwt.split('.');
	        if (length !== 3 || signature !== '') {
	            throw new errors_js_1.JWTInvalid('Invalid Unsecured JWT');
	        }
	        let header;
	        try {
	            header = JSON.parse(buffer_utils_js_1.decoder.decode(base64url.decode(encodedHeader)));
	            if (header.alg !== 'none')
	                throw new Error();
	        }
	        catch {
	            throw new errors_js_1.JWTInvalid('Invalid Unsecured JWT');
	        }
	        const payload = (0, jwt_claims_set_js_1.default)(header, base64url.decode(encodedPayload), options);
	        return { payload, header };
	    }
	}
	unsecured.UnsecuredJWT = UnsecuredJWT;
	return unsecured;
}

var decode_protected_header = {};

var base64url$1 = {};

var hasRequiredBase64url$1;

function requireBase64url$1 () {
	if (hasRequiredBase64url$1) return base64url$1;
	hasRequiredBase64url$1 = 1;
	Object.defineProperty(base64url$1, "__esModule", { value: true });
	base64url$1.decode = base64url$1.encode = void 0;
	const base64url = /*@__PURE__*/ requireBase64url$2();
	base64url$1.encode = base64url.encode;
	base64url$1.decode = base64url.decode;
	return base64url$1;
}

var hasRequiredDecode_protected_header;

function requireDecode_protected_header () {
	if (hasRequiredDecode_protected_header) return decode_protected_header;
	hasRequiredDecode_protected_header = 1;
	Object.defineProperty(decode_protected_header, "__esModule", { value: true });
	decode_protected_header.decodeProtectedHeader = void 0;
	const base64url_js_1 = /*@__PURE__*/ requireBase64url$1();
	const buffer_utils_js_1 = /*@__PURE__*/ requireBuffer_utils();
	const is_object_js_1 = /*@__PURE__*/ requireIs_object();
	function decodeProtectedHeader(token) {
	    let protectedB64u;
	    if (typeof token === 'string') {
	        const parts = token.split('.');
	        if (parts.length === 3 || parts.length === 5) {
	            [protectedB64u] = parts;
	        }
	    }
	    else if (typeof token === 'object' && token) {
	        if ('protected' in token) {
	            protectedB64u = token.protected;
	        }
	        else {
	            throw new TypeError('Token does not contain a Protected Header');
	        }
	    }
	    try {
	        if (typeof protectedB64u !== 'string' || !protectedB64u) {
	            throw new Error();
	        }
	        const result = JSON.parse(buffer_utils_js_1.decoder.decode((0, base64url_js_1.decode)(protectedB64u)));
	        if (!(0, is_object_js_1.default)(result)) {
	            throw new Error();
	        }
	        return result;
	    }
	    catch {
	        throw new TypeError('Invalid Token or Protected Header formatting');
	    }
	}
	decode_protected_header.decodeProtectedHeader = decodeProtectedHeader;
	return decode_protected_header;
}

var decode_jwt$1 = {};

var hasRequiredDecode_jwt$1;

function requireDecode_jwt$1 () {
	if (hasRequiredDecode_jwt$1) return decode_jwt$1;
	hasRequiredDecode_jwt$1 = 1;
	Object.defineProperty(decode_jwt$1, "__esModule", { value: true });
	decode_jwt$1.decodeJwt = void 0;
	const base64url_js_1 = /*@__PURE__*/ requireBase64url$1();
	const buffer_utils_js_1 = /*@__PURE__*/ requireBuffer_utils();
	const is_object_js_1 = /*@__PURE__*/ requireIs_object();
	const errors_js_1 = /*@__PURE__*/ requireErrors();
	function decodeJwt(jwt) {
	    if (typeof jwt !== 'string')
	        throw new errors_js_1.JWTInvalid('JWTs must use Compact JWS serialization, JWT must be a string');
	    const { 1: payload, length } = jwt.split('.');
	    if (length === 5)
	        throw new errors_js_1.JWTInvalid('Only JWTs using Compact JWS serialization can be decoded');
	    if (length !== 3)
	        throw new errors_js_1.JWTInvalid('Invalid JWT');
	    if (!payload)
	        throw new errors_js_1.JWTInvalid('JWTs must contain a payload');
	    let decoded;
	    try {
	        decoded = (0, base64url_js_1.decode)(payload);
	    }
	    catch {
	        throw new errors_js_1.JWTInvalid('Failed to base64url decode the payload');
	    }
	    let result;
	    try {
	        result = JSON.parse(buffer_utils_js_1.decoder.decode(decoded));
	    }
	    catch {
	        throw new errors_js_1.JWTInvalid('Failed to parse the decoded payload as JSON');
	    }
	    if (!(0, is_object_js_1.default)(result))
	        throw new errors_js_1.JWTInvalid('Invalid JWT Claims Set');
	    return result;
	}
	decode_jwt$1.decodeJwt = decodeJwt;
	return decode_jwt$1;
}

var generate_key_pair = {};

var generate = {};

var hasRequiredGenerate;

function requireGenerate () {
	if (hasRequiredGenerate) return generate;
	hasRequiredGenerate = 1;
	Object.defineProperty(generate, "__esModule", { value: true });
	generate.generateKeyPair = generate.generateSecret = void 0;
	const crypto_1 = require$$0$9;
	const util_1 = require$$1;
	const random_js_1 = /*@__PURE__*/ requireRandom();
	const check_modulus_length_js_1 = /*@__PURE__*/ requireCheck_modulus_length();
	const errors_js_1 = /*@__PURE__*/ requireErrors();
	const generate$1 = (0, util_1.promisify)(crypto_1.generateKeyPair);
	async function generateSecret(alg, options) {
	    let length;
	    switch (alg) {
	        case 'HS256':
	        case 'HS384':
	        case 'HS512':
	        case 'A128CBC-HS256':
	        case 'A192CBC-HS384':
	        case 'A256CBC-HS512':
	            length = parseInt(alg.slice(-3), 10);
	            break;
	        case 'A128KW':
	        case 'A192KW':
	        case 'A256KW':
	        case 'A128GCMKW':
	        case 'A192GCMKW':
	        case 'A256GCMKW':
	        case 'A128GCM':
	        case 'A192GCM':
	        case 'A256GCM':
	            length = parseInt(alg.slice(1, 4), 10);
	            break;
	        default:
	            throw new errors_js_1.JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
	    }
	    return (0, crypto_1.createSecretKey)((0, random_js_1.default)(new Uint8Array(length >> 3)));
	}
	generate.generateSecret = generateSecret;
	async function generateKeyPair(alg, options) {
	    var _a, _b;
	    switch (alg) {
	        case 'RS256':
	        case 'RS384':
	        case 'RS512':
	        case 'PS256':
	        case 'PS384':
	        case 'PS512':
	        case 'RSA-OAEP':
	        case 'RSA-OAEP-256':
	        case 'RSA-OAEP-384':
	        case 'RSA-OAEP-512':
	        case 'RSA1_5': {
	            const modulusLength = (_a = options === null || options === void 0 ? void 0 : options.modulusLength) !== null && _a !== void 0 ? _a : 2048;
	            if (typeof modulusLength !== 'number' || modulusLength < 2048) {
	                throw new errors_js_1.JOSENotSupported('Invalid or unsupported modulusLength option provided, 2048 bits or larger keys must be used');
	            }
	            const keypair = await generate$1('rsa', {
	                modulusLength,
	                publicExponent: 0x10001,
	            });
	            (0, check_modulus_length_js_1.setModulusLength)(keypair.privateKey, modulusLength);
	            (0, check_modulus_length_js_1.setModulusLength)(keypair.publicKey, modulusLength);
	            return keypair;
	        }
	        case 'ES256':
	            return generate$1('ec', { namedCurve: 'P-256' });
	        case 'ES256K':
	            return generate$1('ec', { namedCurve: 'secp256k1' });
	        case 'ES384':
	            return generate$1('ec', { namedCurve: 'P-384' });
	        case 'ES512':
	            return generate$1('ec', { namedCurve: 'P-521' });
	        case 'EdDSA': {
	            switch (options === null || options === void 0 ? void 0 : options.crv) {
	                case undefined:
	                case 'Ed25519':
	                    return generate$1('ed25519');
	                case 'Ed448':
	                    return generate$1('ed448');
	                default:
	                    throw new errors_js_1.JOSENotSupported('Invalid or unsupported crv option provided, supported values are Ed25519 and Ed448');
	            }
	        }
	        case 'ECDH-ES':
	        case 'ECDH-ES+A128KW':
	        case 'ECDH-ES+A192KW':
	        case 'ECDH-ES+A256KW':
	            const crv = (_b = options === null || options === void 0 ? void 0 : options.crv) !== null && _b !== void 0 ? _b : 'P-256';
	            switch (crv) {
	                case undefined:
	                case 'P-256':
	                case 'P-384':
	                case 'P-521':
	                    return generate$1('ec', { namedCurve: crv });
	                case 'X25519':
	                    return generate$1('x25519');
	                case 'X448':
	                    return generate$1('x448');
	                default:
	                    throw new errors_js_1.JOSENotSupported('Invalid or unsupported crv option provided, supported values are P-256, P-384, P-521, X25519, and X448');
	            }
	        default:
	            throw new errors_js_1.JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
	    }
	}
	generate.generateKeyPair = generateKeyPair;
	return generate;
}

var hasRequiredGenerate_key_pair;

function requireGenerate_key_pair () {
	if (hasRequiredGenerate_key_pair) return generate_key_pair;
	hasRequiredGenerate_key_pair = 1;
	Object.defineProperty(generate_key_pair, "__esModule", { value: true });
	generate_key_pair.generateKeyPair = void 0;
	const generate_js_1 = /*@__PURE__*/ requireGenerate();
	async function generateKeyPair(alg, options) {
	    return (0, generate_js_1.generateKeyPair)(alg, options);
	}
	generate_key_pair.generateKeyPair = generateKeyPair;
	return generate_key_pair;
}

var generate_secret = {};

var hasRequiredGenerate_secret;

function requireGenerate_secret () {
	if (hasRequiredGenerate_secret) return generate_secret;
	hasRequiredGenerate_secret = 1;
	Object.defineProperty(generate_secret, "__esModule", { value: true });
	generate_secret.generateSecret = void 0;
	const generate_js_1 = /*@__PURE__*/ requireGenerate();
	async function generateSecret(alg, options) {
	    return (0, generate_js_1.generateSecret)(alg, options);
	}
	generate_secret.generateSecret = generateSecret;
	return generate_secret;
}

var runtime$1 = {};

var runtime = {};

var hasRequiredRuntime$1;

function requireRuntime$1 () {
	if (hasRequiredRuntime$1) return runtime;
	hasRequiredRuntime$1 = 1;
	Object.defineProperty(runtime, "__esModule", { value: true });
	runtime.default = 'node:crypto';
	return runtime;
}

var hasRequiredRuntime;

function requireRuntime () {
	if (hasRequiredRuntime) return runtime$1;
	hasRequiredRuntime = 1;
	Object.defineProperty(runtime$1, "__esModule", { value: true });
	const runtime_js_1 = /*@__PURE__*/ requireRuntime$1();
	runtime$1.default = runtime_js_1.default;
	return runtime$1;
}

var hasRequiredCjs;

function requireCjs () {
	if (hasRequiredCjs) return cjs;
	hasRequiredCjs = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.cryptoRuntime = exports.base64url = exports.generateSecret = exports.generateKeyPair = exports.errors = exports.decodeJwt = exports.decodeProtectedHeader = exports.importJWK = exports.importX509 = exports.importPKCS8 = exports.importSPKI = exports.exportJWK = exports.exportSPKI = exports.exportPKCS8 = exports.UnsecuredJWT = exports.createRemoteJWKSet = exports.createLocalJWKSet = exports.EmbeddedJWK = exports.calculateJwkThumbprintUri = exports.calculateJwkThumbprint = exports.EncryptJWT = exports.SignJWT = exports.GeneralSign = exports.FlattenedSign = exports.CompactSign = exports.FlattenedEncrypt = exports.CompactEncrypt = exports.jwtDecrypt = exports.jwtVerify = exports.generalVerify = exports.flattenedVerify = exports.compactVerify = exports.GeneralEncrypt = exports.generalDecrypt = exports.flattenedDecrypt = exports.compactDecrypt = void 0;
		var decrypt_js_1 = /*@__PURE__*/ requireDecrypt$2();
		Object.defineProperty(exports, "compactDecrypt", { enumerable: true, get: function () { return decrypt_js_1.compactDecrypt; } });
		var decrypt_js_2 = /*@__PURE__*/ requireDecrypt$3();
		Object.defineProperty(exports, "flattenedDecrypt", { enumerable: true, get: function () { return decrypt_js_2.flattenedDecrypt; } });
		var decrypt_js_3 = /*@__PURE__*/ requireDecrypt$1();
		Object.defineProperty(exports, "generalDecrypt", { enumerable: true, get: function () { return decrypt_js_3.generalDecrypt; } });
		var encrypt_js_1 = /*@__PURE__*/ requireEncrypt$2();
		Object.defineProperty(exports, "GeneralEncrypt", { enumerable: true, get: function () { return encrypt_js_1.GeneralEncrypt; } });
		var verify_js_1 = /*@__PURE__*/ requireVerify$2();
		Object.defineProperty(exports, "compactVerify", { enumerable: true, get: function () { return verify_js_1.compactVerify; } });
		var verify_js_2 = /*@__PURE__*/ requireVerify$3();
		Object.defineProperty(exports, "flattenedVerify", { enumerable: true, get: function () { return verify_js_2.flattenedVerify; } });
		var verify_js_3 = /*@__PURE__*/ requireVerify$1();
		Object.defineProperty(exports, "generalVerify", { enumerable: true, get: function () { return verify_js_3.generalVerify; } });
		var verify_js_4 = /*@__PURE__*/ requireVerify();
		Object.defineProperty(exports, "jwtVerify", { enumerable: true, get: function () { return verify_js_4.jwtVerify; } });
		var decrypt_js_4 = /*@__PURE__*/ requireDecrypt();
		Object.defineProperty(exports, "jwtDecrypt", { enumerable: true, get: function () { return decrypt_js_4.jwtDecrypt; } });
		var encrypt_js_2 = /*@__PURE__*/ requireEncrypt$1();
		Object.defineProperty(exports, "CompactEncrypt", { enumerable: true, get: function () { return encrypt_js_2.CompactEncrypt; } });
		var encrypt_js_3 = /*@__PURE__*/ requireEncrypt$3();
		Object.defineProperty(exports, "FlattenedEncrypt", { enumerable: true, get: function () { return encrypt_js_3.FlattenedEncrypt; } });
		var sign_js_1 = /*@__PURE__*/ requireSign$2();
		Object.defineProperty(exports, "CompactSign", { enumerable: true, get: function () { return sign_js_1.CompactSign; } });
		var sign_js_2 = /*@__PURE__*/ requireSign$3();
		Object.defineProperty(exports, "FlattenedSign", { enumerable: true, get: function () { return sign_js_2.FlattenedSign; } });
		var sign_js_3 = /*@__PURE__*/ requireSign$1();
		Object.defineProperty(exports, "GeneralSign", { enumerable: true, get: function () { return sign_js_3.GeneralSign; } });
		var sign_js_4 = /*@__PURE__*/ requireSign();
		Object.defineProperty(exports, "SignJWT", { enumerable: true, get: function () { return sign_js_4.SignJWT; } });
		var encrypt_js_4 = /*@__PURE__*/ requireEncrypt();
		Object.defineProperty(exports, "EncryptJWT", { enumerable: true, get: function () { return encrypt_js_4.EncryptJWT; } });
		var thumbprint_js_1 = /*@__PURE__*/ requireThumbprint();
		Object.defineProperty(exports, "calculateJwkThumbprint", { enumerable: true, get: function () { return thumbprint_js_1.calculateJwkThumbprint; } });
		Object.defineProperty(exports, "calculateJwkThumbprintUri", { enumerable: true, get: function () { return thumbprint_js_1.calculateJwkThumbprintUri; } });
		var embedded_js_1 = /*@__PURE__*/ requireEmbedded();
		Object.defineProperty(exports, "EmbeddedJWK", { enumerable: true, get: function () { return embedded_js_1.EmbeddedJWK; } });
		var local_js_1 = /*@__PURE__*/ requireLocal();
		Object.defineProperty(exports, "createLocalJWKSet", { enumerable: true, get: function () { return local_js_1.createLocalJWKSet; } });
		var remote_js_1 = /*@__PURE__*/ requireRemote();
		Object.defineProperty(exports, "createRemoteJWKSet", { enumerable: true, get: function () { return remote_js_1.createRemoteJWKSet; } });
		var unsecured_js_1 = /*@__PURE__*/ requireUnsecured();
		Object.defineProperty(exports, "UnsecuredJWT", { enumerable: true, get: function () { return unsecured_js_1.UnsecuredJWT; } });
		var export_js_1 = /*@__PURE__*/ require_export();
		Object.defineProperty(exports, "exportPKCS8", { enumerable: true, get: function () { return export_js_1.exportPKCS8; } });
		Object.defineProperty(exports, "exportSPKI", { enumerable: true, get: function () { return export_js_1.exportSPKI; } });
		Object.defineProperty(exports, "exportJWK", { enumerable: true, get: function () { return export_js_1.exportJWK; } });
		var import_js_1 = /*@__PURE__*/ require_import();
		Object.defineProperty(exports, "importSPKI", { enumerable: true, get: function () { return import_js_1.importSPKI; } });
		Object.defineProperty(exports, "importPKCS8", { enumerable: true, get: function () { return import_js_1.importPKCS8; } });
		Object.defineProperty(exports, "importX509", { enumerable: true, get: function () { return import_js_1.importX509; } });
		Object.defineProperty(exports, "importJWK", { enumerable: true, get: function () { return import_js_1.importJWK; } });
		var decode_protected_header_js_1 = /*@__PURE__*/ requireDecode_protected_header();
		Object.defineProperty(exports, "decodeProtectedHeader", { enumerable: true, get: function () { return decode_protected_header_js_1.decodeProtectedHeader; } });
		var decode_jwt_js_1 = /*@__PURE__*/ requireDecode_jwt$1();
		Object.defineProperty(exports, "decodeJwt", { enumerable: true, get: function () { return decode_jwt_js_1.decodeJwt; } });
		exports.errors = /*@__PURE__*/ requireErrors();
		var generate_key_pair_js_1 = /*@__PURE__*/ requireGenerate_key_pair();
		Object.defineProperty(exports, "generateKeyPair", { enumerable: true, get: function () { return generate_key_pair_js_1.generateKeyPair; } });
		var generate_secret_js_1 = /*@__PURE__*/ requireGenerate_secret();
		Object.defineProperty(exports, "generateSecret", { enumerable: true, get: function () { return generate_secret_js_1.generateSecret; } });
		exports.base64url = /*@__PURE__*/ requireBase64url$1();
		var runtime_js_1 = /*@__PURE__*/ requireRuntime();
		Object.defineProperty(exports, "cryptoRuntime", { enumerable: true, get: function () { return runtime_js_1.default; } }); 
	} (cjs));
	return cjs;
}

var shake256_1;
var hasRequiredShake256;

function requireShake256 () {
	if (hasRequiredShake256) return shake256_1;
	hasRequiredShake256 = 1;
	const crypto = require$$0$9;

	const [major, minor] = process.version.substring(1).split('.').map((x) => parseInt(x, 10));
	const xofOutputLength = major > 12 || (major === 12 && minor >= 8);
	const shake256 = xofOutputLength && crypto.getHashes().includes('shake256');

	shake256_1 = shake256;
	return shake256_1;
}

var lib$1;
var hasRequiredLib$1;

function requireLib$1 () {
	if (hasRequiredLib$1) return lib$1;
	hasRequiredLib$1 = 1;
	const { strict: assert } = require$$0$5;
	const { createHash } = require$$0$9;
	const { format } = require$$1;

	const shake256 = requireShake256();

	let encode;
	if (Buffer.isEncoding('base64url')) {
	  encode = (input) => input.toString('base64url');
	} else {
	  const fromBase64 = (base64) => base64.replace(/=/g, '').replace(/\+/g, '-').replace(/\//g, '_');
	  encode = (input) => fromBase64(input.toString('base64'));
	}

	/** SPECIFICATION
	 * Its (_hash) value is the base64url encoding of the left-most half of the hash of the octets of
	 * the ASCII representation of the token value, where the hash algorithm used is the hash algorithm
	 * used in the alg Header Parameter of the ID Token's JOSE Header. For instance, if the alg is
	 * RS256, hash the token value with SHA-256, then take the left-most 128 bits and base64url encode
	 * them. The _hash value is a case sensitive string.
	 */

	/**
	 * @name getHash
	 * @api private
	 *
	 * returns the sha length based off the JOSE alg heade value, defaults to sha256
	 *
	 * @param token {String} token value to generate the hash from
	 * @param alg {String} ID Token JOSE header alg value (i.e. RS256, HS384, ES512, PS256)
	 * @param [crv] {String} For EdDSA the curve decides what hash algorithm is used. Required for EdDSA
	 */
	function getHash(alg, crv) {
	  switch (alg) {
	    case 'HS256':
	    case 'RS256':
	    case 'PS256':
	    case 'ES256':
	    case 'ES256K':
	      return createHash('sha256');

	    case 'HS384':
	    case 'RS384':
	    case 'PS384':
	    case 'ES384':
	      return createHash('sha384');

	    case 'HS512':
	    case 'RS512':
	    case 'PS512':
	    case 'ES512':
	      return createHash('sha512');

	    case 'EdDSA':
	      switch (crv) {
	        case 'Ed25519':
	          return createHash('sha512');
	        case 'Ed448':
	          if (!shake256) {
	            throw new TypeError('Ed448 *_hash calculation is not supported in your Node.js runtime version');
	          }

	          return createHash('shake256', { outputLength: 114 });
	        default:
	          throw new TypeError('unrecognized or invalid EdDSA curve provided');
	      }

	    default:
	      throw new TypeError('unrecognized or invalid JWS algorithm provided');
	  }
	}

	function generate(token, alg, crv) {
	  const digest = getHash(alg, crv).update(token).digest();
	  return encode(digest.slice(0, digest.length / 2));
	}

	function validate(names, actual, source, alg, crv) {
	  if (typeof names.claim !== 'string' || !names.claim) {
	    throw new TypeError('names.claim must be a non-empty string');
	  }

	  if (typeof names.source !== 'string' || !names.source) {
	    throw new TypeError('names.source must be a non-empty string');
	  }

	  assert(typeof actual === 'string' && actual, `${names.claim} must be a non-empty string`);
	  assert(typeof source === 'string' && source, `${names.source} must be a non-empty string`);

	  let expected;
	  let msg;
	  try {
	    expected = generate(source, alg, crv);
	  } catch (err) {
	    msg = format('%s could not be validated (%s)', names.claim, err.message);
	  }

	  msg = msg || format('%s mismatch, expected %s, got: %s', names.claim, expected, actual);

	  assert.equal(expected, actual, msg);
	}

	lib$1 = {
	  validate,
	  generate,
	};
	return lib$1;
}

var is_key_object;
var hasRequiredIs_key_object;

function requireIs_key_object () {
	if (hasRequiredIs_key_object) return is_key_object;
	hasRequiredIs_key_object = 1;
	const util = require$$1;
	const crypto = require$$0$9;

	is_key_object = util.types.isKeyObject || ((obj) => obj && obj instanceof crypto.KeyObject);
	return is_key_object;
}

var base64url = {};

var hasRequiredBase64url;

function requireBase64url () {
	if (hasRequiredBase64url) return base64url;
	hasRequiredBase64url = 1;
	let encode;
	if (Buffer.isEncoding('base64url')) {
	  encode = (input, encoding = 'utf8') => Buffer.from(input, encoding).toString('base64url');
	} else {
	  const fromBase64 = (base64) => base64.replace(/=/g, '').replace(/\+/g, '-').replace(/\//g, '_');
	  encode = (input, encoding = 'utf8') =>
	    fromBase64(Buffer.from(input, encoding).toString('base64'));
	}

	const decode = (input) => Buffer.from(input, 'base64');

	base64url.decode = decode;
	base64url.encode = encode;
	return base64url;
}

var decode_jwt;
var hasRequiredDecode_jwt;

function requireDecode_jwt () {
	if (hasRequiredDecode_jwt) return decode_jwt;
	hasRequiredDecode_jwt = 1;
	const base64url = requireBase64url();

	decode_jwt = (token) => {
	  if (typeof token !== 'string' || !token) {
	    throw new TypeError('JWT must be a string');
	  }

	  const { 0: header, 1: payload, 2: signature, length } = token.split('.');

	  if (length === 5) {
	    throw new TypeError('encrypted JWTs cannot be decoded');
	  }

	  if (length !== 3) {
	    throw new Error('JWTs must have three components');
	  }

	  try {
	    return {
	      header: JSON.parse(base64url.decode(header)),
	      payload: JSON.parse(base64url.decode(payload)),
	      signature,
	    };
	  } catch (err) {
	    throw new Error('JWT is malformed');
	  }
	};
	return decode_jwt;
}

var defaults = {exports: {}};

var is_plain_object;
var hasRequiredIs_plain_object;

function requireIs_plain_object () {
	if (hasRequiredIs_plain_object) return is_plain_object;
	hasRequiredIs_plain_object = 1;
	is_plain_object = (a) => !!a && a.constructor === Object;
	return is_plain_object;
}

var hasRequiredDefaults;

function requireDefaults () {
	if (hasRequiredDefaults) return defaults.exports;
	hasRequiredDefaults = 1;
	const isPlainObject = requireIs_plain_object();

	function defaults$1(deep, target, ...sources) {
	  for (const source of sources) {
	    if (!isPlainObject(source)) {
	      continue;
	    }
	    for (const [key, value] of Object.entries(source)) {
	      /* istanbul ignore if */
	      if (key === '__proto__' || key === 'constructor') {
	        continue;
	      }
	      if (typeof target[key] === 'undefined' && typeof value !== 'undefined') {
	        target[key] = value;
	      }

	      if (deep && isPlainObject(target[key]) && isPlainObject(value)) {
	        defaults$1(true, target[key], value);
	      }
	    }
	  }

	  return target;
	}

	defaults.exports = defaults$1.bind(undefined, false);
	defaults.exports.deep = defaults$1.bind(undefined, true);
	return defaults.exports;
}

var www_authenticate_parser;
var hasRequiredWww_authenticate_parser;

function requireWww_authenticate_parser () {
	if (hasRequiredWww_authenticate_parser) return www_authenticate_parser;
	hasRequiredWww_authenticate_parser = 1;
	const REGEXP = /(\w+)=("[^"]*")/g;

	www_authenticate_parser = (wwwAuthenticate) => {
	  const params = {};
	  try {
	    while (REGEXP.exec(wwwAuthenticate) !== null) {
	      if (RegExp.$1 && RegExp.$2) {
	        params[RegExp.$1] = RegExp.$2.slice(1, -1);
	      }
	    }
	  } catch (err) {}

	  return params;
	};
	return www_authenticate_parser;
}

var assert;
var hasRequiredAssert;

function requireAssert () {
	if (hasRequiredAssert) return assert;
	hasRequiredAssert = 1;
	function assertSigningAlgValuesSupport(endpoint, issuer, properties) {
	  if (!issuer[`${endpoint}_endpoint`]) return;

	  const eam = `${endpoint}_endpoint_auth_method`;
	  const easa = `${endpoint}_endpoint_auth_signing_alg`;
	  const easavs = `${endpoint}_endpoint_auth_signing_alg_values_supported`;

	  if (properties[eam] && properties[eam].endsWith('_jwt') && !properties[easa] && !issuer[easavs]) {
	    throw new TypeError(
	      `${easavs} must be configured on the issuer if ${easa} is not defined on a client`,
	    );
	  }
	}

	function assertIssuerConfiguration(issuer, endpoint) {
	  if (!issuer[endpoint]) {
	    throw new TypeError(`${endpoint} must be configured on the issuer`);
	  }
	}

	assert = {
	  assertSigningAlgValuesSupport,
	  assertIssuerConfiguration,
	};
	return assert;
}

var pick;
var hasRequiredPick;

function requirePick () {
	if (hasRequiredPick) return pick;
	hasRequiredPick = 1;
	pick = function pick(object, ...paths) {
	  const obj = {};
	  for (const path of paths) {
	    if (object[path] !== undefined) {
	      obj[path] = object[path];
	    }
	  }
	  return obj;
	};
	return pick;
}

var process_response;
var hasRequiredProcess_response;

function requireProcess_response () {
	if (hasRequiredProcess_response) return process_response;
	hasRequiredProcess_response = 1;
	const { STATUS_CODES } = require$$0$2;
	const { format } = require$$1;

	const { OPError } = requireErrors$1();
	const parseWwwAuthenticate = requireWww_authenticate_parser();

	const throwAuthenticateErrors = (response) => {
	  const params = parseWwwAuthenticate(response.headers['www-authenticate']);

	  if (params.error) {
	    throw new OPError(params, response);
	  }
	};

	const isStandardBodyError = (response) => {
	  let result = false;
	  try {
	    let jsonbody;
	    if (typeof response.body !== 'object' || Buffer.isBuffer(response.body)) {
	      jsonbody = JSON.parse(response.body);
	    } else {
	      jsonbody = response.body;
	    }
	    result = typeof jsonbody.error === 'string' && jsonbody.error.length;
	    if (result) Object.defineProperty(response, 'body', { value: jsonbody, configurable: true });
	  } catch (err) {}

	  return result;
	};

	function processResponse(response, { statusCode = 200, body = true, bearer = false } = {}) {
	  if (response.statusCode !== statusCode) {
	    if (bearer) {
	      throwAuthenticateErrors(response);
	    }

	    if (isStandardBodyError(response)) {
	      throw new OPError(response.body, response);
	    }

	    throw new OPError(
	      {
	        error: format(
	          'expected %i %s, got: %i %s',
	          statusCode,
	          STATUS_CODES[statusCode],
	          response.statusCode,
	          STATUS_CODES[response.statusCode],
	        ),
	      },
	      response,
	    );
	  }

	  if (body && !response.body) {
	    throw new OPError(
	      {
	        error: format(
	          'expected %i %s with body but no body was returned',
	          statusCode,
	          STATUS_CODES[statusCode],
	        ),
	      },
	      response,
	    );
	  }

	  return response.body;
	}

	process_response = processResponse;
	return process_response;
}

var unix_timestamp;
var hasRequiredUnix_timestamp;

function requireUnix_timestamp () {
	if (hasRequiredUnix_timestamp) return unix_timestamp;
	hasRequiredUnix_timestamp = 1;
	unix_timestamp = () => Math.floor(Date.now() / 1000);
	return unix_timestamp;
}

var token_set;
var hasRequiredToken_set;

function requireToken_set () {
	if (hasRequiredToken_set) return token_set;
	hasRequiredToken_set = 1;
	const base64url = requireBase64url();
	const now = requireUnix_timestamp();

	class TokenSet {
	  constructor(values) {
	    Object.assign(this, values);
	    const { constructor, ...properties } = Object.getOwnPropertyDescriptors(
	      this.constructor.prototype,
	    );

	    Object.defineProperties(this, properties);
	  }

	  set expires_in(value) {
	    this.expires_at = now() + Number(value);
	  }

	  get expires_in() {
	    return Math.max.apply(null, [this.expires_at - now(), 0]);
	  }

	  expired() {
	    return this.expires_in === 0;
	  }

	  claims() {
	    if (!this.id_token) {
	      throw new TypeError('id_token not present in TokenSet');
	    }

	    return JSON.parse(base64url.decode(this.id_token.split('.')[1]));
	  }
	}

	token_set = TokenSet;
	return token_set;
}

var generators$1;
var hasRequiredGenerators;

function requireGenerators () {
	if (hasRequiredGenerators) return generators$1;
	hasRequiredGenerators = 1;
	const { createHash, randomBytes } = require$$0$9;

	const base64url = requireBase64url();

	const random = (bytes = 32) => base64url.encode(randomBytes(bytes));

	generators$1 = {
	  random,
	  state: random,
	  nonce: random,
	  codeVerifier: random,
	  codeChallenge: (codeVerifier) =>
	    base64url.encode(createHash('sha256').update(codeVerifier).digest()),
	};
	return generators$1;
}

var request = {exports: {}};

var iterator;
var hasRequiredIterator;

function requireIterator () {
	if (hasRequiredIterator) return iterator;
	hasRequiredIterator = 1;
	iterator = function (Yallist) {
	  Yallist.prototype[Symbol.iterator] = function* () {
	    for (let walker = this.head; walker; walker = walker.next) {
	      yield walker.value;
	    }
	  };
	};
	return iterator;
}

var yallist;
var hasRequiredYallist;

function requireYallist () {
	if (hasRequiredYallist) return yallist;
	hasRequiredYallist = 1;
	yallist = Yallist;

	Yallist.Node = Node;
	Yallist.create = Yallist;

	function Yallist (list) {
	  var self = this;
	  if (!(self instanceof Yallist)) {
	    self = new Yallist();
	  }

	  self.tail = null;
	  self.head = null;
	  self.length = 0;

	  if (list && typeof list.forEach === 'function') {
	    list.forEach(function (item) {
	      self.push(item);
	    });
	  } else if (arguments.length > 0) {
	    for (var i = 0, l = arguments.length; i < l; i++) {
	      self.push(arguments[i]);
	    }
	  }

	  return self
	}

	Yallist.prototype.removeNode = function (node) {
	  if (node.list !== this) {
	    throw new Error('removing node which does not belong to this list')
	  }

	  var next = node.next;
	  var prev = node.prev;

	  if (next) {
	    next.prev = prev;
	  }

	  if (prev) {
	    prev.next = next;
	  }

	  if (node === this.head) {
	    this.head = next;
	  }
	  if (node === this.tail) {
	    this.tail = prev;
	  }

	  node.list.length--;
	  node.next = null;
	  node.prev = null;
	  node.list = null;

	  return next
	};

	Yallist.prototype.unshiftNode = function (node) {
	  if (node === this.head) {
	    return
	  }

	  if (node.list) {
	    node.list.removeNode(node);
	  }

	  var head = this.head;
	  node.list = this;
	  node.next = head;
	  if (head) {
	    head.prev = node;
	  }

	  this.head = node;
	  if (!this.tail) {
	    this.tail = node;
	  }
	  this.length++;
	};

	Yallist.prototype.pushNode = function (node) {
	  if (node === this.tail) {
	    return
	  }

	  if (node.list) {
	    node.list.removeNode(node);
	  }

	  var tail = this.tail;
	  node.list = this;
	  node.prev = tail;
	  if (tail) {
	    tail.next = node;
	  }

	  this.tail = node;
	  if (!this.head) {
	    this.head = node;
	  }
	  this.length++;
	};

	Yallist.prototype.push = function () {
	  for (var i = 0, l = arguments.length; i < l; i++) {
	    push(this, arguments[i]);
	  }
	  return this.length
	};

	Yallist.prototype.unshift = function () {
	  for (var i = 0, l = arguments.length; i < l; i++) {
	    unshift(this, arguments[i]);
	  }
	  return this.length
	};

	Yallist.prototype.pop = function () {
	  if (!this.tail) {
	    return undefined
	  }

	  var res = this.tail.value;
	  this.tail = this.tail.prev;
	  if (this.tail) {
	    this.tail.next = null;
	  } else {
	    this.head = null;
	  }
	  this.length--;
	  return res
	};

	Yallist.prototype.shift = function () {
	  if (!this.head) {
	    return undefined
	  }

	  var res = this.head.value;
	  this.head = this.head.next;
	  if (this.head) {
	    this.head.prev = null;
	  } else {
	    this.tail = null;
	  }
	  this.length--;
	  return res
	};

	Yallist.prototype.forEach = function (fn, thisp) {
	  thisp = thisp || this;
	  for (var walker = this.head, i = 0; walker !== null; i++) {
	    fn.call(thisp, walker.value, i, this);
	    walker = walker.next;
	  }
	};

	Yallist.prototype.forEachReverse = function (fn, thisp) {
	  thisp = thisp || this;
	  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
	    fn.call(thisp, walker.value, i, this);
	    walker = walker.prev;
	  }
	};

	Yallist.prototype.get = function (n) {
	  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
	    // abort out of the list early if we hit a cycle
	    walker = walker.next;
	  }
	  if (i === n && walker !== null) {
	    return walker.value
	  }
	};

	Yallist.prototype.getReverse = function (n) {
	  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
	    // abort out of the list early if we hit a cycle
	    walker = walker.prev;
	  }
	  if (i === n && walker !== null) {
	    return walker.value
	  }
	};

	Yallist.prototype.map = function (fn, thisp) {
	  thisp = thisp || this;
	  var res = new Yallist();
	  for (var walker = this.head; walker !== null;) {
	    res.push(fn.call(thisp, walker.value, this));
	    walker = walker.next;
	  }
	  return res
	};

	Yallist.prototype.mapReverse = function (fn, thisp) {
	  thisp = thisp || this;
	  var res = new Yallist();
	  for (var walker = this.tail; walker !== null;) {
	    res.push(fn.call(thisp, walker.value, this));
	    walker = walker.prev;
	  }
	  return res
	};

	Yallist.prototype.reduce = function (fn, initial) {
	  var acc;
	  var walker = this.head;
	  if (arguments.length > 1) {
	    acc = initial;
	  } else if (this.head) {
	    walker = this.head.next;
	    acc = this.head.value;
	  } else {
	    throw new TypeError('Reduce of empty list with no initial value')
	  }

	  for (var i = 0; walker !== null; i++) {
	    acc = fn(acc, walker.value, i);
	    walker = walker.next;
	  }

	  return acc
	};

	Yallist.prototype.reduceReverse = function (fn, initial) {
	  var acc;
	  var walker = this.tail;
	  if (arguments.length > 1) {
	    acc = initial;
	  } else if (this.tail) {
	    walker = this.tail.prev;
	    acc = this.tail.value;
	  } else {
	    throw new TypeError('Reduce of empty list with no initial value')
	  }

	  for (var i = this.length - 1; walker !== null; i--) {
	    acc = fn(acc, walker.value, i);
	    walker = walker.prev;
	  }

	  return acc
	};

	Yallist.prototype.toArray = function () {
	  var arr = new Array(this.length);
	  for (var i = 0, walker = this.head; walker !== null; i++) {
	    arr[i] = walker.value;
	    walker = walker.next;
	  }
	  return arr
	};

	Yallist.prototype.toArrayReverse = function () {
	  var arr = new Array(this.length);
	  for (var i = 0, walker = this.tail; walker !== null; i++) {
	    arr[i] = walker.value;
	    walker = walker.prev;
	  }
	  return arr
	};

	Yallist.prototype.slice = function (from, to) {
	  to = to || this.length;
	  if (to < 0) {
	    to += this.length;
	  }
	  from = from || 0;
	  if (from < 0) {
	    from += this.length;
	  }
	  var ret = new Yallist();
	  if (to < from || to < 0) {
	    return ret
	  }
	  if (from < 0) {
	    from = 0;
	  }
	  if (to > this.length) {
	    to = this.length;
	  }
	  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
	    walker = walker.next;
	  }
	  for (; walker !== null && i < to; i++, walker = walker.next) {
	    ret.push(walker.value);
	  }
	  return ret
	};

	Yallist.prototype.sliceReverse = function (from, to) {
	  to = to || this.length;
	  if (to < 0) {
	    to += this.length;
	  }
	  from = from || 0;
	  if (from < 0) {
	    from += this.length;
	  }
	  var ret = new Yallist();
	  if (to < from || to < 0) {
	    return ret
	  }
	  if (from < 0) {
	    from = 0;
	  }
	  if (to > this.length) {
	    to = this.length;
	  }
	  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
	    walker = walker.prev;
	  }
	  for (; walker !== null && i > from; i--, walker = walker.prev) {
	    ret.push(walker.value);
	  }
	  return ret
	};

	Yallist.prototype.splice = function (start, deleteCount, ...nodes) {
	  if (start > this.length) {
	    start = this.length - 1;
	  }
	  if (start < 0) {
	    start = this.length + start;
	  }

	  for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
	    walker = walker.next;
	  }

	  var ret = [];
	  for (var i = 0; walker && i < deleteCount; i++) {
	    ret.push(walker.value);
	    walker = this.removeNode(walker);
	  }
	  if (walker === null) {
	    walker = this.tail;
	  }

	  if (walker !== this.head && walker !== this.tail) {
	    walker = walker.prev;
	  }

	  for (var i = 0; i < nodes.length; i++) {
	    walker = insert(this, walker, nodes[i]);
	  }
	  return ret;
	};

	Yallist.prototype.reverse = function () {
	  var head = this.head;
	  var tail = this.tail;
	  for (var walker = head; walker !== null; walker = walker.prev) {
	    var p = walker.prev;
	    walker.prev = walker.next;
	    walker.next = p;
	  }
	  this.head = tail;
	  this.tail = head;
	  return this
	};

	function insert (self, node, value) {
	  var inserted = node === self.head ?
	    new Node(value, null, node, self) :
	    new Node(value, node, node.next, self);

	  if (inserted.next === null) {
	    self.tail = inserted;
	  }
	  if (inserted.prev === null) {
	    self.head = inserted;
	  }

	  self.length++;

	  return inserted
	}

	function push (self, item) {
	  self.tail = new Node(item, self.tail, null, self);
	  if (!self.head) {
	    self.head = self.tail;
	  }
	  self.length++;
	}

	function unshift (self, item) {
	  self.head = new Node(item, null, self.head, self);
	  if (!self.tail) {
	    self.tail = self.head;
	  }
	  self.length++;
	}

	function Node (value, prev, next, list) {
	  if (!(this instanceof Node)) {
	    return new Node(value, prev, next, list)
	  }

	  this.list = list;
	  this.value = value;

	  if (prev) {
	    prev.next = this;
	    this.prev = prev;
	  } else {
	    this.prev = null;
	  }

	  if (next) {
	    next.prev = this;
	    this.next = next;
	  } else {
	    this.next = null;
	  }
	}

	try {
	  // add if support for Symbol.iterator is present
	  requireIterator()(Yallist);
	} catch (er) {}
	return yallist;
}

var lruCache;
var hasRequiredLruCache;

function requireLruCache () {
	if (hasRequiredLruCache) return lruCache;
	hasRequiredLruCache = 1;

	// A linked list to keep track of recently-used-ness
	const Yallist = requireYallist();

	const MAX = Symbol('max');
	const LENGTH = Symbol('length');
	const LENGTH_CALCULATOR = Symbol('lengthCalculator');
	const ALLOW_STALE = Symbol('allowStale');
	const MAX_AGE = Symbol('maxAge');
	const DISPOSE = Symbol('dispose');
	const NO_DISPOSE_ON_SET = Symbol('noDisposeOnSet');
	const LRU_LIST = Symbol('lruList');
	const CACHE = Symbol('cache');
	const UPDATE_AGE_ON_GET = Symbol('updateAgeOnGet');

	const naiveLength = () => 1;

	// lruList is a yallist where the head is the youngest
	// item, and the tail is the oldest.  the list contains the Hit
	// objects as the entries.
	// Each Hit object has a reference to its Yallist.Node.  This
	// never changes.
	//
	// cache is a Map (or PseudoMap) that matches the keys to
	// the Yallist.Node object.
	class LRUCache {
	  constructor (options) {
	    if (typeof options === 'number')
	      options = { max: options };

	    if (!options)
	      options = {};

	    if (options.max && (typeof options.max !== 'number' || options.max < 0))
	      throw new TypeError('max must be a non-negative number')
	    // Kind of weird to have a default max of Infinity, but oh well.
	    this[MAX] = options.max || Infinity;

	    const lc = options.length || naiveLength;
	    this[LENGTH_CALCULATOR] = (typeof lc !== 'function') ? naiveLength : lc;
	    this[ALLOW_STALE] = options.stale || false;
	    if (options.maxAge && typeof options.maxAge !== 'number')
	      throw new TypeError('maxAge must be a number')
	    this[MAX_AGE] = options.maxAge || 0;
	    this[DISPOSE] = options.dispose;
	    this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
	    this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
	    this.reset();
	  }

	  // resize the cache when the max changes.
	  set max (mL) {
	    if (typeof mL !== 'number' || mL < 0)
	      throw new TypeError('max must be a non-negative number')

	    this[MAX] = mL || Infinity;
	    trim(this);
	  }
	  get max () {
	    return this[MAX]
	  }

	  set allowStale (allowStale) {
	    this[ALLOW_STALE] = !!allowStale;
	  }
	  get allowStale () {
	    return this[ALLOW_STALE]
	  }

	  set maxAge (mA) {
	    if (typeof mA !== 'number')
	      throw new TypeError('maxAge must be a non-negative number')

	    this[MAX_AGE] = mA;
	    trim(this);
	  }
	  get maxAge () {
	    return this[MAX_AGE]
	  }

	  // resize the cache when the lengthCalculator changes.
	  set lengthCalculator (lC) {
	    if (typeof lC !== 'function')
	      lC = naiveLength;

	    if (lC !== this[LENGTH_CALCULATOR]) {
	      this[LENGTH_CALCULATOR] = lC;
	      this[LENGTH] = 0;
	      this[LRU_LIST].forEach(hit => {
	        hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
	        this[LENGTH] += hit.length;
	      });
	    }
	    trim(this);
	  }
	  get lengthCalculator () { return this[LENGTH_CALCULATOR] }

	  get length () { return this[LENGTH] }
	  get itemCount () { return this[LRU_LIST].length }

	  rforEach (fn, thisp) {
	    thisp = thisp || this;
	    for (let walker = this[LRU_LIST].tail; walker !== null;) {
	      const prev = walker.prev;
	      forEachStep(this, fn, walker, thisp);
	      walker = prev;
	    }
	  }

	  forEach (fn, thisp) {
	    thisp = thisp || this;
	    for (let walker = this[LRU_LIST].head; walker !== null;) {
	      const next = walker.next;
	      forEachStep(this, fn, walker, thisp);
	      walker = next;
	    }
	  }

	  keys () {
	    return this[LRU_LIST].toArray().map(k => k.key)
	  }

	  values () {
	    return this[LRU_LIST].toArray().map(k => k.value)
	  }

	  reset () {
	    if (this[DISPOSE] &&
	        this[LRU_LIST] &&
	        this[LRU_LIST].length) {
	      this[LRU_LIST].forEach(hit => this[DISPOSE](hit.key, hit.value));
	    }

	    this[CACHE] = new Map(); // hash of items by key
	    this[LRU_LIST] = new Yallist(); // list of items in order of use recency
	    this[LENGTH] = 0; // length of items in the list
	  }

	  dump () {
	    return this[LRU_LIST].map(hit =>
	      isStale(this, hit) ? false : {
	        k: hit.key,
	        v: hit.value,
	        e: hit.now + (hit.maxAge || 0)
	      }).toArray().filter(h => h)
	  }

	  dumpLru () {
	    return this[LRU_LIST]
	  }

	  set (key, value, maxAge) {
	    maxAge = maxAge || this[MAX_AGE];

	    if (maxAge && typeof maxAge !== 'number')
	      throw new TypeError('maxAge must be a number')

	    const now = maxAge ? Date.now() : 0;
	    const len = this[LENGTH_CALCULATOR](value, key);

	    if (this[CACHE].has(key)) {
	      if (len > this[MAX]) {
	        del(this, this[CACHE].get(key));
	        return false
	      }

	      const node = this[CACHE].get(key);
	      const item = node.value;

	      // dispose of the old one before overwriting
	      // split out into 2 ifs for better coverage tracking
	      if (this[DISPOSE]) {
	        if (!this[NO_DISPOSE_ON_SET])
	          this[DISPOSE](key, item.value);
	      }

	      item.now = now;
	      item.maxAge = maxAge;
	      item.value = value;
	      this[LENGTH] += len - item.length;
	      item.length = len;
	      this.get(key);
	      trim(this);
	      return true
	    }

	    const hit = new Entry(key, value, len, now, maxAge);

	    // oversized objects fall out of cache automatically.
	    if (hit.length > this[MAX]) {
	      if (this[DISPOSE])
	        this[DISPOSE](key, value);

	      return false
	    }

	    this[LENGTH] += hit.length;
	    this[LRU_LIST].unshift(hit);
	    this[CACHE].set(key, this[LRU_LIST].head);
	    trim(this);
	    return true
	  }

	  has (key) {
	    if (!this[CACHE].has(key)) return false
	    const hit = this[CACHE].get(key).value;
	    return !isStale(this, hit)
	  }

	  get (key) {
	    return get(this, key, true)
	  }

	  peek (key) {
	    return get(this, key, false)
	  }

	  pop () {
	    const node = this[LRU_LIST].tail;
	    if (!node)
	      return null

	    del(this, node);
	    return node.value
	  }

	  del (key) {
	    del(this, this[CACHE].get(key));
	  }

	  load (arr) {
	    // reset the cache
	    this.reset();

	    const now = Date.now();
	    // A previous serialized cache has the most recent items first
	    for (let l = arr.length - 1; l >= 0; l--) {
	      const hit = arr[l];
	      const expiresAt = hit.e || 0;
	      if (expiresAt === 0)
	        // the item was created without expiration in a non aged cache
	        this.set(hit.k, hit.v);
	      else {
	        const maxAge = expiresAt - now;
	        // dont add already expired items
	        if (maxAge > 0) {
	          this.set(hit.k, hit.v, maxAge);
	        }
	      }
	    }
	  }

	  prune () {
	    this[CACHE].forEach((value, key) => get(this, key, false));
	  }
	}

	const get = (self, key, doUse) => {
	  const node = self[CACHE].get(key);
	  if (node) {
	    const hit = node.value;
	    if (isStale(self, hit)) {
	      del(self, node);
	      if (!self[ALLOW_STALE])
	        return undefined
	    } else {
	      if (doUse) {
	        if (self[UPDATE_AGE_ON_GET])
	          node.value.now = Date.now();
	        self[LRU_LIST].unshiftNode(node);
	      }
	    }
	    return hit.value
	  }
	};

	const isStale = (self, hit) => {
	  if (!hit || (!hit.maxAge && !self[MAX_AGE]))
	    return false

	  const diff = Date.now() - hit.now;
	  return hit.maxAge ? diff > hit.maxAge
	    : self[MAX_AGE] && (diff > self[MAX_AGE])
	};

	const trim = self => {
	  if (self[LENGTH] > self[MAX]) {
	    for (let walker = self[LRU_LIST].tail;
	      self[LENGTH] > self[MAX] && walker !== null;) {
	      // We know that we're about to delete this one, and also
	      // what the next least recently used key will be, so just
	      // go ahead and set it now.
	      const prev = walker.prev;
	      del(self, walker);
	      walker = prev;
	    }
	  }
	};

	const del = (self, node) => {
	  if (node) {
	    const hit = node.value;
	    if (self[DISPOSE])
	      self[DISPOSE](hit.key, hit.value);

	    self[LENGTH] -= hit.length;
	    self[CACHE].delete(hit.key);
	    self[LRU_LIST].removeNode(node);
	  }
	};

	class Entry {
	  constructor (key, value, length, now, maxAge) {
	    this.key = key;
	    this.value = value;
	    this.length = length;
	    this.now = now;
	    this.maxAge = maxAge || 0;
	  }
	}

	const forEachStep = (self, fn, node, thisp) => {
	  let hit = node.value;
	  if (isStale(self, hit)) {
	    del(self, node);
	    if (!self[ALLOW_STALE])
	      hit = undefined;
	  }
	  if (hit)
	    fn.call(thisp, hit.value, hit.key, self);
	};

	lruCache = LRUCache;
	return lruCache;
}

var name = "openid-client";
var version = "5.7.0";
var description = "OpenID Connect Relying Party (RP, Client) implementation for Node.js runtime, supports passportjs";
var keywords = [
	"auth",
	"authentication",
	"basic",
	"certified",
	"client",
	"connect",
	"dynamic",
	"electron",
	"hybrid",
	"identity",
	"implicit",
	"oauth",
	"oauth2",
	"oidc",
	"openid",
	"passport",
	"relying party",
	"strategy"
];
var homepage = "https://github.com/panva/node-openid-client";
var repository = "panva/node-openid-client";
var funding = {
	url: "https://github.com/sponsors/panva"
};
var license = "MIT";
var author = "Filip Skokan <panva.ip@gmail.com>";
var exports$1 = {
	types: "./types/index.d.ts",
	"import": "./lib/index.mjs",
	require: "./lib/index.js"
};
var main = "./lib/index.js";
var types = "./types/index.d.ts";
var files = [
	"lib",
	"types/index.d.ts"
];
var scripts = {
	format: "npx prettier --loglevel silent --write ./lib ./test ./certification ./types",
	test: "mocha test/**/*.test.js"
};
var dependencies = {
	jose: "^4.15.9",
	"lru-cache": "^6.0.0",
	"object-hash": "^2.2.0",
	"oidc-token-hash": "^5.0.3"
};
var devDependencies = {
	"@types/node": "^16.18.106",
	"@types/passport": "^1.0.16",
	base64url: "^3.0.1",
	chai: "^4.5.0",
	mocha: "^10.7.3",
	nock: "^13.5.5",
	prettier: "^2.8.8",
	"readable-mock-req": "^0.2.2",
	sinon: "^9.2.4",
	timekeeper: "^2.3.1"
};
var require$$7 = {
	name: name,
	version: version,
	description: description,
	keywords: keywords,
	homepage: homepage,
	repository: repository,
	funding: funding,
	license: license,
	author: author,
	exports: exports$1,
	main: main,
	types: types,
	files: files,
	scripts: scripts,
	dependencies: dependencies,
	devDependencies: devDependencies,
	"standard-version": {
	scripts: {
		postchangelog: "sed -i '' -e 's/### \\[/## [/g' CHANGELOG.md"
	},
	types: [
		{
			type: "feat",
			section: "Features"
		},
		{
			type: "fix",
			section: "Fixes"
		},
		{
			type: "chore",
			hidden: true
		},
		{
			type: "docs",
			hidden: true
		},
		{
			type: "style",
			hidden: true
		},
		{
			type: "refactor",
			section: "Refactor",
			hidden: false
		},
		{
			type: "perf",
			section: "Performance",
			hidden: false
		},
		{
			type: "test",
			hidden: true
		}
	]
}
};

var consts;
var hasRequiredConsts;

function requireConsts () {
	if (hasRequiredConsts) return consts;
	hasRequiredConsts = 1;
	const HTTP_OPTIONS = Symbol();
	const CLOCK_TOLERANCE = Symbol();

	consts = {
	  CLOCK_TOLERANCE,
	  HTTP_OPTIONS,
	};
	return consts;
}

var hasRequiredRequest;

function requireRequest () {
	if (hasRequiredRequest) return request.exports;
	hasRequiredRequest = 1;
	const assert = require$$0$5;
	const querystring = require$$1$3;
	const http = require$$0$2;
	const https = require$$2;
	const { once } = require$$2$1;
	const { URL } = require$$5;

	const LRU = requireLruCache();

	const pkg = require$$7;
	const { RPError } = requireErrors$1();

	const pick = requirePick();
	const { deep: defaultsDeep } = requireDefaults();
	const { HTTP_OPTIONS } = requireConsts();

	let DEFAULT_HTTP_OPTIONS;
	const NQCHAR = /^[\x21\x23-\x5B\x5D-\x7E]+$/;

	const allowed = [
	  'agent',
	  'ca',
	  'cert',
	  'crl',
	  'headers',
	  'key',
	  'lookup',
	  'passphrase',
	  'pfx',
	  'timeout',
	];

	const setDefaults = (props, options) => {
	  DEFAULT_HTTP_OPTIONS = defaultsDeep(
	    {},
	    props.length ? pick(options, ...props) : options,
	    DEFAULT_HTTP_OPTIONS,
	  );
	};

	setDefaults([], {
	  headers: {
	    'User-Agent': `${pkg.name}/${pkg.version} (${pkg.homepage})`,
	    'Accept-Encoding': 'identity',
	  },
	  timeout: 3500,
	});

	function send(req, body, contentType) {
	  if (contentType) {
	    req.removeHeader('content-type');
	    req.setHeader('content-type', contentType);
	  }
	  if (body) {
	    req.removeHeader('content-length');
	    req.setHeader('content-length', Buffer.byteLength(body));
	    req.write(body);
	  }
	  req.end();
	}

	const nonces = new LRU({ max: 100 });

	request.exports = async function request(options, { accessToken, mTLS = false, DPoP } = {}) {
	  let url;
	  try {
	    url = new URL(options.url);
	    delete options.url;
	    assert(/^(https?:)$/.test(url.protocol));
	  } catch (err) {
	    throw new TypeError('only valid absolute URLs can be requested');
	  }
	  const optsFn = this[HTTP_OPTIONS];
	  let opts = options;

	  const nonceKey = `${url.origin}${url.pathname}`;
	  if (DPoP && 'dpopProof' in this) {
	    opts.headers = opts.headers || {};
	    opts.headers.DPoP = await this.dpopProof(
	      {
	        htu: `${url.origin}${url.pathname}`,
	        htm: options.method || 'GET',
	        nonce: nonces.get(nonceKey),
	      },
	      DPoP,
	      accessToken,
	    );
	  }

	  let userOptions;
	  if (optsFn) {
	    userOptions = pick(
	      optsFn.call(this, url, defaultsDeep({}, opts, DEFAULT_HTTP_OPTIONS)),
	      ...allowed,
	    );
	  }
	  opts = defaultsDeep({}, userOptions, opts, DEFAULT_HTTP_OPTIONS);

	  if (mTLS && !opts.pfx && !(opts.key && opts.cert)) {
	    throw new TypeError('mutual-TLS certificate and key not set');
	  }

	  if (opts.searchParams) {
	    for (const [key, value] of Object.entries(opts.searchParams)) {
	      url.searchParams.delete(key);
	      url.searchParams.set(key, value);
	    }
	  }

	  let responseType;
	  let form;
	  let json;
	  let body;
	  ({ form, responseType, json, body, ...opts } = opts);

	  for (const [key, value] of Object.entries(opts.headers || {})) {
	    if (value === undefined) {
	      delete opts.headers[key];
	    }
	  }

	  let response;
	  const req = (url.protocol === 'https:' ? https.request : http.request)(url.href, opts);
	  return (async () => {
	    if (json) {
	      send(req, JSON.stringify(json), 'application/json');
	    } else if (form) {
	      send(req, querystring.stringify(form), 'application/x-www-form-urlencoded');
	    } else if (body) {
	      send(req, body);
	    } else {
	      send(req);
	    }

	    [response] = await Promise.race([once(req, 'response'), once(req, 'timeout')]);

	    // timeout reached
	    if (!response) {
	      req.destroy();
	      throw new RPError(`outgoing request timed out after ${opts.timeout}ms`);
	    }

	    const parts = [];

	    for await (const part of response) {
	      parts.push(part);
	    }

	    if (parts.length) {
	      switch (responseType) {
	        case 'json': {
	          Object.defineProperty(response, 'body', {
	            get() {
	              let value = Buffer.concat(parts);
	              try {
	                value = JSON.parse(value);
	              } catch (err) {
	                Object.defineProperty(err, 'response', { value: response });
	                throw err;
	              } finally {
	                Object.defineProperty(response, 'body', { value, configurable: true });
	              }
	              return value;
	            },
	            configurable: true,
	          });
	          break;
	        }
	        case undefined:
	        case 'buffer': {
	          Object.defineProperty(response, 'body', {
	            get() {
	              const value = Buffer.concat(parts);
	              Object.defineProperty(response, 'body', { value, configurable: true });
	              return value;
	            },
	            configurable: true,
	          });
	          break;
	        }
	        default:
	          throw new TypeError('unsupported responseType request option');
	      }
	    }

	    return response;
	  })()
	    .catch((err) => {
	      if (response) Object.defineProperty(err, 'response', { value: response });
	      throw err;
	    })
	    .finally(() => {
	      const dpopNonce = response && response.headers['dpop-nonce'];
	      if (dpopNonce && NQCHAR.test(dpopNonce)) {
	        nonces.set(nonceKey, dpopNonce);
	      }
	    });
	};

	request.exports.setDefaults = setDefaults.bind(undefined, allowed);
	return request.exports;
}

var weak_cache = {};

var hasRequiredWeak_cache;

function requireWeak_cache () {
	if (hasRequiredWeak_cache) return weak_cache;
	hasRequiredWeak_cache = 1;
	weak_cache.keystores = new WeakMap();
	return weak_cache;
}

var deep_clone;
var hasRequiredDeep_clone;

function requireDeep_clone () {
	if (hasRequiredDeep_clone) return deep_clone;
	hasRequiredDeep_clone = 1;
	deep_clone = globalThis.structuredClone || ((obj) => JSON.parse(JSON.stringify(obj)));
	return deep_clone;
}

var keystore;
var hasRequiredKeystore;

function requireKeystore () {
	if (hasRequiredKeystore) return keystore;
	hasRequiredKeystore = 1;
	const jose = /*@__PURE__*/ requireCjs();

	const clone = requireDeep_clone();
	const isPlainObject = requireIs_plain_object();

	const internal = Symbol();

	const keyscore = (key, { alg, use }) => {
	  let score = 0;

	  if (alg && key.alg) {
	    score++;
	  }

	  if (use && key.use) {
	    score++;
	  }

	  return score;
	};

	function getKtyFromAlg(alg) {
	  switch (typeof alg === 'string' && alg.slice(0, 2)) {
	    case 'RS':
	    case 'PS':
	      return 'RSA';
	    case 'ES':
	      return 'EC';
	    case 'Ed':
	      return 'OKP';
	    default:
	      return undefined;
	  }
	}

	function getAlgorithms(use, alg, kty, crv) {
	  // Ed25519, Ed448, and secp256k1 always have "alg"
	  // OKP always has "use"
	  if (alg) {
	    return new Set([alg]);
	  }

	  switch (kty) {
	    case 'EC': {
	      let algs = [];

	      if (use === 'enc' || use === undefined) {
	        algs = algs.concat(['ECDH-ES', 'ECDH-ES+A128KW', 'ECDH-ES+A192KW', 'ECDH-ES+A256KW']);
	      }

	      if (use === 'sig' || use === undefined) {
	        switch (crv) {
	          case 'P-256':
	          case 'P-384':
	            algs = algs.concat([`ES${crv.slice(-3)}`]);
	            break;
	          case 'P-521':
	            algs = algs.concat(['ES512']);
	            break;
	          case 'secp256k1':
	            if (jose.cryptoRuntime === 'node:crypto') {
	              algs = algs.concat(['ES256K']);
	            }
	            break;
	        }
	      }

	      return new Set(algs);
	    }
	    case 'OKP': {
	      return new Set(['ECDH-ES', 'ECDH-ES+A128KW', 'ECDH-ES+A192KW', 'ECDH-ES+A256KW']);
	    }
	    case 'RSA': {
	      let algs = [];

	      if (use === 'enc' || use === undefined) {
	        algs = algs.concat(['RSA-OAEP', 'RSA-OAEP-256', 'RSA-OAEP-384', 'RSA-OAEP-512']);
	        if (jose.cryptoRuntime === 'node:crypto') {
	          algs = algs.concat(['RSA1_5']);
	        }
	      }

	      if (use === 'sig' || use === undefined) {
	        algs = algs.concat(['PS256', 'PS384', 'PS512', 'RS256', 'RS384', 'RS512']);
	      }

	      return new Set(algs);
	    }
	    default:
	      throw new Error('unreachable');
	  }
	}

	keystore = class KeyStore {
	  #keys;

	  constructor(i, keys) {
	    if (i !== internal) throw new Error('invalid constructor call');
	    this.#keys = keys;
	  }

	  toJWKS() {
	    return {
	      keys: this.map(({ jwk: { d, p, q, dp, dq, qi, ...jwk } }) => jwk),
	    };
	  }

	  all({ alg, kid, use } = {}) {
	    if (!use || !alg) {
	      throw new Error();
	    }

	    const kty = getKtyFromAlg(alg);

	    const search = { alg, use };
	    return this.filter((key) => {
	      let candidate = true;

	      if (candidate && kty !== undefined && key.jwk.kty !== kty) {
	        candidate = false;
	      }

	      if (candidate && kid !== undefined && key.jwk.kid !== kid) {
	        candidate = false;
	      }

	      if (candidate && use !== undefined && key.jwk.use !== undefined && key.jwk.use !== use) {
	        candidate = false;
	      }

	      if (candidate && key.jwk.alg && key.jwk.alg !== alg) {
	        candidate = false;
	      } else if (!key.algorithms.has(alg)) {
	        candidate = false;
	      }

	      return candidate;
	    }).sort((first, second) => keyscore(second, search) - keyscore(first, search));
	  }

	  get(...args) {
	    return this.all(...args)[0];
	  }

	  static async fromJWKS(jwks, { onlyPublic = false, onlyPrivate = false } = {}) {
	    if (
	      !isPlainObject(jwks) ||
	      !Array.isArray(jwks.keys) ||
	      jwks.keys.some((k) => !isPlainObject(k) || !('kty' in k))
	    ) {
	      throw new TypeError('jwks must be a JSON Web Key Set formatted object');
	    }

	    const keys = [];

	    for (let jwk of jwks.keys) {
	      jwk = clone(jwk);
	      const { kty, kid, crv } = jwk;

	      let { alg, use } = jwk;

	      if (typeof kty !== 'string' || !kty) {
	        continue;
	      }

	      if (use !== undefined && use !== 'sig' && use !== 'enc') {
	        continue;
	      }

	      if (typeof alg !== 'string' && alg !== undefined) {
	        continue;
	      }

	      if (typeof kid !== 'string' && kid !== undefined) {
	        continue;
	      }

	      if (kty === 'EC' && use === 'sig') {
	        switch (crv) {
	          case 'P-256':
	            alg = 'ES256';
	            break;
	          case 'P-384':
	            alg = 'ES384';
	            break;
	          case 'P-521':
	            alg = 'ES512';
	            break;
	        }
	      }

	      if (crv === 'secp256k1') {
	        use = 'sig';
	        alg = 'ES256K';
	      }

	      if (kty === 'OKP') {
	        switch (crv) {
	          case 'Ed25519':
	          case 'Ed448':
	            use = 'sig';
	            alg = 'EdDSA';
	            break;
	          case 'X25519':
	          case 'X448':
	            use = 'enc';
	            break;
	        }
	      }

	      if (alg && !use) {
	        switch (true) {
	          case alg.startsWith('ECDH'):
	            use = 'enc';
	            break;
	          case alg.startsWith('RSA'):
	            use = 'enc';
	            break;
	        }
	      }

	      if (onlyPrivate && (jwk.kty === 'oct' || !jwk.d)) {
	        throw new Error('jwks must only contain private keys');
	      }

	      if (onlyPublic && (jwk.d || jwk.k)) {
	        continue;
	      }

	      keys.push({
	        jwk: { ...jwk, alg, use },
	        async keyObject(alg) {
	          if (this[alg]) {
	            return this[alg];
	          }

	          const keyObject = await jose.importJWK(this.jwk, alg);
	          this[alg] = keyObject;
	          return keyObject;
	        },
	        get algorithms() {
	          Object.defineProperty(this, 'algorithms', {
	            value: getAlgorithms(this.jwk.use, this.jwk.alg, this.jwk.kty, this.jwk.crv),
	            enumerable: true,
	            configurable: false,
	          });
	          return this.algorithms;
	        },
	      });
	    }

	    return new this(internal, keys);
	  }

	  filter(...args) {
	    return this.#keys.filter(...args);
	  }

	  find(...args) {
	    return this.#keys.find(...args);
	  }

	  every(...args) {
	    return this.#keys.every(...args);
	  }

	  some(...args) {
	    return this.#keys.some(...args);
	  }

	  map(...args) {
	    return this.#keys.map(...args);
	  }

	  forEach(...args) {
	    return this.#keys.forEach(...args);
	  }

	  reduce(...args) {
	    return this.#keys.reduce(...args);
	  }

	  sort(...args) {
	    return this.#keys.sort(...args);
	  }

	  *[Symbol.iterator]() {
	    for (const key of this.#keys) {
	      yield key;
	    }
	  }
	};
	return keystore;
}

var merge_1;
var hasRequiredMerge;

function requireMerge () {
	if (hasRequiredMerge) return merge_1;
	hasRequiredMerge = 1;
	const isPlainObject = requireIs_plain_object();

	function merge(target, ...sources) {
	  for (const source of sources) {
	    if (!isPlainObject(source)) {
	      continue;
	    }
	    for (const [key, value] of Object.entries(source)) {
	      /* istanbul ignore if */
	      if (key === '__proto__' || key === 'constructor') {
	        continue;
	      }
	      if (isPlainObject(target[key]) && isPlainObject(value)) {
	        target[key] = merge(target[key], value);
	      } else if (typeof value !== 'undefined') {
	        target[key] = value;
	      }
	    }
	  }

	  return target;
	}

	merge_1 = merge;
	return merge_1;
}

var client;
var hasRequiredClient$1;

function requireClient$1 () {
	if (hasRequiredClient$1) return client;
	hasRequiredClient$1 = 1;
	const jose = /*@__PURE__*/ requireCjs();

	const { RPError } = requireErrors$1();

	const { assertIssuerConfiguration } = requireAssert();
	const { random } = requireGenerators();
	const now = requireUnix_timestamp();
	const request = requireRequest();
	const { keystores } = requireWeak_cache();
	const merge = requireMerge();

	// TODO: in v6.x additionally encode the `- _ . ! ~ * ' ( )` characters
	// https://github.com/panva/node-openid-client/commit/5a2ea80ef5e59ec0c03dbd97d82f551e24a9d348
	const formUrlEncode = (value) => encodeURIComponent(value).replace(/%20/g, '+');

	async function clientAssertion(endpoint, payload) {
	  let alg = this[`${endpoint}_endpoint_auth_signing_alg`];
	  if (!alg) {
	    assertIssuerConfiguration(
	      this.issuer,
	      `${endpoint}_endpoint_auth_signing_alg_values_supported`,
	    );
	  }

	  if (this[`${endpoint}_endpoint_auth_method`] === 'client_secret_jwt') {
	    if (!alg) {
	      const supported = this.issuer[`${endpoint}_endpoint_auth_signing_alg_values_supported`];
	      alg =
	        Array.isArray(supported) && supported.find((signAlg) => /^HS(?:256|384|512)/.test(signAlg));
	    }

	    if (!alg) {
	      throw new RPError(
	        `failed to determine a JWS Algorithm to use for ${
	          this[`${endpoint}_endpoint_auth_method`]
	        } Client Assertion`,
	      );
	    }

	    return new jose.CompactSign(Buffer.from(JSON.stringify(payload)))
	      .setProtectedHeader({ alg })
	      .sign(this.secretForAlg(alg));
	  }

	  const keystore = await keystores.get(this);

	  if (!keystore) {
	    throw new TypeError('no client jwks provided for signing a client assertion with');
	  }

	  if (!alg) {
	    const supported = this.issuer[`${endpoint}_endpoint_auth_signing_alg_values_supported`];
	    alg =
	      Array.isArray(supported) &&
	      supported.find((signAlg) => keystore.get({ alg: signAlg, use: 'sig' }));
	  }

	  if (!alg) {
	    throw new RPError(
	      `failed to determine a JWS Algorithm to use for ${
	        this[`${endpoint}_endpoint_auth_method`]
	      } Client Assertion`,
	    );
	  }

	  const key = keystore.get({ alg, use: 'sig' });
	  if (!key) {
	    throw new RPError(
	      `no key found in client jwks to sign a client assertion with using alg ${alg}`,
	    );
	  }

	  return new jose.CompactSign(Buffer.from(JSON.stringify(payload)))
	    .setProtectedHeader({ alg, kid: key.jwk && key.jwk.kid })
	    .sign(await key.keyObject(alg));
	}

	async function authFor(endpoint, { clientAssertionPayload } = {}) {
	  const authMethod = this[`${endpoint}_endpoint_auth_method`];
	  switch (authMethod) {
	    case 'self_signed_tls_client_auth':
	    case 'tls_client_auth':
	    case 'none':
	      return { form: { client_id: this.client_id } };
	    case 'client_secret_post':
	      if (typeof this.client_secret !== 'string') {
	        throw new TypeError(
	          'client_secret_post client authentication method requires a client_secret',
	        );
	      }
	      return { form: { client_id: this.client_id, client_secret: this.client_secret } };
	    case 'private_key_jwt':
	    case 'client_secret_jwt': {
	      const timestamp = now();
	      const audience = [
	        ...new Set([this.issuer.issuer, this.issuer.token_endpoint].filter(Boolean)),
	      ];

	      const assertion = await clientAssertion.call(this, endpoint, {
	        iat: timestamp,
	        exp: timestamp + 60,
	        jti: random(),
	        iss: this.client_id,
	        sub: this.client_id,
	        aud: audience,
	        ...clientAssertionPayload,
	      });

	      return {
	        form: {
	          client_id: this.client_id,
	          client_assertion: assertion,
	          client_assertion_type: 'urn:ietf:params:oauth:client-assertion-type:jwt-bearer',
	        },
	      };
	    }
	    case 'client_secret_basic': {
	      // This is correct behaviour, see https://tools.ietf.org/html/rfc6749#section-2.3.1 and the
	      // related appendix. (also https://github.com/panva/node-openid-client/pull/91)
	      // > The client identifier is encoded using the
	      // > "application/x-www-form-urlencoded" encoding algorithm per
	      // > Appendix B, and the encoded value is used as the username; the client
	      // > password is encoded using the same algorithm and used as the
	      // > password.
	      if (typeof this.client_secret !== 'string') {
	        throw new TypeError(
	          'client_secret_basic client authentication method requires a client_secret',
	        );
	      }
	      const encoded = `${formUrlEncode(this.client_id)}:${formUrlEncode(this.client_secret)}`;
	      const value = Buffer.from(encoded).toString('base64');
	      return { headers: { Authorization: `Basic ${value}` } };
	    }
	    default: {
	      throw new TypeError(`missing, or unsupported, ${endpoint}_endpoint_auth_method`);
	    }
	  }
	}

	function resolveResponseType() {
	  const { length, 0: value } = this.response_types;

	  if (length === 1) {
	    return value;
	  }

	  return undefined;
	}

	function resolveRedirectUri() {
	  const { length, 0: value } = this.redirect_uris || [];

	  if (length === 1) {
	    return value;
	  }

	  return undefined;
	}

	async function authenticatedPost(
	  endpoint,
	  opts,
	  { clientAssertionPayload, endpointAuthMethod = endpoint, DPoP } = {},
	) {
	  const auth = await authFor.call(this, endpointAuthMethod, { clientAssertionPayload });
	  const requestOpts = merge(opts, auth);

	  const mTLS =
	    this[`${endpointAuthMethod}_endpoint_auth_method`].includes('tls_client_auth') ||
	    (endpoint === 'token' && this.tls_client_certificate_bound_access_tokens);

	  let targetUrl;
	  if (mTLS && this.issuer.mtls_endpoint_aliases) {
	    targetUrl = this.issuer.mtls_endpoint_aliases[`${endpoint}_endpoint`];
	  }

	  targetUrl = targetUrl || this.issuer[`${endpoint}_endpoint`];

	  if ('form' in requestOpts) {
	    for (const [key, value] of Object.entries(requestOpts.form)) {
	      if (typeof value === 'undefined') {
	        delete requestOpts.form[key];
	      }
	    }
	  }

	  return request.call(
	    this,
	    {
	      ...requestOpts,
	      method: 'POST',
	      url: targetUrl,
	      headers: {
	        ...(endpoint !== 'revocation'
	          ? {
	              Accept: 'application/json',
	            }
	          : undefined),
	        ...requestOpts.headers,
	      },
	    },
	    { mTLS, DPoP },
	  );
	}

	client = {
	  resolveResponseType,
	  resolveRedirectUri,
	  authFor,
	  authenticatedPost,
	};
	return client;
}

var issuer$1 = {};

var objectHash = {exports: {}};

var hasRequiredObjectHash;

function requireObjectHash () {
	if (hasRequiredObjectHash) return objectHash.exports;
	hasRequiredObjectHash = 1;
	(function (module, exports) {

		var crypto = require$$0$9;

		/**
		 * Exported function
		 *
		 * Options:
		 *
		 *  - `algorithm` hash algo to be used by this instance: *'sha1', 'md5'
		 *  - `excludeValues` {true|*false} hash object keys, values ignored
		 *  - `encoding` hash encoding, supports 'buffer', '*hex', 'binary', 'base64'
		 *  - `ignoreUnknown` {true|*false} ignore unknown object types
		 *  - `replacer` optional function that replaces values before hashing
		 *  - `respectFunctionProperties` {*true|false} consider function properties when hashing
		 *  - `respectFunctionNames` {*true|false} consider 'name' property of functions for hashing
		 *  - `respectType` {*true|false} Respect special properties (prototype, constructor)
		 *    when hashing to distinguish between types
		 *  - `unorderedArrays` {true|*false} Sort all arrays before hashing
		 *  - `unorderedSets` {*true|false} Sort `Set` and `Map` instances before hashing
		 *  * = default
		 *
		 * @param {object} object value to hash
		 * @param {object} options hashing options
		 * @return {string} hash value
		 * @api public
		 */
		exports = module.exports = objectHash;

		function objectHash(object, options){
		  options = applyDefaults(object, options);

		  return hash(object, options);
		}

		/**
		 * Exported sugar methods
		 *
		 * @param {object} object value to hash
		 * @return {string} hash value
		 * @api public
		 */
		exports.sha1 = function(object){
		  return objectHash(object);
		};
		exports.keys = function(object){
		  return objectHash(object, {excludeValues: true, algorithm: 'sha1', encoding: 'hex'});
		};
		exports.MD5 = function(object){
		  return objectHash(object, {algorithm: 'md5', encoding: 'hex'});
		};
		exports.keysMD5 = function(object){
		  return objectHash(object, {algorithm: 'md5', encoding: 'hex', excludeValues: true});
		};

		// Internals
		var hashes = crypto.getHashes ? crypto.getHashes().slice() : ['sha1', 'md5'];
		hashes.push('passthrough');
		var encodings = ['buffer', 'hex', 'binary', 'base64'];

		function applyDefaults(object, sourceOptions){
		  sourceOptions = sourceOptions || {};

		  // create a copy rather than mutating
		  var options = {};
		  options.algorithm = sourceOptions.algorithm || 'sha1';
		  options.encoding = sourceOptions.encoding || 'hex';
		  options.excludeValues = sourceOptions.excludeValues ? true : false;
		  options.algorithm = options.algorithm.toLowerCase();
		  options.encoding = options.encoding.toLowerCase();
		  options.ignoreUnknown = sourceOptions.ignoreUnknown !== true ? false : true; // default to false
		  options.respectType = sourceOptions.respectType === false ? false : true; // default to true
		  options.respectFunctionNames = sourceOptions.respectFunctionNames === false ? false : true;
		  options.respectFunctionProperties = sourceOptions.respectFunctionProperties === false ? false : true;
		  options.unorderedArrays = sourceOptions.unorderedArrays !== true ? false : true; // default to false
		  options.unorderedSets = sourceOptions.unorderedSets === false ? false : true; // default to false
		  options.unorderedObjects = sourceOptions.unorderedObjects === false ? false : true; // default to true
		  options.replacer = sourceOptions.replacer || undefined;
		  options.excludeKeys = sourceOptions.excludeKeys || undefined;

		  if(typeof object === 'undefined') {
		    throw new Error('Object argument required.');
		  }

		  // if there is a case-insensitive match in the hashes list, accept it
		  // (i.e. SHA256 for sha256)
		  for (var i = 0; i < hashes.length; ++i) {
		    if (hashes[i].toLowerCase() === options.algorithm.toLowerCase()) {
		      options.algorithm = hashes[i];
		    }
		  }

		  if(hashes.indexOf(options.algorithm) === -1){
		    throw new Error('Algorithm "' + options.algorithm + '"  not supported. ' +
		      'supported values: ' + hashes.join(', '));
		  }

		  if(encodings.indexOf(options.encoding) === -1 &&
		     options.algorithm !== 'passthrough'){
		    throw new Error('Encoding "' + options.encoding + '"  not supported. ' +
		      'supported values: ' + encodings.join(', '));
		  }

		  return options;
		}

		/** Check if the given function is a native function */
		function isNativeFunction(f) {
		  if ((typeof f) !== 'function') {
		    return false;
		  }
		  var exp = /^function\s+\w*\s*\(\s*\)\s*{\s+\[native code\]\s+}$/i;
		  return exp.exec(Function.prototype.toString.call(f)) != null;
		}

		function hash(object, options) {
		  var hashingStream;

		  if (options.algorithm !== 'passthrough') {
		    hashingStream = crypto.createHash(options.algorithm);
		  } else {
		    hashingStream = new PassThrough();
		  }

		  if (typeof hashingStream.write === 'undefined') {
		    hashingStream.write = hashingStream.update;
		    hashingStream.end   = hashingStream.update;
		  }

		  var hasher = typeHasher(options, hashingStream);
		  hasher.dispatch(object);
		  if (!hashingStream.update) {
		    hashingStream.end('');
		  }

		  if (hashingStream.digest) {
		    return hashingStream.digest(options.encoding === 'buffer' ? undefined : options.encoding);
		  }

		  var buf = hashingStream.read();
		  if (options.encoding === 'buffer') {
		    return buf;
		  }

		  return buf.toString(options.encoding);
		}

		/**
		 * Expose streaming API
		 *
		 * @param {object} object  Value to serialize
		 * @param {object} options  Options, as for hash()
		 * @param {object} stream  A stream to write the serializiation to
		 * @api public
		 */
		exports.writeToStream = function(object, options, stream) {
		  if (typeof stream === 'undefined') {
		    stream = options;
		    options = {};
		  }

		  options = applyDefaults(object, options);

		  return typeHasher(options, stream).dispatch(object);
		};

		function typeHasher(options, writeTo, context){
		  context = context || [];
		  var write = function(str) {
		    if (writeTo.update) {
		      return writeTo.update(str, 'utf8');
		    } else {
		      return writeTo.write(str, 'utf8');
		    }
		  };

		  return {
		    dispatch: function(value){
		      if (options.replacer) {
		        value = options.replacer(value);
		      }

		      var type = typeof value;
		      if (value === null) {
		        type = 'null';
		      }

		      //console.log("[DEBUG] Dispatch: ", value, "->", type, " -> ", "_" + type);

		      return this['_' + type](value);
		    },
		    _object: function(object) {
		      var pattern = (/\[object (.*)\]/i);
		      var objString = Object.prototype.toString.call(object);
		      var objType = pattern.exec(objString);
		      if (!objType) { // object type did not match [object ...]
		        objType = 'unknown:[' + objString + ']';
		      } else {
		        objType = objType[1]; // take only the class name
		      }

		      objType = objType.toLowerCase();

		      var objectNumber = null;

		      if ((objectNumber = context.indexOf(object)) >= 0) {
		        return this.dispatch('[CIRCULAR:' + objectNumber + ']');
		      } else {
		        context.push(object);
		      }

		      if (typeof Buffer !== 'undefined' && Buffer.isBuffer && Buffer.isBuffer(object)) {
		        write('buffer:');
		        return write(object);
		      }

		      if(objType !== 'object' && objType !== 'function' && objType !== 'asyncfunction') {
		        if(this['_' + objType]) {
		          this['_' + objType](object);
		        } else if (options.ignoreUnknown) {
		          return write('[' + objType + ']');
		        } else {
		          throw new Error('Unknown object type "' + objType + '"');
		        }
		      }else {
		        var keys = Object.keys(object);
		        if (options.unorderedObjects) {
		          keys = keys.sort();
		        }
		        // Make sure to incorporate special properties, so
		        // Types with different prototypes will produce
		        // a different hash and objects derived from
		        // different functions (`new Foo`, `new Bar`) will
		        // produce different hashes.
		        // We never do this for native functions since some
		        // seem to break because of that.
		        if (options.respectType !== false && !isNativeFunction(object)) {
		          keys.splice(0, 0, 'prototype', '__proto__', 'constructor');
		        }

		        if (options.excludeKeys) {
		          keys = keys.filter(function(key) { return !options.excludeKeys(key); });
		        }

		        write('object:' + keys.length + ':');
		        var self = this;
		        return keys.forEach(function(key){
		          self.dispatch(key);
		          write(':');
		          if(!options.excludeValues) {
		            self.dispatch(object[key]);
		          }
		          write(',');
		        });
		      }
		    },
		    _array: function(arr, unordered){
		      unordered = typeof unordered !== 'undefined' ? unordered :
		        options.unorderedArrays !== false; // default to options.unorderedArrays

		      var self = this;
		      write('array:' + arr.length + ':');
		      if (!unordered || arr.length <= 1) {
		        return arr.forEach(function(entry) {
		          return self.dispatch(entry);
		        });
		      }

		      // the unordered case is a little more complicated:
		      // since there is no canonical ordering on objects,
		      // i.e. {a:1} < {a:2} and {a:1} > {a:2} are both false,
		      // we first serialize each entry using a PassThrough stream
		      // before sorting.
		      // also: we cant use the same context array for all entries
		      // since the order of hashing should *not* matter. instead,
		      // we keep track of the additions to a copy of the context array
		      // and add all of them to the global context array when were done
		      var contextAdditions = [];
		      var entries = arr.map(function(entry) {
		        var strm = new PassThrough();
		        var localContext = context.slice(); // make copy
		        var hasher = typeHasher(options, strm, localContext);
		        hasher.dispatch(entry);
		        // take only what was added to localContext and append it to contextAdditions
		        contextAdditions = contextAdditions.concat(localContext.slice(context.length));
		        return strm.read().toString();
		      });
		      context = context.concat(contextAdditions);
		      entries.sort();
		      return this._array(entries, false);
		    },
		    _date: function(date){
		      return write('date:' + date.toJSON());
		    },
		    _symbol: function(sym){
		      return write('symbol:' + sym.toString());
		    },
		    _error: function(err){
		      return write('error:' + err.toString());
		    },
		    _boolean: function(bool){
		      return write('bool:' + bool.toString());
		    },
		    _string: function(string){
		      write('string:' + string.length + ':');
		      write(string.toString());
		    },
		    _function: function(fn){
		      write('fn:');
		      if (isNativeFunction(fn)) {
		        this.dispatch('[native]');
		      } else {
		        this.dispatch(fn.toString());
		      }

		      if (options.respectFunctionNames !== false) {
		        // Make sure we can still distinguish native functions
		        // by their name, otherwise String and Function will
		        // have the same hash
		        this.dispatch("function-name:" + String(fn.name));
		      }

		      if (options.respectFunctionProperties) {
		        this._object(fn);
		      }
		    },
		    _number: function(number){
		      return write('number:' + number.toString());
		    },
		    _xml: function(xml){
		      return write('xml:' + xml.toString());
		    },
		    _null: function() {
		      return write('Null');
		    },
		    _undefined: function() {
		      return write('Undefined');
		    },
		    _regexp: function(regex){
		      return write('regex:' + regex.toString());
		    },
		    _uint8array: function(arr){
		      write('uint8array:');
		      return this.dispatch(Array.prototype.slice.call(arr));
		    },
		    _uint8clampedarray: function(arr){
		      write('uint8clampedarray:');
		      return this.dispatch(Array.prototype.slice.call(arr));
		    },
		    _int8array: function(arr){
		      write('uint8array:');
		      return this.dispatch(Array.prototype.slice.call(arr));
		    },
		    _uint16array: function(arr){
		      write('uint16array:');
		      return this.dispatch(Array.prototype.slice.call(arr));
		    },
		    _int16array: function(arr){
		      write('uint16array:');
		      return this.dispatch(Array.prototype.slice.call(arr));
		    },
		    _uint32array: function(arr){
		      write('uint32array:');
		      return this.dispatch(Array.prototype.slice.call(arr));
		    },
		    _int32array: function(arr){
		      write('uint32array:');
		      return this.dispatch(Array.prototype.slice.call(arr));
		    },
		    _float32array: function(arr){
		      write('float32array:');
		      return this.dispatch(Array.prototype.slice.call(arr));
		    },
		    _float64array: function(arr){
		      write('float64array:');
		      return this.dispatch(Array.prototype.slice.call(arr));
		    },
		    _arraybuffer: function(arr){
		      write('arraybuffer:');
		      return this.dispatch(new Uint8Array(arr));
		    },
		    _url: function(url) {
		      return write('url:' + url.toString());
		    },
		    _map: function(map) {
		      write('map:');
		      var arr = Array.from(map);
		      return this._array(arr, options.unorderedSets !== false);
		    },
		    _set: function(set) {
		      write('set:');
		      var arr = Array.from(set);
		      return this._array(arr, options.unorderedSets !== false);
		    },
		    _file: function(file) {
		      write('file:');
		      return this.dispatch([file.name, file.size, file.type, file.lastModfied]);
		    },
		    _blob: function() {
		      if (options.ignoreUnknown) {
		        return write('[blob]');
		      }

		      throw Error('Hashing Blob objects is currently not supported\n' +
		        '(see https://github.com/puleos/object-hash/issues/26)\n' +
		        'Use "options.replacer" or "options.ignoreUnknown"\n');
		    },
		    _domwindow: function() { return write('domwindow'); },
		    _bigint: function(number){
		      return write('bigint:' + number.toString());
		    },
		    /* Node.js standard native objects */
		    _process: function() { return write('process'); },
		    _timer: function() { return write('timer'); },
		    _pipe: function() { return write('pipe'); },
		    _tcp: function() { return write('tcp'); },
		    _udp: function() { return write('udp'); },
		    _tty: function() { return write('tty'); },
		    _statwatcher: function() { return write('statwatcher'); },
		    _securecontext: function() { return write('securecontext'); },
		    _connection: function() { return write('connection'); },
		    _zlib: function() { return write('zlib'); },
		    _context: function() { return write('context'); },
		    _nodescript: function() { return write('nodescript'); },
		    _httpparser: function() { return write('httpparser'); },
		    _dataview: function() { return write('dataview'); },
		    _signal: function() { return write('signal'); },
		    _fsevent: function() { return write('fsevent'); },
		    _tlswrap: function() { return write('tlswrap'); },
		  };
		}

		// Mini-implementation of stream.PassThrough
		// We are far from having need for the full implementation, and we can
		// make assumptions like "many writes, then only one final read"
		// and we can ignore encoding specifics
		function PassThrough() {
		  return {
		    buf: '',

		    write: function(b) {
		      this.buf += b;
		    },

		    end: function(b) {
		      this.buf += b;
		    },

		    read: function() {
		      return this.buf;
		    }
		  };
		} 
	} (objectHash, objectHash.exports));
	return objectHash.exports;
}

var hasRequiredIssuer$1;

function requireIssuer$1 () {
	if (hasRequiredIssuer$1) return issuer$1;
	hasRequiredIssuer$1 = 1;
	const objectHash = requireObjectHash();
	const LRU = requireLruCache();

	const { RPError } = requireErrors$1();

	const { assertIssuerConfiguration } = requireAssert();
	const KeyStore = requireKeystore();
	const { keystores } = requireWeak_cache();
	const processResponse = requireProcess_response();
	const request = requireRequest();

	const inFlight = new WeakMap();
	const caches = new WeakMap();
	const lrus = (ctx) => {
	  if (!caches.has(ctx)) {
	    caches.set(ctx, new LRU({ max: 100 }));
	  }
	  return caches.get(ctx);
	};

	async function getKeyStore(reload = false) {
	  assertIssuerConfiguration(this, 'jwks_uri');

	  const keystore = keystores.get(this);
	  const cache = lrus(this);

	  if (reload || !keystore) {
	    if (inFlight.has(this)) {
	      return inFlight.get(this);
	    }
	    cache.reset();
	    inFlight.set(
	      this,
	      (async () => {
	        const response = await request
	          .call(this, {
	            method: 'GET',
	            responseType: 'json',
	            url: this.jwks_uri,
	            headers: {
	              Accept: 'application/json, application/jwk-set+json',
	            },
	          })
	          .finally(() => {
	            inFlight.delete(this);
	          });
	        const jwks = processResponse(response);

	        const joseKeyStore = KeyStore.fromJWKS(jwks, { onlyPublic: true });
	        cache.set('throttle', true, 60 * 1000);
	        keystores.set(this, joseKeyStore);

	        return joseKeyStore;
	      })(),
	    );

	    return inFlight.get(this);
	  }

	  return keystore;
	}

	async function queryKeyStore({ kid, kty, alg, use }, { allowMulti = false } = {}) {
	  const cache = lrus(this);

	  const def = {
	    kid,
	    kty,
	    alg,
	    use,
	  };

	  const defHash = objectHash(def, {
	    algorithm: 'sha256',
	    ignoreUnknown: true,
	    unorderedArrays: true,
	    unorderedSets: true,
	    respectType: false,
	  });

	  // refresh keystore on every unknown key but also only upto once every minute
	  const freshJwksUri = cache.get(defHash) || cache.get('throttle');

	  const keystore = await getKeyStore.call(this, !freshJwksUri);
	  const keys = keystore.all(def);

	  delete def.use;
	  if (keys.length === 0) {
	    throw new RPError({
	      printf: ["no valid key found in issuer's jwks_uri for key parameters %j", def],
	      jwks: keystore,
	    });
	  }

	  if (!allowMulti && keys.length > 1 && !kid) {
	    throw new RPError({
	      printf: [
	        "multiple matching keys found in issuer's jwks_uri for key parameters %j, kid must be provided in this case",
	        def,
	      ],
	      jwks: keystore,
	    });
	  }

	  cache.set(defHash, true);

	  return keys;
	}

	issuer$1.queryKeyStore = queryKeyStore;
	issuer$1.keystore = getKeyStore;
	return issuer$1;
}

var device_flow_handle;
var hasRequiredDevice_flow_handle;

function requireDevice_flow_handle () {
	if (hasRequiredDevice_flow_handle) return device_flow_handle;
	hasRequiredDevice_flow_handle = 1;
	const { inspect } = require$$1;

	const { RPError, OPError } = requireErrors$1();
	const now = requireUnix_timestamp();

	class DeviceFlowHandle {
	  #aborted;
	  #client;
	  #clientAssertionPayload;
	  #DPoP;
	  #exchangeBody;
	  #expires_at;
	  #interval;
	  #maxAge;
	  #response;
	  constructor({ client, exchangeBody, clientAssertionPayload, response, maxAge, DPoP }) {
	    ['verification_uri', 'user_code', 'device_code'].forEach((prop) => {
	      if (typeof response[prop] !== 'string' || !response[prop]) {
	        throw new RPError(
	          `expected ${prop} string to be returned by Device Authorization Response, got %j`,
	          response[prop],
	        );
	      }
	    });

	    if (!Number.isSafeInteger(response.expires_in)) {
	      throw new RPError(
	        'expected expires_in number to be returned by Device Authorization Response, got %j',
	        response.expires_in,
	      );
	    }

	    this.#expires_at = now() + response.expires_in;
	    this.#client = client;
	    this.#DPoP = DPoP;
	    this.#maxAge = maxAge;
	    this.#exchangeBody = exchangeBody;
	    this.#clientAssertionPayload = clientAssertionPayload;
	    this.#response = response;
	    this.#interval = response.interval * 1000 || 5000;
	  }

	  abort() {
	    this.#aborted = true;
	  }

	  async poll({ signal } = {}) {
	    if ((signal && signal.aborted) || this.#aborted) {
	      throw new RPError('polling aborted');
	    }

	    if (this.expired()) {
	      throw new RPError(
	        'the device code %j has expired and the device authorization session has concluded',
	        this.device_code,
	      );
	    }

	    await new Promise((resolve) => setTimeout(resolve, this.#interval));

	    let tokenset;
	    try {
	      tokenset = await this.#client.grant(
	        {
	          ...this.#exchangeBody,
	          grant_type: 'urn:ietf:params:oauth:grant-type:device_code',
	          device_code: this.device_code,
	        },
	        { clientAssertionPayload: this.#clientAssertionPayload, DPoP: this.#DPoP },
	      );
	    } catch (err) {
	      switch (err instanceof OPError && err.error) {
	        case 'slow_down':
	          this.#interval += 5000;
	        case 'authorization_pending':
	          return this.poll({ signal });
	        default:
	          throw err;
	      }
	    }

	    if ('id_token' in tokenset) {
	      await this.#client.decryptIdToken(tokenset);
	      await this.#client.validateIdToken(tokenset, undefined, 'token', this.#maxAge);
	    }

	    return tokenset;
	  }

	  get device_code() {
	    return this.#response.device_code;
	  }

	  get user_code() {
	    return this.#response.user_code;
	  }

	  get verification_uri() {
	    return this.#response.verification_uri;
	  }

	  get verification_uri_complete() {
	    return this.#response.verification_uri_complete;
	  }

	  get expires_in() {
	    return Math.max.apply(null, [this.#expires_at - now(), 0]);
	  }

	  expired() {
	    return this.expires_in === 0;
	  }

	  /* istanbul ignore next */
	  [inspect.custom]() {
	    return `${this.constructor.name} ${inspect(this.#response, {
	      depth: Infinity,
	      colors: process.stdout.isTTY,
	      compact: false,
	      sorted: true,
	    })}`;
	  }
	}

	device_flow_handle = DeviceFlowHandle;
	return device_flow_handle;
}

var hasRequiredClient;

function requireClient () {
	if (hasRequiredClient) return client$1.exports;
	hasRequiredClient = 1;
	const { inspect } = require$$1;
	const stdhttp = require$$0$2;
	const crypto = require$$0$9;
	const { strict: assert } = require$$0$5;
	const querystring = require$$1$3;
	const url = require$$5;
	const { URL, URLSearchParams } = require$$5;

	const jose = /*@__PURE__*/ requireCjs();
	const tokenHash = requireLib$1();

	const isKeyObject = requireIs_key_object();
	const decodeJWT = requireDecode_jwt();
	const base64url = requireBase64url();
	const defaults = requireDefaults();
	const parseWwwAuthenticate = requireWww_authenticate_parser();
	const { assertSigningAlgValuesSupport, assertIssuerConfiguration } = requireAssert();
	const pick = requirePick();
	const isPlainObject = requireIs_plain_object();
	const processResponse = requireProcess_response();
	const TokenSet = requireToken_set();
	const { OPError, RPError } = requireErrors$1();
	const now = requireUnix_timestamp();
	const { random } = requireGenerators();
	const request = requireRequest();
	const { CLOCK_TOLERANCE } = requireConsts();
	const { keystores } = requireWeak_cache();
	const KeyStore = requireKeystore();
	const clone = requireDeep_clone();
	const { authenticatedPost, resolveResponseType, resolveRedirectUri } = requireClient$1();
	const { queryKeyStore } = requireIssuer$1();
	const DeviceFlowHandle = requireDevice_flow_handle();

	const [major, minor] = process.version
	  .slice(1)
	  .split('.')
	  .map((str) => parseInt(str, 10));

	const rsaPssParams = major >= 17 || (major === 16 && minor >= 9);
	const retryAttempt = Symbol();
	const skipNonceCheck = Symbol();
	const skipMaxAgeCheck = Symbol();

	function pickCb(input) {
	  return pick(
	    input,
	    'access_token', // OAuth 2.0
	    'code', // OAuth 2.0
	    'error_description', // OAuth 2.0
	    'error_uri', // OAuth 2.0
	    'error', // OAuth 2.0
	    'expires_in', // OAuth 2.0
	    'id_token', // OIDC Core 1.0
	    'iss', // draft-ietf-oauth-iss-auth-resp
	    'response', // FAPI JARM
	    'session_state', // OIDC Session Management
	    'state', // OAuth 2.0
	    'token_type', // OAuth 2.0
	  );
	}

	function authorizationHeaderValue(token, tokenType = 'Bearer') {
	  return `${tokenType} ${token}`;
	}

	function getSearchParams(input) {
	  const parsed = url.parse(input);
	  if (!parsed.search) return {};
	  return querystring.parse(parsed.search.substring(1));
	}

	function verifyPresence(payload, jwt, prop) {
	  if (payload[prop] === undefined) {
	    throw new RPError({
	      message: `missing required JWT property ${prop}`,
	      jwt,
	    });
	  }
	}

	function authorizationParams(params) {
	  const authParams = {
	    client_id: this.client_id,
	    scope: 'openid',
	    response_type: resolveResponseType.call(this),
	    redirect_uri: resolveRedirectUri.call(this),
	    ...params,
	  };

	  Object.entries(authParams).forEach(([key, value]) => {
	    if (value === null || value === undefined) {
	      delete authParams[key];
	    } else if (key === 'claims' && typeof value === 'object') {
	      authParams[key] = JSON.stringify(value);
	    } else if (key === 'resource' && Array.isArray(value)) {
	      authParams[key] = value;
	    } else if (typeof value !== 'string') {
	      authParams[key] = String(value);
	    }
	  });

	  return authParams;
	}

	function getKeystore(jwks) {
	  if (
	    !isPlainObject(jwks) ||
	    !Array.isArray(jwks.keys) ||
	    jwks.keys.some((k) => !isPlainObject(k) || !('kty' in k))
	  ) {
	    throw new TypeError('jwks must be a JSON Web Key Set formatted object');
	  }

	  return KeyStore.fromJWKS(jwks, { onlyPrivate: true });
	}

	// if an OP doesnt support client_secret_basic but supports client_secret_post, use it instead
	// this is in place to take care of most common pitfalls when first using discovered Issuers without
	// the support for default values defined by Discovery 1.0
	function checkBasicSupport(client, properties) {
	  try {
	    const supported = client.issuer.token_endpoint_auth_methods_supported;
	    if (!supported.includes(properties.token_endpoint_auth_method)) {
	      if (supported.includes('client_secret_post')) {
	        properties.token_endpoint_auth_method = 'client_secret_post';
	      }
	    }
	  } catch (err) {}
	}

	function handleCommonMistakes(client, metadata, properties) {
	  if (!metadata.token_endpoint_auth_method) {
	    // if no explicit value was provided
	    checkBasicSupport(client, properties);
	  }

	  // :fp: c'mon people... RTFM
	  if (metadata.redirect_uri) {
	    if (metadata.redirect_uris) {
	      throw new TypeError('provide a redirect_uri or redirect_uris, not both');
	    }
	    properties.redirect_uris = [metadata.redirect_uri];
	    delete properties.redirect_uri;
	  }

	  if (metadata.response_type) {
	    if (metadata.response_types) {
	      throw new TypeError('provide a response_type or response_types, not both');
	    }
	    properties.response_types = [metadata.response_type];
	    delete properties.response_type;
	  }
	}

	function getDefaultsForEndpoint(endpoint, issuer, properties) {
	  if (!issuer[`${endpoint}_endpoint`]) return;

	  const tokenEndpointAuthMethod = properties.token_endpoint_auth_method;
	  const tokenEndpointAuthSigningAlg = properties.token_endpoint_auth_signing_alg;

	  const eam = `${endpoint}_endpoint_auth_method`;
	  const easa = `${endpoint}_endpoint_auth_signing_alg`;

	  if (properties[eam] === undefined && properties[easa] === undefined) {
	    if (tokenEndpointAuthMethod !== undefined) {
	      properties[eam] = tokenEndpointAuthMethod;
	    }
	    if (tokenEndpointAuthSigningAlg !== undefined) {
	      properties[easa] = tokenEndpointAuthSigningAlg;
	    }
	  }
	}

	class BaseClient {
	  #metadata;
	  #issuer;
	  #aadIssValidation;
	  #additionalAuthorizedParties;
	  constructor(issuer, aadIssValidation, metadata = {}, jwks, options) {
	    this.#metadata = new Map();
	    this.#issuer = issuer;
	    this.#aadIssValidation = aadIssValidation;

	    if (typeof metadata.client_id !== 'string' || !metadata.client_id) {
	      throw new TypeError('client_id is required');
	    }

	    const properties = {
	      grant_types: ['authorization_code'],
	      id_token_signed_response_alg: 'RS256',
	      authorization_signed_response_alg: 'RS256',
	      response_types: ['code'],
	      token_endpoint_auth_method: 'client_secret_basic',
	      ...(this.fapi1()
	        ? {
	            grant_types: ['authorization_code', 'implicit'],
	            id_token_signed_response_alg: 'PS256',
	            authorization_signed_response_alg: 'PS256',
	            response_types: ['code id_token'],
	            tls_client_certificate_bound_access_tokens: true,
	            token_endpoint_auth_method: undefined,
	          }
	        : undefined),
	      ...(this.fapi2()
	        ? {
	            id_token_signed_response_alg: 'PS256',
	            authorization_signed_response_alg: 'PS256',
	            token_endpoint_auth_method: undefined,
	          }
	        : undefined),
	      ...metadata,
	    };

	    if (this.fapi()) {
	      switch (properties.token_endpoint_auth_method) {
	        case 'self_signed_tls_client_auth':
	        case 'tls_client_auth':
	          break;
	        case 'private_key_jwt':
	          if (!jwks) {
	            throw new TypeError('jwks is required');
	          }
	          break;
	        case undefined:
	          throw new TypeError('token_endpoint_auth_method is required');
	        default:
	          throw new TypeError('invalid or unsupported token_endpoint_auth_method');
	      }
	    }

	    if (this.fapi2()) {
	      if (
	        properties.tls_client_certificate_bound_access_tokens &&
	        properties.dpop_bound_access_tokens
	      ) {
	        throw new TypeError(
	          'either tls_client_certificate_bound_access_tokens or dpop_bound_access_tokens must be set to true',
	        );
	      }

	      if (
	        !properties.tls_client_certificate_bound_access_tokens &&
	        !properties.dpop_bound_access_tokens
	      ) {
	        throw new TypeError(
	          'either tls_client_certificate_bound_access_tokens or dpop_bound_access_tokens must be set to true',
	        );
	      }
	    }

	    handleCommonMistakes(this, metadata, properties);

	    assertSigningAlgValuesSupport('token', this.issuer, properties);
	    ['introspection', 'revocation'].forEach((endpoint) => {
	      getDefaultsForEndpoint(endpoint, this.issuer, properties);
	      assertSigningAlgValuesSupport(endpoint, this.issuer, properties);
	    });

	    Object.entries(properties).forEach(([key, value]) => {
	      this.#metadata.set(key, value);
	      if (!this[key]) {
	        Object.defineProperty(this, key, {
	          get() {
	            return this.#metadata.get(key);
	          },
	          enumerable: true,
	        });
	      }
	    });

	    if (jwks !== undefined) {
	      const keystore = getKeystore.call(this, jwks);
	      keystores.set(this, keystore);
	    }

	    if (options != null && options.additionalAuthorizedParties) {
	      this.#additionalAuthorizedParties = clone(options.additionalAuthorizedParties);
	    }

	    this[CLOCK_TOLERANCE] = 0;
	  }

	  authorizationUrl(params = {}) {
	    if (!isPlainObject(params)) {
	      throw new TypeError('params must be a plain object');
	    }
	    assertIssuerConfiguration(this.issuer, 'authorization_endpoint');
	    const target = new URL(this.issuer.authorization_endpoint);

	    for (const [name, value] of Object.entries(authorizationParams.call(this, params))) {
	      if (Array.isArray(value)) {
	        target.searchParams.delete(name);
	        for (const member of value) {
	          target.searchParams.append(name, member);
	        }
	      } else {
	        target.searchParams.set(name, value);
	      }
	    }

	    // TODO: is the replace needed?
	    return target.href.replace(/\+/g, '%20');
	  }

	  authorizationPost(params = {}) {
	    if (!isPlainObject(params)) {
	      throw new TypeError('params must be a plain object');
	    }
	    const inputs = authorizationParams.call(this, params);
	    const formInputs = Object.keys(inputs)
	      .map((name) => `<input type="hidden" name="${name}" value="${inputs[name]}"/>`)
	      .join('\n');

	    return `<!DOCTYPE html>
<head>
<title>Requesting Authorization</title>
</head>
<body onload="javascript:document.forms[0].submit()">
<form method="post" action="${this.issuer.authorization_endpoint}">
  ${formInputs}
</form>
</body>
</html>`;
	  }

	  endSessionUrl(params = {}) {
	    assertIssuerConfiguration(this.issuer, 'end_session_endpoint');

	    const { 0: postLogout, length } = this.post_logout_redirect_uris || [];

	    const { post_logout_redirect_uri = length === 1 ? postLogout : undefined } = params;

	    let id_token_hint;
	    ({ id_token_hint, ...params } = params);
	    if (id_token_hint instanceof TokenSet) {
	      if (!id_token_hint.id_token) {
	        throw new TypeError('id_token not present in TokenSet');
	      }
	      id_token_hint = id_token_hint.id_token;
	    }

	    const target = url.parse(this.issuer.end_session_endpoint);
	    const query = defaults(
	      getSearchParams(this.issuer.end_session_endpoint),
	      params,
	      {
	        post_logout_redirect_uri,
	        client_id: this.client_id,
	      },
	      { id_token_hint },
	    );

	    Object.entries(query).forEach(([key, value]) => {
	      if (value === null || value === undefined) {
	        delete query[key];
	      }
	    });

	    target.search = null;
	    target.query = query;

	    return url.format(target);
	  }

	  callbackParams(input) {
	    const isIncomingMessage =
	      input instanceof stdhttp.IncomingMessage || (input && input.method && input.url);
	    const isString = typeof input === 'string';

	    if (!isString && !isIncomingMessage) {
	      throw new TypeError(
	        '#callbackParams only accepts string urls, http.IncomingMessage or a lookalike',
	      );
	    }
	    if (isIncomingMessage) {
	      switch (input.method) {
	        case 'GET':
	          return pickCb(getSearchParams(input.url));
	        case 'POST':
	          if (input.body === undefined) {
	            throw new TypeError(
	              'incoming message body missing, include a body parser prior to this method call',
	            );
	          }
	          switch (typeof input.body) {
	            case 'object':
	            case 'string':
	              if (Buffer.isBuffer(input.body)) {
	                return pickCb(querystring.parse(input.body.toString('utf-8')));
	              }
	              if (typeof input.body === 'string') {
	                return pickCb(querystring.parse(input.body));
	              }

	              return pickCb(input.body);
	            default:
	              throw new TypeError('invalid IncomingMessage body object');
	          }
	        default:
	          throw new TypeError('invalid IncomingMessage method');
	      }
	    } else {
	      return pickCb(getSearchParams(input));
	    }
	  }

	  async callback(
	    redirectUri,
	    parameters,
	    checks = {},
	    { exchangeBody, clientAssertionPayload, DPoP } = {},
	  ) {
	    let params = pickCb(parameters);

	    if (checks.jarm && !('response' in parameters)) {
	      throw new RPError({
	        message: 'expected a JARM response',
	        checks,
	        params,
	      });
	    } else if ('response' in parameters) {
	      const decrypted = await this.decryptJARM(params.response);
	      params = await this.validateJARM(decrypted);
	    }

	    if (this.default_max_age && !checks.max_age) {
	      checks.max_age = this.default_max_age;
	    }

	    if (params.state && !checks.state) {
	      throw new TypeError('checks.state argument is missing');
	    }

	    if (!params.state && checks.state) {
	      throw new RPError({
	        message: 'state missing from the response',
	        checks,
	        params,
	      });
	    }

	    if (checks.state !== params.state) {
	      throw new RPError({
	        printf: ['state mismatch, expected %s, got: %s', checks.state, params.state],
	        checks,
	        params,
	      });
	    }

	    if ('iss' in params) {
	      assertIssuerConfiguration(this.issuer, 'issuer');
	      if (params.iss !== this.issuer.issuer) {
	        throw new RPError({
	          printf: ['iss mismatch, expected %s, got: %s', this.issuer.issuer, params.iss],
	          params,
	        });
	      }
	    } else if (
	      this.issuer.authorization_response_iss_parameter_supported &&
	      !('id_token' in params) &&
	      !('response' in parameters)
	    ) {
	      throw new RPError({
	        message: 'iss missing from the response',
	        params,
	      });
	    }

	    if (params.error) {
	      throw new OPError(params);
	    }

	    const RESPONSE_TYPE_REQUIRED_PARAMS = {
	      code: ['code'],
	      id_token: ['id_token'],
	      token: ['access_token', 'token_type'],
	    };

	    if (checks.response_type) {
	      for (const type of checks.response_type.split(' ')) {
	        if (type === 'none') {
	          if (params.code || params.id_token || params.access_token) {
	            throw new RPError({
	              message: 'unexpected params encountered for "none" response',
	              checks,
	              params,
	            });
	          }
	        } else {
	          for (const param of RESPONSE_TYPE_REQUIRED_PARAMS[type]) {
	            if (!params[param]) {
	              throw new RPError({
	                message: `${param} missing from response`,
	                checks,
	                params,
	              });
	            }
	          }
	        }
	      }
	    }

	    if (params.id_token) {
	      const tokenset = new TokenSet(params);
	      await this.decryptIdToken(tokenset);
	      await this.validateIdToken(
	        tokenset,
	        checks.nonce,
	        'authorization',
	        checks.max_age,
	        checks.state,
	      );

	      if (!params.code) {
	        return tokenset;
	      }
	    }

	    if (params.code) {
	      const tokenset = await this.grant(
	        {
	          ...exchangeBody,
	          grant_type: 'authorization_code',
	          code: params.code,
	          redirect_uri: redirectUri,
	          code_verifier: checks.code_verifier,
	        },
	        { clientAssertionPayload, DPoP },
	      );

	      await this.decryptIdToken(tokenset);
	      await this.validateIdToken(tokenset, checks.nonce, 'token', checks.max_age);

	      if (params.session_state) {
	        tokenset.session_state = params.session_state;
	      }

	      return tokenset;
	    }

	    return new TokenSet(params);
	  }

	  async oauthCallback(
	    redirectUri,
	    parameters,
	    checks = {},
	    { exchangeBody, clientAssertionPayload, DPoP } = {},
	  ) {
	    let params = pickCb(parameters);

	    if (checks.jarm && !('response' in parameters)) {
	      throw new RPError({
	        message: 'expected a JARM response',
	        checks,
	        params,
	      });
	    } else if ('response' in parameters) {
	      const decrypted = await this.decryptJARM(params.response);
	      params = await this.validateJARM(decrypted);
	    }

	    if (params.state && !checks.state) {
	      throw new TypeError('checks.state argument is missing');
	    }

	    if (!params.state && checks.state) {
	      throw new RPError({
	        message: 'state missing from the response',
	        checks,
	        params,
	      });
	    }

	    if (checks.state !== params.state) {
	      throw new RPError({
	        printf: ['state mismatch, expected %s, got: %s', checks.state, params.state],
	        checks,
	        params,
	      });
	    }

	    if ('iss' in params) {
	      assertIssuerConfiguration(this.issuer, 'issuer');
	      if (params.iss !== this.issuer.issuer) {
	        throw new RPError({
	          printf: ['iss mismatch, expected %s, got: %s', this.issuer.issuer, params.iss],
	          params,
	        });
	      }
	    } else if (
	      this.issuer.authorization_response_iss_parameter_supported &&
	      !('id_token' in params) &&
	      !('response' in parameters)
	    ) {
	      throw new RPError({
	        message: 'iss missing from the response',
	        params,
	      });
	    }

	    if (params.error) {
	      throw new OPError(params);
	    }

	    if (typeof params.id_token === 'string' && params.id_token.length) {
	      throw new RPError({
	        message:
	          'id_token detected in the response, you must use client.callback() instead of client.oauthCallback()',
	        params,
	      });
	    }
	    delete params.id_token;

	    const RESPONSE_TYPE_REQUIRED_PARAMS = {
	      code: ['code'],
	      token: ['access_token', 'token_type'],
	    };

	    if (checks.response_type) {
	      for (const type of checks.response_type.split(' ')) {
	        if (type === 'none') {
	          if (params.code || params.id_token || params.access_token) {
	            throw new RPError({
	              message: 'unexpected params encountered for "none" response',
	              checks,
	              params,
	            });
	          }
	        }

	        if (RESPONSE_TYPE_REQUIRED_PARAMS[type]) {
	          for (const param of RESPONSE_TYPE_REQUIRED_PARAMS[type]) {
	            if (!params[param]) {
	              throw new RPError({
	                message: `${param} missing from response`,
	                checks,
	                params,
	              });
	            }
	          }
	        }
	      }
	    }

	    if (params.code) {
	      const tokenset = await this.grant(
	        {
	          ...exchangeBody,
	          grant_type: 'authorization_code',
	          code: params.code,
	          redirect_uri: redirectUri,
	          code_verifier: checks.code_verifier,
	        },
	        { clientAssertionPayload, DPoP },
	      );

	      if (typeof tokenset.id_token === 'string' && tokenset.id_token.length) {
	        throw new RPError({
	          message:
	            'id_token detected in the response, you must use client.callback() instead of client.oauthCallback()',
	          params,
	        });
	      }
	      delete tokenset.id_token;

	      return tokenset;
	    }

	    return new TokenSet(params);
	  }

	  async decryptIdToken(token) {
	    if (!this.id_token_encrypted_response_alg) {
	      return token;
	    }

	    let idToken = token;

	    if (idToken instanceof TokenSet) {
	      if (!idToken.id_token) {
	        throw new TypeError('id_token not present in TokenSet');
	      }
	      idToken = idToken.id_token;
	    }

	    const expectedAlg = this.id_token_encrypted_response_alg;
	    const expectedEnc = this.id_token_encrypted_response_enc;

	    const result = await this.decryptJWE(idToken, expectedAlg, expectedEnc);

	    if (token instanceof TokenSet) {
	      token.id_token = result;
	      return token;
	    }

	    return result;
	  }

	  async validateJWTUserinfo(body) {
	    const expectedAlg = this.userinfo_signed_response_alg;

	    return this.validateJWT(body, expectedAlg, []);
	  }

	  async decryptJARM(response) {
	    if (!this.authorization_encrypted_response_alg) {
	      return response;
	    }

	    const expectedAlg = this.authorization_encrypted_response_alg;
	    const expectedEnc = this.authorization_encrypted_response_enc;

	    return this.decryptJWE(response, expectedAlg, expectedEnc);
	  }

	  async decryptJWTUserinfo(body) {
	    if (!this.userinfo_encrypted_response_alg) {
	      return body;
	    }

	    const expectedAlg = this.userinfo_encrypted_response_alg;
	    const expectedEnc = this.userinfo_encrypted_response_enc;

	    return this.decryptJWE(body, expectedAlg, expectedEnc);
	  }

	  async decryptJWE(jwe, expectedAlg, expectedEnc = 'A128CBC-HS256') {
	    const header = JSON.parse(base64url.decode(jwe.split('.')[0]));

	    if (header.alg !== expectedAlg) {
	      throw new RPError({
	        printf: ['unexpected JWE alg received, expected %s, got: %s', expectedAlg, header.alg],
	        jwt: jwe,
	      });
	    }

	    if (header.enc !== expectedEnc) {
	      throw new RPError({
	        printf: ['unexpected JWE enc received, expected %s, got: %s', expectedEnc, header.enc],
	        jwt: jwe,
	      });
	    }

	    const getPlaintext = (result) => new TextDecoder().decode(result.plaintext);
	    let plaintext;
	    if (expectedAlg.match(/^(?:RSA|ECDH)/)) {
	      const keystore = await keystores.get(this);

	      const protectedHeader = jose.decodeProtectedHeader(jwe);

	      for (const key of keystore.all({
	        ...protectedHeader,
	        use: 'enc',
	      })) {
	        plaintext = await jose
	          .compactDecrypt(jwe, await key.keyObject(protectedHeader.alg))
	          .then(getPlaintext, () => {});
	        if (plaintext) break;
	      }
	    } else {
	      plaintext = await jose
	        .compactDecrypt(jwe, this.secretForAlg(expectedAlg === 'dir' ? expectedEnc : expectedAlg))
	        .then(getPlaintext, () => {});
	    }

	    if (!plaintext) {
	      throw new RPError({
	        message: 'failed to decrypt JWE',
	        jwt: jwe,
	      });
	    }
	    return plaintext;
	  }

	  async validateIdToken(tokenSet, nonce, returnedBy, maxAge, state) {
	    let idToken = tokenSet;

	    const expectedAlg = this.id_token_signed_response_alg;

	    const isTokenSet = idToken instanceof TokenSet;

	    if (isTokenSet) {
	      if (!idToken.id_token) {
	        throw new TypeError('id_token not present in TokenSet');
	      }
	      idToken = idToken.id_token;
	    }

	    idToken = String(idToken);

	    const timestamp = now();
	    const { protected: header, payload, key } = await this.validateJWT(idToken, expectedAlg);

	    if (typeof maxAge === 'number' || (maxAge !== skipMaxAgeCheck && this.require_auth_time)) {
	      if (!payload.auth_time) {
	        throw new RPError({
	          message: 'missing required JWT property auth_time',
	          jwt: idToken,
	        });
	      }
	      if (typeof payload.auth_time !== 'number') {
	        throw new RPError({
	          message: 'JWT auth_time claim must be a JSON numeric value',
	          jwt: idToken,
	        });
	      }
	    }

	    if (
	      typeof maxAge === 'number' &&
	      payload.auth_time + maxAge < timestamp - this[CLOCK_TOLERANCE]
	    ) {
	      throw new RPError({
	        printf: [
	          'too much time has elapsed since the last End-User authentication, max_age %i, auth_time: %i, now %i',
	          maxAge,
	          payload.auth_time,
	          timestamp - this[CLOCK_TOLERANCE],
	        ],
	        now: timestamp,
	        tolerance: this[CLOCK_TOLERANCE],
	        auth_time: payload.auth_time,
	        jwt: idToken,
	      });
	    }

	    if (
	      nonce !== skipNonceCheck &&
	      (payload.nonce || nonce !== undefined) &&
	      payload.nonce !== nonce
	    ) {
	      throw new RPError({
	        printf: ['nonce mismatch, expected %s, got: %s', nonce, payload.nonce],
	        jwt: idToken,
	      });
	    }

	    if (returnedBy === 'authorization') {
	      if (!payload.at_hash && tokenSet.access_token) {
	        throw new RPError({
	          message: 'missing required property at_hash',
	          jwt: idToken,
	        });
	      }

	      if (!payload.c_hash && tokenSet.code) {
	        throw new RPError({
	          message: 'missing required property c_hash',
	          jwt: idToken,
	        });
	      }

	      if (this.fapi1()) {
	        if (!payload.s_hash && (tokenSet.state || state)) {
	          throw new RPError({
	            message: 'missing required property s_hash',
	            jwt: idToken,
	          });
	        }
	      }

	      if (payload.s_hash) {
	        if (!state) {
	          throw new TypeError('cannot verify s_hash, "checks.state" property not provided');
	        }

	        try {
	          tokenHash.validate(
	            { claim: 's_hash', source: 'state' },
	            payload.s_hash,
	            state,
	            header.alg,
	            key.jwk && key.jwk.crv,
	          );
	        } catch (err) {
	          throw new RPError({ message: err.message, jwt: idToken });
	        }
	      }
	    }

	    if (this.fapi() && payload.iat < timestamp - 3600) {
	      throw new RPError({
	        printf: ['JWT issued too far in the past, now %i, iat %i', timestamp, payload.iat],
	        now: timestamp,
	        tolerance: this[CLOCK_TOLERANCE],
	        iat: payload.iat,
	        jwt: idToken,
	      });
	    }

	    if (tokenSet.access_token && payload.at_hash !== undefined) {
	      try {
	        tokenHash.validate(
	          { claim: 'at_hash', source: 'access_token' },
	          payload.at_hash,
	          tokenSet.access_token,
	          header.alg,
	          key.jwk && key.jwk.crv,
	        );
	      } catch (err) {
	        throw new RPError({ message: err.message, jwt: idToken });
	      }
	    }

	    if (tokenSet.code && payload.c_hash !== undefined) {
	      try {
	        tokenHash.validate(
	          { claim: 'c_hash', source: 'code' },
	          payload.c_hash,
	          tokenSet.code,
	          header.alg,
	          key.jwk && key.jwk.crv,
	        );
	      } catch (err) {
	        throw new RPError({ message: err.message, jwt: idToken });
	      }
	    }

	    return tokenSet;
	  }

	  async validateJWT(jwt, expectedAlg, required = ['iss', 'sub', 'aud', 'exp', 'iat']) {
	    const isSelfIssued = this.issuer.issuer === 'https://self-issued.me';
	    const timestamp = now();
	    let header;
	    let payload;
	    try {
	      ({ header, payload } = decodeJWT(jwt, { complete: true }));
	    } catch (err) {
	      throw new RPError({
	        printf: ['failed to decode JWT (%s: %s)', err.name, err.message],
	        jwt,
	      });
	    }

	    if (header.alg !== expectedAlg) {
	      throw new RPError({
	        printf: ['unexpected JWT alg received, expected %s, got: %s', expectedAlg, header.alg],
	        jwt,
	      });
	    }

	    if (isSelfIssued) {
	      required = [...required, 'sub_jwk'];
	    }

	    required.forEach(verifyPresence.bind(undefined, payload, jwt));

	    if (payload.iss !== undefined) {
	      let expectedIss = this.issuer.issuer;

	      if (this.#aadIssValidation) {
	        expectedIss = this.issuer.issuer.replace('{tenantid}', payload.tid);
	      }

	      if (payload.iss !== expectedIss) {
	        throw new RPError({
	          printf: ['unexpected iss value, expected %s, got: %s', expectedIss, payload.iss],
	          jwt,
	        });
	      }
	    }

	    if (payload.iat !== undefined) {
	      if (typeof payload.iat !== 'number') {
	        throw new RPError({
	          message: 'JWT iat claim must be a JSON numeric value',
	          jwt,
	        });
	      }
	    }

	    if (payload.nbf !== undefined) {
	      if (typeof payload.nbf !== 'number') {
	        throw new RPError({
	          message: 'JWT nbf claim must be a JSON numeric value',
	          jwt,
	        });
	      }
	      if (payload.nbf > timestamp + this[CLOCK_TOLERANCE]) {
	        throw new RPError({
	          printf: [
	            'JWT not active yet, now %i, nbf %i',
	            timestamp + this[CLOCK_TOLERANCE],
	            payload.nbf,
	          ],
	          now: timestamp,
	          tolerance: this[CLOCK_TOLERANCE],
	          nbf: payload.nbf,
	          jwt,
	        });
	      }
	    }

	    if (payload.exp !== undefined) {
	      if (typeof payload.exp !== 'number') {
	        throw new RPError({
	          message: 'JWT exp claim must be a JSON numeric value',
	          jwt,
	        });
	      }
	      if (timestamp - this[CLOCK_TOLERANCE] >= payload.exp) {
	        throw new RPError({
	          printf: ['JWT expired, now %i, exp %i', timestamp - this[CLOCK_TOLERANCE], payload.exp],
	          now: timestamp,
	          tolerance: this[CLOCK_TOLERANCE],
	          exp: payload.exp,
	          jwt,
	        });
	      }
	    }

	    if (payload.aud !== undefined) {
	      if (Array.isArray(payload.aud)) {
	        if (payload.aud.length > 1 && !payload.azp) {
	          throw new RPError({
	            message: 'missing required JWT property azp',
	            jwt,
	          });
	        }

	        if (!payload.aud.includes(this.client_id)) {
	          throw new RPError({
	            printf: [
	              'aud is missing the client_id, expected %s to be included in %j',
	              this.client_id,
	              payload.aud,
	            ],
	            jwt,
	          });
	        }
	      } else if (payload.aud !== this.client_id) {
	        throw new RPError({
	          printf: ['aud mismatch, expected %s, got: %s', this.client_id, payload.aud],
	          jwt,
	        });
	      }
	    }

	    if (payload.azp !== undefined) {
	      let additionalAuthorizedParties = this.#additionalAuthorizedParties;

	      if (typeof additionalAuthorizedParties === 'string') {
	        additionalAuthorizedParties = [this.client_id, additionalAuthorizedParties];
	      } else if (Array.isArray(additionalAuthorizedParties)) {
	        additionalAuthorizedParties = [this.client_id, ...additionalAuthorizedParties];
	      } else {
	        additionalAuthorizedParties = [this.client_id];
	      }

	      if (!additionalAuthorizedParties.includes(payload.azp)) {
	        throw new RPError({
	          printf: ['azp mismatch, got: %s', payload.azp],
	          jwt,
	        });
	      }
	    }

	    let keys;

	    if (isSelfIssued) {
	      try {
	        assert(isPlainObject(payload.sub_jwk));
	        const key = await jose.importJWK(payload.sub_jwk, header.alg);
	        assert.equal(key.type, 'public');
	        keys = [
	          {
	            keyObject() {
	              return key;
	            },
	          },
	        ];
	      } catch (err) {
	        throw new RPError({
	          message: 'failed to use sub_jwk claim as an asymmetric JSON Web Key',
	          jwt,
	        });
	      }
	      if ((await jose.calculateJwkThumbprint(payload.sub_jwk)) !== payload.sub) {
	        throw new RPError({
	          message: 'failed to match the subject with sub_jwk',
	          jwt,
	        });
	      }
	    } else if (header.alg.startsWith('HS')) {
	      keys = [this.secretForAlg(header.alg)];
	    } else if (header.alg !== 'none') {
	      keys = await queryKeyStore.call(this.issuer, { ...header, use: 'sig' });
	    }

	    if (!keys && header.alg === 'none') {
	      return { protected: header, payload };
	    }

	    for (const key of keys) {
	      const verified = await jose
	        .compactVerify(jwt, key instanceof Uint8Array ? key : await key.keyObject(header.alg))
	        .catch(() => {});
	      if (verified) {
	        return {
	          payload,
	          protected: verified.protectedHeader,
	          key,
	        };
	      }
	    }

	    throw new RPError({
	      message: 'failed to validate JWT signature',
	      jwt,
	    });
	  }

	  async refresh(refreshToken, { exchangeBody, clientAssertionPayload, DPoP } = {}) {
	    let token = refreshToken;

	    if (token instanceof TokenSet) {
	      if (!token.refresh_token) {
	        throw new TypeError('refresh_token not present in TokenSet');
	      }
	      token = token.refresh_token;
	    }

	    const tokenset = await this.grant(
	      {
	        ...exchangeBody,
	        grant_type: 'refresh_token',
	        refresh_token: String(token),
	      },
	      { clientAssertionPayload, DPoP },
	    );

	    if (tokenset.id_token) {
	      await this.decryptIdToken(tokenset);
	      await this.validateIdToken(tokenset, skipNonceCheck, 'token', skipMaxAgeCheck);

	      if (refreshToken instanceof TokenSet && refreshToken.id_token) {
	        const expectedSub = refreshToken.claims().sub;
	        const actualSub = tokenset.claims().sub;
	        if (actualSub !== expectedSub) {
	          throw new RPError({
	            printf: ['sub mismatch, expected %s, got: %s', expectedSub, actualSub],
	            jwt: tokenset.id_token,
	          });
	        }
	      }
	    }

	    return tokenset;
	  }

	  async requestResource(
	    resourceUrl,
	    accessToken,
	    {
	      method,
	      headers,
	      body,
	      DPoP,
	      tokenType = DPoP
	        ? 'DPoP'
	        : accessToken instanceof TokenSet
	        ? accessToken.token_type
	        : 'Bearer',
	    } = {},
	    retry,
	  ) {
	    if (accessToken instanceof TokenSet) {
	      if (!accessToken.access_token) {
	        throw new TypeError('access_token not present in TokenSet');
	      }
	      accessToken = accessToken.access_token;
	    }

	    if (!accessToken) {
	      throw new TypeError('no access token provided');
	    } else if (typeof accessToken !== 'string') {
	      throw new TypeError('invalid access token provided');
	    }

	    const requestOpts = {
	      headers: {
	        Authorization: authorizationHeaderValue(accessToken, tokenType),
	        ...headers,
	      },
	      body,
	    };

	    const mTLS = !!this.tls_client_certificate_bound_access_tokens;

	    const response = await request.call(
	      this,
	      {
	        ...requestOpts,
	        responseType: 'buffer',
	        method,
	        url: resourceUrl,
	      },
	      { accessToken, mTLS, DPoP },
	    );

	    const wwwAuthenticate = response.headers['www-authenticate'];
	    if (
	      retry !== retryAttempt &&
	      wwwAuthenticate &&
	      wwwAuthenticate.toLowerCase().startsWith('dpop ') &&
	      parseWwwAuthenticate(wwwAuthenticate).error === 'use_dpop_nonce'
	    ) {
	      return this.requestResource(resourceUrl, accessToken, {
	        method,
	        headers,
	        body,
	        DPoP,
	        tokenType,
	      });
	    }

	    return response;
	  }

	  async userinfo(accessToken, { method = 'GET', via = 'header', tokenType, params, DPoP } = {}) {
	    assertIssuerConfiguration(this.issuer, 'userinfo_endpoint');
	    const options = {
	      tokenType,
	      method: String(method).toUpperCase(),
	      DPoP,
	    };

	    if (options.method !== 'GET' && options.method !== 'POST') {
	      throw new TypeError('#userinfo() method can only be POST or a GET');
	    }

	    if (via === 'body' && options.method !== 'POST') {
	      throw new TypeError('can only send body on POST');
	    }

	    const jwt = !!(this.userinfo_signed_response_alg || this.userinfo_encrypted_response_alg);

	    if (jwt) {
	      options.headers = { Accept: 'application/jwt' };
	    } else {
	      options.headers = { Accept: 'application/json' };
	    }
	    const mTLS = !!this.tls_client_certificate_bound_access_tokens;

	    let targetUrl;
	    if (mTLS && this.issuer.mtls_endpoint_aliases) {
	      targetUrl = this.issuer.mtls_endpoint_aliases.userinfo_endpoint;
	    }

	    targetUrl = new URL(targetUrl || this.issuer.userinfo_endpoint);

	    if (via === 'body') {
	      options.headers.Authorization = undefined;
	      options.headers['Content-Type'] = 'application/x-www-form-urlencoded';
	      options.body = new URLSearchParams();
	      options.body.append(
	        'access_token',
	        accessToken instanceof TokenSet ? accessToken.access_token : accessToken,
	      );
	    }

	    // handle additional parameters, GET via querystring, POST via urlencoded body
	    if (params) {
	      if (options.method === 'GET') {
	        Object.entries(params).forEach(([key, value]) => {
	          targetUrl.searchParams.append(key, value);
	        });
	      } else if (options.body) {
	        // POST && via body
	        Object.entries(params).forEach(([key, value]) => {
	          options.body.append(key, value);
	        });
	      } else {
	        // POST && via header
	        options.body = new URLSearchParams();
	        options.headers['Content-Type'] = 'application/x-www-form-urlencoded';
	        Object.entries(params).forEach(([key, value]) => {
	          options.body.append(key, value);
	        });
	      }
	    }

	    if (options.body) {
	      options.body = options.body.toString();
	    }

	    const response = await this.requestResource(targetUrl, accessToken, options);

	    let parsed = processResponse(response, { bearer: true });

	    if (jwt) {
	      if (!/^application\/jwt/.test(response.headers['content-type'])) {
	        throw new RPError({
	          message: 'expected application/jwt response from the userinfo_endpoint',
	          response,
	        });
	      }

	      const body = response.body.toString();
	      const userinfo = await this.decryptJWTUserinfo(body);
	      if (!this.userinfo_signed_response_alg) {
	        try {
	          parsed = JSON.parse(userinfo);
	          assert(isPlainObject(parsed));
	        } catch (err) {
	          throw new RPError({
	            message: 'failed to parse userinfo JWE payload as JSON',
	            jwt: userinfo,
	          });
	        }
	      } else {
	        ({ payload: parsed } = await this.validateJWTUserinfo(userinfo));
	      }
	    } else {
	      try {
	        parsed = JSON.parse(response.body);
	      } catch (err) {
	        Object.defineProperty(err, 'response', { value: response });
	        throw err;
	      }
	    }

	    if (accessToken instanceof TokenSet && accessToken.id_token) {
	      const expectedSub = accessToken.claims().sub;
	      if (parsed.sub !== expectedSub) {
	        throw new RPError({
	          printf: ['userinfo sub mismatch, expected %s, got: %s', expectedSub, parsed.sub],
	          body: parsed,
	          jwt: accessToken.id_token,
	        });
	      }
	    }

	    return parsed;
	  }

	  encryptionSecret(len) {
	    const hash = len <= 256 ? 'sha256' : len <= 384 ? 'sha384' : len <= 512 ? 'sha512' : false;
	    if (!hash) {
	      throw new Error('unsupported symmetric encryption key derivation');
	    }

	    return crypto
	      .createHash(hash)
	      .update(this.client_secret)
	      .digest()
	      .slice(0, len / 8);
	  }

	  secretForAlg(alg) {
	    if (!this.client_secret) {
	      throw new TypeError('client_secret is required');
	    }

	    if (/^A(\d{3})(?:GCM)?KW$/.test(alg)) {
	      return this.encryptionSecret(parseInt(RegExp.$1, 10));
	    }

	    if (/^A(\d{3})(?:GCM|CBC-HS(\d{3}))$/.test(alg)) {
	      return this.encryptionSecret(parseInt(RegExp.$2 || RegExp.$1, 10));
	    }

	    return new TextEncoder().encode(this.client_secret);
	  }

	  async grant(body, { clientAssertionPayload, DPoP } = {}, retry) {
	    assertIssuerConfiguration(this.issuer, 'token_endpoint');
	    const response = await authenticatedPost.call(
	      this,
	      'token',
	      {
	        form: body,
	        responseType: 'json',
	      },
	      { clientAssertionPayload, DPoP },
	    );
	    let responseBody;
	    try {
	      responseBody = processResponse(response);
	    } catch (err) {
	      if (retry !== retryAttempt && err instanceof OPError && err.error === 'use_dpop_nonce') {
	        return this.grant(body, { clientAssertionPayload, DPoP }, retryAttempt);
	      }
	      throw err;
	    }

	    return new TokenSet(responseBody);
	  }

	  async deviceAuthorization(params = {}, { exchangeBody, clientAssertionPayload, DPoP } = {}) {
	    assertIssuerConfiguration(this.issuer, 'device_authorization_endpoint');
	    assertIssuerConfiguration(this.issuer, 'token_endpoint');

	    const body = authorizationParams.call(this, {
	      client_id: this.client_id,
	      redirect_uri: null,
	      response_type: null,
	      ...params,
	    });

	    const response = await authenticatedPost.call(
	      this,
	      'device_authorization',
	      {
	        responseType: 'json',
	        form: body,
	      },
	      { clientAssertionPayload, endpointAuthMethod: 'token' },
	    );
	    const responseBody = processResponse(response);

	    return new DeviceFlowHandle({
	      client: this,
	      exchangeBody,
	      clientAssertionPayload,
	      response: responseBody,
	      maxAge: params.max_age,
	      DPoP,
	    });
	  }

	  async revoke(token, hint, { revokeBody, clientAssertionPayload } = {}) {
	    assertIssuerConfiguration(this.issuer, 'revocation_endpoint');
	    if (hint !== undefined && typeof hint !== 'string') {
	      throw new TypeError('hint must be a string');
	    }

	    const form = { ...revokeBody, token };

	    if (hint) {
	      form.token_type_hint = hint;
	    }

	    const response = await authenticatedPost.call(
	      this,
	      'revocation',
	      {
	        form,
	      },
	      { clientAssertionPayload },
	    );
	    processResponse(response, { body: false });
	  }

	  async introspect(token, hint, { introspectBody, clientAssertionPayload } = {}) {
	    assertIssuerConfiguration(this.issuer, 'introspection_endpoint');
	    if (hint !== undefined && typeof hint !== 'string') {
	      throw new TypeError('hint must be a string');
	    }

	    const form = { ...introspectBody, token };
	    if (hint) {
	      form.token_type_hint = hint;
	    }

	    const response = await authenticatedPost.call(
	      this,
	      'introspection',
	      { form, responseType: 'json' },
	      { clientAssertionPayload },
	    );

	    const responseBody = processResponse(response);

	    return responseBody;
	  }

	  static async register(metadata, options = {}) {
	    const { initialAccessToken, jwks, ...clientOptions } = options;

	    assertIssuerConfiguration(this.issuer, 'registration_endpoint');

	    if (jwks !== undefined && !(metadata.jwks || metadata.jwks_uri)) {
	      const keystore = await getKeystore.call(this, jwks);
	      metadata.jwks = keystore.toJWKS();
	    }

	    const response = await request.call(this, {
	      headers: {
	        Accept: 'application/json',
	        ...(initialAccessToken
	          ? {
	              Authorization: authorizationHeaderValue(initialAccessToken),
	            }
	          : undefined),
	      },
	      responseType: 'json',
	      json: metadata,
	      url: this.issuer.registration_endpoint,
	      method: 'POST',
	    });
	    const responseBody = processResponse(response, { statusCode: 201, bearer: true });

	    return new this(responseBody, jwks, clientOptions);
	  }

	  get metadata() {
	    return clone(Object.fromEntries(this.#metadata.entries()));
	  }

	  static async fromUri(registrationClientUri, registrationAccessToken, jwks, clientOptions) {
	    const response = await request.call(this, {
	      method: 'GET',
	      url: registrationClientUri,
	      responseType: 'json',
	      headers: {
	        Authorization: authorizationHeaderValue(registrationAccessToken),
	        Accept: 'application/json',
	      },
	    });
	    const responseBody = processResponse(response, { bearer: true });

	    return new this(responseBody, jwks, clientOptions);
	  }

	  async requestObject(
	    requestObject = {},
	    {
	      sign: signingAlgorithm = this.request_object_signing_alg || 'none',
	      encrypt: {
	        alg: eKeyManagement = this.request_object_encryption_alg,
	        enc: eContentEncryption = this.request_object_encryption_enc || 'A128CBC-HS256',
	      } = {},
	    } = {},
	  ) {
	    if (!isPlainObject(requestObject)) {
	      throw new TypeError('requestObject must be a plain object');
	    }

	    let signed;
	    let key;
	    const unix = now();
	    const header = { alg: signingAlgorithm, typ: 'oauth-authz-req+jwt' };
	    const payload = JSON.stringify(
	      defaults({}, requestObject, {
	        iss: this.client_id,
	        aud: this.issuer.issuer,
	        client_id: this.client_id,
	        jti: random(),
	        iat: unix,
	        exp: unix + 300,
	        ...(this.fapi() ? { nbf: unix } : undefined),
	      }),
	    );
	    if (signingAlgorithm === 'none') {
	      signed = [base64url.encode(JSON.stringify(header)), base64url.encode(payload), ''].join('.');
	    } else {
	      const symmetric = signingAlgorithm.startsWith('HS');
	      if (symmetric) {
	        key = this.secretForAlg(signingAlgorithm);
	      } else {
	        const keystore = await keystores.get(this);

	        if (!keystore) {
	          throw new TypeError(
	            `no keystore present for client, cannot sign using alg ${signingAlgorithm}`,
	          );
	        }
	        key = keystore.get({ alg: signingAlgorithm, use: 'sig' });
	        if (!key) {
	          throw new TypeError(`no key to sign with found for alg ${signingAlgorithm}`);
	        }
	      }

	      signed = await new jose.CompactSign(new TextEncoder().encode(payload))
	        .setProtectedHeader({
	          ...header,
	          kid: symmetric ? undefined : key.jwk.kid,
	        })
	        .sign(symmetric ? key : await key.keyObject(signingAlgorithm));
	    }

	    if (!eKeyManagement) {
	      return signed;
	    }

	    const fields = { alg: eKeyManagement, enc: eContentEncryption, cty: 'oauth-authz-req+jwt' };

	    if (fields.alg.match(/^(RSA|ECDH)/)) {
	      [key] = await queryKeyStore.call(
	        this.issuer,
	        { alg: fields.alg, use: 'enc' },
	        { allowMulti: true },
	      );
	    } else {
	      key = this.secretForAlg(fields.alg === 'dir' ? fields.enc : fields.alg);
	    }

	    return new jose.CompactEncrypt(new TextEncoder().encode(signed))
	      .setProtectedHeader({
	        ...fields,
	        kid: key instanceof Uint8Array ? undefined : key.jwk.kid,
	      })
	      .encrypt(key instanceof Uint8Array ? key : await key.keyObject(fields.alg));
	  }

	  async pushedAuthorizationRequest(params = {}, { clientAssertionPayload } = {}) {
	    assertIssuerConfiguration(this.issuer, 'pushed_authorization_request_endpoint');

	    const body = {
	      ...('request' in params ? params : authorizationParams.call(this, params)),
	      client_id: this.client_id,
	    };

	    const response = await authenticatedPost.call(
	      this,
	      'pushed_authorization_request',
	      {
	        responseType: 'json',
	        form: body,
	      },
	      { clientAssertionPayload, endpointAuthMethod: 'token' },
	    );
	    const responseBody = processResponse(response, { statusCode: 201 });

	    if (!('expires_in' in responseBody)) {
	      throw new RPError({
	        message: 'expected expires_in in Pushed Authorization Successful Response',
	        response,
	      });
	    }
	    if (typeof responseBody.expires_in !== 'number') {
	      throw new RPError({
	        message: 'invalid expires_in value in Pushed Authorization Successful Response',
	        response,
	      });
	    }
	    if (!('request_uri' in responseBody)) {
	      throw new RPError({
	        message: 'expected request_uri in Pushed Authorization Successful Response',
	        response,
	      });
	    }
	    if (typeof responseBody.request_uri !== 'string') {
	      throw new RPError({
	        message: 'invalid request_uri value in Pushed Authorization Successful Response',
	        response,
	      });
	    }

	    return responseBody;
	  }

	  get issuer() {
	    return this.#issuer;
	  }

	  /* istanbul ignore next */
	  [inspect.custom]() {
	    return `${this.constructor.name} ${inspect(this.metadata, {
	      depth: Infinity,
	      colors: process.stdout.isTTY,
	      compact: false,
	      sorted: true,
	    })}`;
	  }

	  fapi() {
	    return this.fapi1() || this.fapi2();
	  }

	  fapi1() {
	    return this.constructor.name === 'FAPI1Client';
	  }

	  fapi2() {
	    return this.constructor.name === 'FAPI2Client';
	  }

	  async validateJARM(response) {
	    const expectedAlg = this.authorization_signed_response_alg;
	    const { payload } = await this.validateJWT(response, expectedAlg, ['iss', 'exp', 'aud']);
	    return pickCb(payload);
	  }

	  /**
	   * @name dpopProof
	   * @api private
	   */
	  async dpopProof(payload, privateKeyInput, accessToken) {
	    if (!isPlainObject(payload)) {
	      throw new TypeError('payload must be a plain object');
	    }

	    let privateKey;
	    if (isKeyObject(privateKeyInput)) {
	      privateKey = privateKeyInput;
	    } else if (privateKeyInput[Symbol.toStringTag] === 'CryptoKey') {
	      privateKey = privateKeyInput;
	    } else if (jose.cryptoRuntime === 'node:crypto') {
	      privateKey = crypto.createPrivateKey(privateKeyInput);
	    } else {
	      throw new TypeError('unrecognized crypto runtime');
	    }

	    if (privateKey.type !== 'private') {
	      throw new TypeError('"DPoP" option must be a private key');
	    }
	    let alg = determineDPoPAlgorithm.call(this, privateKey, privateKeyInput);

	    if (!alg) {
	      throw new TypeError('could not determine DPoP JWS Algorithm');
	    }

	    return new jose.SignJWT({
	      ath: accessToken
	        ? base64url.encode(crypto.createHash('sha256').update(accessToken).digest())
	        : undefined,
	      ...payload,
	    })
	      .setProtectedHeader({
	        alg,
	        typ: 'dpop+jwt',
	        jwk: await getJwk(privateKey, privateKeyInput),
	      })
	      .setIssuedAt()
	      .setJti(random())
	      .sign(privateKey);
	  }
	}

	function determineDPoPAlgorithmFromCryptoKey(cryptoKey) {
	  switch (cryptoKey.algorithm.name) {
	    case 'Ed25519':
	    case 'Ed448':
	      return 'EdDSA';
	    case 'ECDSA': {
	      switch (cryptoKey.algorithm.namedCurve) {
	        case 'P-256':
	          return 'ES256';
	        case 'P-384':
	          return 'ES384';
	        case 'P-521':
	          return 'ES512';
	      }
	      break;
	    }
	    case 'RSASSA-PKCS1-v1_5':
	      return `RS${cryptoKey.algorithm.hash.name.slice(4)}`;
	    case 'RSA-PSS':
	      return `PS${cryptoKey.algorithm.hash.name.slice(4)}`;
	    default:
	      throw new TypeError('unsupported DPoP private key');
	  }
	}

	let determineDPoPAlgorithm;
	if (jose.cryptoRuntime === 'node:crypto') {
	  determineDPoPAlgorithm = function (privateKey, privateKeyInput) {
	    if (privateKeyInput[Symbol.toStringTag] === 'CryptoKey') {
	      return determineDPoPAlgorithmFromCryptoKey(privateKey);
	    }

	    switch (privateKey.asymmetricKeyType) {
	      case 'ed25519':
	      case 'ed448':
	        return 'EdDSA';
	      case 'ec':
	        return determineEcAlgorithm(privateKey, privateKeyInput);
	      case 'rsa':
	      case rsaPssParams && 'rsa-pss':
	        return determineRsaAlgorithm(
	          privateKey,
	          privateKeyInput,
	          this.issuer.dpop_signing_alg_values_supported,
	        );
	      default:
	        throw new TypeError('unsupported DPoP private key');
	    }
	  };

	  const RSPS = /^(?:RS|PS)(?:256|384|512)$/;
	  function determineRsaAlgorithm(privateKey, privateKeyInput, valuesSupported) {
	    if (
	      typeof privateKeyInput === 'object' &&
	      privateKeyInput.format === 'jwk' &&
	      privateKeyInput.key &&
	      privateKeyInput.key.alg
	    ) {
	      return privateKeyInput.key.alg;
	    }

	    if (Array.isArray(valuesSupported)) {
	      let candidates = valuesSupported.filter(RegExp.prototype.test.bind(RSPS));
	      if (privateKey.asymmetricKeyType === 'rsa-pss') {
	        candidates = candidates.filter((value) => value.startsWith('PS'));
	      }
	      return ['PS256', 'PS384', 'PS512', 'RS256', 'RS384', 'RS384'].find((preferred) =>
	        candidates.includes(preferred),
	      );
	    }

	    return 'PS256';
	  }

	  const p256 = Buffer.from([42, 134, 72, 206, 61, 3, 1, 7]);
	  const p384 = Buffer.from([43, 129, 4, 0, 34]);
	  const p521 = Buffer.from([43, 129, 4, 0, 35]);
	  const secp256k1 = Buffer.from([43, 129, 4, 0, 10]);

	  function determineEcAlgorithm(privateKey, privateKeyInput) {
	    // If input was a JWK
	    switch (
	      typeof privateKeyInput === 'object' &&
	      typeof privateKeyInput.key === 'object' &&
	      privateKeyInput.key.crv
	    ) {
	      case 'P-256':
	        return 'ES256';
	      case 'secp256k1':
	        return 'ES256K';
	      case 'P-384':
	        return 'ES384';
	      case 'P-512':
	        return 'ES512';
	    }

	    const buf = privateKey.export({ format: 'der', type: 'pkcs8' });
	    const i = buf[1] < 128 ? 17 : 18;
	    const len = buf[i];
	    const curveOid = buf.slice(i + 1, i + 1 + len);
	    if (curveOid.equals(p256)) {
	      return 'ES256';
	    }

	    if (curveOid.equals(p384)) {
	      return 'ES384';
	    }
	    if (curveOid.equals(p521)) {
	      return 'ES512';
	    }

	    if (curveOid.equals(secp256k1)) {
	      return 'ES256K';
	    }

	    throw new TypeError('unsupported DPoP private key curve');
	  }
	} else {
	  determineDPoPAlgorithm = determineDPoPAlgorithmFromCryptoKey;
	}

	const jwkCache = new WeakMap();
	async function getJwk(keyObject, privateKeyInput) {
	  if (
	    jose.cryptoRuntime === 'node:crypto' &&
	    typeof privateKeyInput === 'object' &&
	    typeof privateKeyInput.key === 'object' &&
	    privateKeyInput.format === 'jwk'
	  ) {
	    return pick(privateKeyInput.key, 'kty', 'crv', 'x', 'y', 'e', 'n');
	  }

	  if (jwkCache.has(privateKeyInput)) {
	    return jwkCache.get(privateKeyInput);
	  }

	  const jwk = pick(await jose.exportJWK(keyObject), 'kty', 'crv', 'x', 'y', 'e', 'n');

	  if (isKeyObject(privateKeyInput) || jose.cryptoRuntime === 'WebCryptoAPI') {
	    jwkCache.set(privateKeyInput, jwk);
	  }

	  return jwk;
	}

	client$1.exports = (issuer, aadIssValidation = false) =>
	  class Client extends BaseClient {
	    constructor(...args) {
	      super(issuer, aadIssValidation, ...args);
	    }

	    static get issuer() {
	      return issuer;
	    }
	  };

	client$1.exports.BaseClient = BaseClient;
	return client$1.exports;
}

var issuer_registry;
var hasRequiredIssuer_registry;

function requireIssuer_registry () {
	if (hasRequiredIssuer_registry) return issuer_registry;
	hasRequiredIssuer_registry = 1;
	const LRU = requireLruCache();

	issuer_registry = new LRU({ max: 100 });
	return issuer_registry;
}

var webfinger_normalize;
var hasRequiredWebfinger_normalize;

function requireWebfinger_normalize () {
	if (hasRequiredWebfinger_normalize) return webfinger_normalize;
	hasRequiredWebfinger_normalize = 1;
	// Credit: https://github.com/rohe/pyoidc/blob/master/src/oic/utils/webfinger.py

	// -- Normalization --
	// A string of any other type is interpreted as a URI either the form of scheme
	// "://" authority path-abempty [ "?" query ] [ "#" fragment ] or authority
	// path-abempty [ "?" query ] [ "#" fragment ] per RFC 3986 [RFC3986] and is
	// normalized according to the following rules:
	//
	// If the user input Identifier does not have an RFC 3986 [RFC3986] scheme
	// portion, the string is interpreted as [userinfo "@"] host [":" port]
	// path-abempty [ "?" query ] [ "#" fragment ] per RFC 3986 [RFC3986].
	// If the userinfo component is present and all of the path component, query
	// component, and port component are empty, the acct scheme is assumed. In this
	// case, the normalized URI is formed by prefixing acct: to the string as the
	// scheme. Per the 'acct' URI Scheme [ID.ietfappsawgaccturi], if there is an
	// at-sign character ('@') in the userinfo component, it needs to be
	// percent-encoded as described in RFC 3986 [RFC3986].
	// For all other inputs without a scheme portion, the https scheme is assumed,
	// and the normalized URI is formed by prefixing https:// to the string as the
	// scheme.
	// If the resulting URI contains a fragment portion, it MUST be stripped off
	// together with the fragment delimiter character "#".
	// The WebFinger [ID.ietfappsawgwebfinger] Resource in this case is the
	// resulting URI, and the WebFinger Host is the authority component.
	//
	// Note: Since the definition of authority in RFC 3986 [RFC3986] is
	// [ userinfo "@" ] host [ ":" port ], it is legal to have a user input
	// identifier like userinfo@host:port, e.g., alice@example.com:8080.

	const PORT = /^\d+$/;

	function hasScheme(input) {
	  if (input.includes('://')) return true;

	  const authority = input.replace(/(\/|\?)/g, '#').split('#')[0];
	  if (authority.includes(':')) {
	    const index = authority.indexOf(':');
	    const hostOrPort = authority.slice(index + 1);
	    if (!PORT.test(hostOrPort)) {
	      return true;
	    }
	  }

	  return false;
	}

	function acctSchemeAssumed(input) {
	  if (!input.includes('@')) return false;
	  const parts = input.split('@');
	  const host = parts[parts.length - 1];
	  return !(host.includes(':') || host.includes('/') || host.includes('?'));
	}

	function normalize(input) {
	  if (typeof input !== 'string') {
	    throw new TypeError('input must be a string');
	  }

	  let output;
	  if (hasScheme(input)) {
	    output = input;
	  } else if (acctSchemeAssumed(input)) {
	    output = `acct:${input}`;
	  } else {
	    output = `https://${input}`;
	  }

	  return output.split('#')[0];
	}

	webfinger_normalize = normalize;
	return webfinger_normalize;
}

var issuer;
var hasRequiredIssuer;

function requireIssuer () {
	if (hasRequiredIssuer) return issuer;
	hasRequiredIssuer = 1;
	const { inspect } = require$$1;
	const url = require$$5;

	const { RPError } = requireErrors$1();
	const getClient = requireClient();
	const registry = requireIssuer_registry();
	const processResponse = requireProcess_response();
	const webfingerNormalize = requireWebfinger_normalize();
	const request = requireRequest();
	const clone = requireDeep_clone();
	const { keystore } = requireIssuer$1();

	const AAD_MULTITENANT_DISCOVERY = [
	  'https://login.microsoftonline.com/common/.well-known/openid-configuration',
	  'https://login.microsoftonline.com/common/v2.0/.well-known/openid-configuration',
	  'https://login.microsoftonline.com/organizations/v2.0/.well-known/openid-configuration',
	  'https://login.microsoftonline.com/consumers/v2.0/.well-known/openid-configuration',
	];
	const AAD_MULTITENANT = Symbol();
	const ISSUER_DEFAULTS = {
	  claim_types_supported: ['normal'],
	  claims_parameter_supported: false,
	  grant_types_supported: ['authorization_code', 'implicit'],
	  request_parameter_supported: false,
	  request_uri_parameter_supported: true,
	  require_request_uri_registration: false,
	  response_modes_supported: ['query', 'fragment'],
	  token_endpoint_auth_methods_supported: ['client_secret_basic'],
	};

	class Issuer {
	  #metadata;
	  constructor(meta = {}) {
	    const aadIssValidation = meta[AAD_MULTITENANT];
	    delete meta[AAD_MULTITENANT];
	    ['introspection', 'revocation'].forEach((endpoint) => {
	      // if intro/revocation endpoint auth specific meta is missing use the token ones if they
	      // are defined
	      if (
	        meta[`${endpoint}_endpoint`] &&
	        meta[`${endpoint}_endpoint_auth_methods_supported`] === undefined &&
	        meta[`${endpoint}_endpoint_auth_signing_alg_values_supported`] === undefined
	      ) {
	        if (meta.token_endpoint_auth_methods_supported) {
	          meta[`${endpoint}_endpoint_auth_methods_supported`] =
	            meta.token_endpoint_auth_methods_supported;
	        }
	        if (meta.token_endpoint_auth_signing_alg_values_supported) {
	          meta[`${endpoint}_endpoint_auth_signing_alg_values_supported`] =
	            meta.token_endpoint_auth_signing_alg_values_supported;
	        }
	      }
	    });

	    this.#metadata = new Map();

	    Object.entries(meta).forEach(([key, value]) => {
	      this.#metadata.set(key, value);
	      if (!this[key]) {
	        Object.defineProperty(this, key, {
	          get() {
	            return this.#metadata.get(key);
	          },
	          enumerable: true,
	        });
	      }
	    });

	    registry.set(this.issuer, this);

	    const Client = getClient(this, aadIssValidation);

	    Object.defineProperties(this, {
	      Client: { value: Client, enumerable: true },
	      FAPI1Client: { value: class FAPI1Client extends Client {}, enumerable: true },
	      FAPI2Client: { value: class FAPI2Client extends Client {}, enumerable: true },
	    });
	  }

	  get metadata() {
	    return clone(Object.fromEntries(this.#metadata.entries()));
	  }

	  static async webfinger(input) {
	    const resource = webfingerNormalize(input);
	    const { host } = url.parse(resource);
	    const webfingerUrl = `https://${host}/.well-known/webfinger`;

	    const response = await request.call(this, {
	      method: 'GET',
	      url: webfingerUrl,
	      responseType: 'json',
	      searchParams: { resource, rel: 'http://openid.net/specs/connect/1.0/issuer' },
	      headers: {
	        Accept: 'application/json',
	      },
	    });
	    const body = processResponse(response);

	    const location =
	      Array.isArray(body.links) &&
	      body.links.find(
	        (link) =>
	          typeof link === 'object' &&
	          link.rel === 'http://openid.net/specs/connect/1.0/issuer' &&
	          link.href,
	      );

	    if (!location) {
	      throw new RPError({
	        message: 'no issuer found in webfinger response',
	        body,
	      });
	    }

	    if (typeof location.href !== 'string' || !location.href.startsWith('https://')) {
	      throw new RPError({
	        printf: ['invalid issuer location %s', location.href],
	        body,
	      });
	    }

	    const expectedIssuer = location.href;
	    if (registry.has(expectedIssuer)) {
	      return registry.get(expectedIssuer);
	    }

	    const issuer = await this.discover(expectedIssuer);

	    if (issuer.issuer !== expectedIssuer) {
	      registry.del(issuer.issuer);
	      throw new RPError(
	        'discovered issuer mismatch, expected %s, got: %s',
	        expectedIssuer,
	        issuer.issuer,
	      );
	    }
	    return issuer;
	  }

	  static async discover(uri) {
	    const wellKnownUri = resolveWellKnownUri(uri);

	    const response = await request.call(this, {
	      method: 'GET',
	      responseType: 'json',
	      url: wellKnownUri,
	      headers: {
	        Accept: 'application/json',
	      },
	    });
	    const body = processResponse(response);
	    return new Issuer({
	      ...ISSUER_DEFAULTS,
	      ...body,
	      [AAD_MULTITENANT]: !!AAD_MULTITENANT_DISCOVERY.find((discoveryURL) =>
	        wellKnownUri.startsWith(discoveryURL),
	      ),
	    });
	  }

	  async reloadJwksUri() {
	    await keystore.call(this, true);
	  }

	  /* istanbul ignore next */
	  [inspect.custom]() {
	    return `${this.constructor.name} ${inspect(this.metadata, {
	      depth: Infinity,
	      colors: process.stdout.isTTY,
	      compact: false,
	      sorted: true,
	    })}`;
	  }
	}

	function resolveWellKnownUri(uri) {
	  const parsed = url.parse(uri);
	  if (parsed.pathname.includes('/.well-known/')) {
	    return uri;
	  } else {
	    let pathname;
	    if (parsed.pathname.endsWith('/')) {
	      pathname = `${parsed.pathname}.well-known/openid-configuration`;
	    } else {
	      pathname = `${parsed.pathname}/.well-known/openid-configuration`;
	    }
	    return url.format({ ...parsed, pathname });
	  }
	}

	issuer = Issuer;
	return issuer;
}

var passport_strategy;
var hasRequiredPassport_strategy;

function requirePassport_strategy () {
	if (hasRequiredPassport_strategy) return passport_strategy;
	hasRequiredPassport_strategy = 1;
	const url = require$$5;
	const { format } = require$$1;

	const cloneDeep = requireDeep_clone();
	const { RPError, OPError } = requireErrors$1();
	const { BaseClient } = requireClient();
	const { random, codeChallenge } = requireGenerators();
	const pick = requirePick();
	const { resolveResponseType, resolveRedirectUri } = requireClient$1();

	function verified(err, user, info = {}) {
	  if (err) {
	    this.error(err);
	  } else if (!user) {
	    this.fail(info);
	  } else {
	    this.success(user, info);
	  }
	}

	function OpenIDConnectStrategy(
	  { client, params = {}, passReqToCallback = false, sessionKey, usePKCE = true, extras = {} } = {},
	  verify,
	) {
	  if (!(client instanceof BaseClient)) {
	    throw new TypeError('client must be an instance of openid-client Client');
	  }

	  if (typeof verify !== 'function') {
	    throw new TypeError('verify callback must be a function');
	  }

	  if (!client.issuer || !client.issuer.issuer) {
	    throw new TypeError('client must have an issuer with an identifier');
	  }

	  this._client = client;
	  this._issuer = client.issuer;
	  this._verify = verify;
	  this._passReqToCallback = passReqToCallback;
	  this._usePKCE = usePKCE;
	  this._key = sessionKey || `oidc:${url.parse(this._issuer.issuer).hostname}`;
	  this._params = cloneDeep(params);

	  // state and nonce are handled in authenticate()
	  delete this._params.state;
	  delete this._params.nonce;

	  this._extras = cloneDeep(extras);

	  if (!this._params.response_type) this._params.response_type = resolveResponseType.call(client);
	  if (!this._params.redirect_uri) this._params.redirect_uri = resolveRedirectUri.call(client);
	  if (!this._params.scope) this._params.scope = 'openid';

	  if (this._usePKCE === true) {
	    const supportedMethods = Array.isArray(this._issuer.code_challenge_methods_supported)
	      ? this._issuer.code_challenge_methods_supported
	      : false;

	    if (supportedMethods && supportedMethods.includes('S256')) {
	      this._usePKCE = 'S256';
	    } else if (supportedMethods && supportedMethods.includes('plain')) {
	      this._usePKCE = 'plain';
	    } else if (supportedMethods) {
	      throw new TypeError(
	        'neither code_challenge_method supported by the client is supported by the issuer',
	      );
	    } else {
	      this._usePKCE = 'S256';
	    }
	  } else if (typeof this._usePKCE === 'string' && !['plain', 'S256'].includes(this._usePKCE)) {
	    throw new TypeError(`${this._usePKCE} is not valid/implemented PKCE code_challenge_method`);
	  }

	  this.name = url.parse(client.issuer.issuer).hostname;
	}

	OpenIDConnectStrategy.prototype.authenticate = function authenticate(req, options) {
	  (async () => {
	    const client = this._client;
	    if (!req.session) {
	      throw new TypeError('authentication requires session support');
	    }
	    const reqParams = client.callbackParams(req);
	    const sessionKey = this._key;

	    const { 0: parameter, length } = Object.keys(reqParams);

	    /**
	     * Start authentication request if this has no authorization response parameters or
	     * this might a login initiated from a third party as per
	     * https://openid.net/specs/openid-connect-core-1_0.html#ThirdPartyInitiatedLogin.
	     */
	    if (length === 0 || (length === 1 && parameter === 'iss')) {
	      // provide options object with extra authentication parameters
	      const params = {
	        state: random(),
	        ...this._params,
	        ...options,
	      };

	      if (!params.nonce && params.response_type.includes('id_token')) {
	        params.nonce = random();
	      }

	      req.session[sessionKey] = pick(params, 'nonce', 'state', 'max_age', 'response_type');

	      if (this._usePKCE && params.response_type.includes('code')) {
	        const verifier = random();
	        req.session[sessionKey].code_verifier = verifier;

	        switch (this._usePKCE) {
	          case 'S256':
	            params.code_challenge = codeChallenge(verifier);
	            params.code_challenge_method = 'S256';
	            break;
	          case 'plain':
	            params.code_challenge = verifier;
	            break;
	        }
	      }

	      this.redirect(client.authorizationUrl(params));
	      return;
	    }
	    /* end authentication request */

	    /* start authentication response */

	    const session = req.session[sessionKey];
	    if (Object.keys(session || {}).length === 0) {
	      throw new Error(
	        format(
	          'did not find expected authorization request details in session, req.session["%s"] is %j',
	          sessionKey,
	          session,
	        ),
	      );
	    }

	    const {
	      state,
	      nonce,
	      max_age: maxAge,
	      code_verifier: codeVerifier,
	      response_type: responseType,
	    } = session;

	    try {
	      delete req.session[sessionKey];
	    } catch (err) {}

	    const opts = {
	      redirect_uri: this._params.redirect_uri,
	      ...options,
	    };

	    const checks = {
	      state,
	      nonce,
	      max_age: maxAge,
	      code_verifier: codeVerifier,
	      response_type: responseType,
	    };

	    const tokenset = await client.callback(opts.redirect_uri, reqParams, checks, this._extras);

	    const passReq = this._passReqToCallback;
	    const loadUserinfo = this._verify.length > (passReq ? 3 : 2) && client.issuer.userinfo_endpoint;

	    const args = [tokenset, verified.bind(this)];

	    if (loadUserinfo) {
	      if (!tokenset.access_token) {
	        throw new RPError({
	          message:
	            'expected access_token to be returned when asking for userinfo in verify callback',
	          tokenset,
	        });
	      }
	      const userinfo = await client.userinfo(tokenset);
	      args.splice(1, 0, userinfo);
	    }

	    if (passReq) {
	      args.unshift(req);
	    }

	    this._verify(...args);
	    /* end authentication response */
	  })().catch((error) => {
	    if (
	      (error instanceof OPError &&
	        error.error !== 'server_error' &&
	        !error.error.startsWith('invalid')) ||
	      error instanceof RPError
	    ) {
	      this.fail(error);
	    } else {
	      this.error(error);
	    }
	  });
	};

	passport_strategy = OpenIDConnectStrategy;
	return passport_strategy;
}

var lib;
var hasRequiredLib;

function requireLib () {
	if (hasRequiredLib) return lib;
	hasRequiredLib = 1;
	const Issuer = requireIssuer();
	const { OPError, RPError } = requireErrors$1();
	const Strategy = requirePassport_strategy();
	const TokenSet = requireToken_set();
	const { CLOCK_TOLERANCE, HTTP_OPTIONS } = requireConsts();
	const generators = requireGenerators();
	const { setDefaults } = requireRequest();

	lib = {
	  Issuer,
	  Strategy,
	  TokenSet,
	  errors: {
	    OPError,
	    RPError,
	  },
	  custom: {
	    setHttpOptionsDefaults: setDefaults,
	    http_options: HTTP_OPTIONS,
	    clock_tolerance: CLOCK_TOLERANCE,
	  },
	  generators,
	};
	return lib;
}

var libExports = requireLib();
var mod = /*@__PURE__*/getDefaultExportFromCjs(libExports);

const Issuer = mod.Issuer;
mod.Strategy;
mod.TokenSet;
mod.errors;
const custom = mod.custom;
const generators = mod.generators;

/**
 * A JavaScript implementation of the SHA family of hashes - defined in FIPS PUB 180-4, FIPS PUB 202,
 * and SP 800-185 - as well as the corresponding HMAC implementation as defined in FIPS PUB 198-1.
 *
 * Copyright 2008-2023 Brian Turek, 1998-2009 Paul Johnston & Contributors
 * Distributed under the BSD License
 * See http://caligatio.github.com/jsSHA/ for more information
 */
const t="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",n="ARRAYBUFFER not supported by this environment",e="UINT8ARRAY not supported by this environment";function r(t,n,e,r){let i,s,o;const h=n||[0],u=(e=e||0)>>>3,w=-1===r?3:0;for(i=0;i<t.length;i+=1)o=i+u,s=o>>>2,h.length<=s&&h.push(0),h[s]|=t[i]<<8*(w+r*(o%4));return {value:h,binLen:8*t.length+e}}function i(i,s,o){switch(s){case"UTF8":case"UTF16BE":case"UTF16LE":break;default:throw new Error("encoding must be UTF8, UTF16BE, or UTF16LE")}switch(i){case"HEX":return function(t,n,e){return function(t,n,e,r){let i,s,o,h;if(0!=t.length%2)throw new Error("String of HEX type must be in byte increments");const u=n||[0],w=(e=e||0)>>>3,c=-1===r?3:0;for(i=0;i<t.length;i+=2){if(s=parseInt(t.substr(i,2),16),isNaN(s))throw new Error("String of HEX type contains invalid characters");for(h=(i>>>1)+w,o=h>>>2;u.length<=o;)u.push(0);u[o]|=s<<8*(c+r*(h%4));}return {value:u,binLen:4*t.length+e}}(t,n,e,o)};case"TEXT":return function(t,n,e){return function(t,n,e,r,i){let s,o,h,u,w,c,f,a,l=0;const A=e||[0],E=(r=r||0)>>>3;if("UTF8"===n)for(f=-1===i?3:0,h=0;h<t.length;h+=1)for(s=t.charCodeAt(h),o=[],128>s?o.push(s):2048>s?(o.push(192|s>>>6),o.push(128|63&s)):55296>s||57344<=s?o.push(224|s>>>12,128|s>>>6&63,128|63&s):(h+=1,s=65536+((1023&s)<<10|1023&t.charCodeAt(h)),o.push(240|s>>>18,128|s>>>12&63,128|s>>>6&63,128|63&s)),u=0;u<o.length;u+=1){for(c=l+E,w=c>>>2;A.length<=w;)A.push(0);A[w]|=o[u]<<8*(f+i*(c%4)),l+=1;}else for(f=-1===i?2:0,a="UTF16LE"===n&&1!==i||"UTF16LE"!==n&&1===i,h=0;h<t.length;h+=1){for(s=t.charCodeAt(h),!0===a&&(u=255&s,s=u<<8|s>>>8),c=l+E,w=c>>>2;A.length<=w;)A.push(0);A[w]|=s<<8*(f+i*(c%4)),l+=2;}return {value:A,binLen:8*l+r}}(t,s,n,e,o)};case"B64":return function(n,e,r){return function(n,e,r,i){let s,o,h,u,w,c,f,a=0;const l=e||[0],A=(r=r||0)>>>3,E=-1===i?3:0,H=n.indexOf("=");if(-1===n.search(/^[a-zA-Z0-9=+/]+$/))throw new Error("Invalid character in base-64 string");if(n=n.replace(/=/g,""),-1!==H&&H<n.length)throw new Error("Invalid '=' found in base-64 string");for(o=0;o<n.length;o+=4){for(w=n.substr(o,4),u=0,h=0;h<w.length;h+=1)s=t.indexOf(w.charAt(h)),u|=s<<18-6*h;for(h=0;h<w.length-1;h+=1){for(f=a+A,c=f>>>2;l.length<=c;)l.push(0);l[c]|=(u>>>16-8*h&255)<<8*(E+i*(f%4)),a+=1;}}return {value:l,binLen:8*a+r}}(n,e,r,o)};case"BYTES":return function(t,n,e){return function(t,n,e,r){let i,s,o,h;const u=n||[0],w=(e=e||0)>>>3,c=-1===r?3:0;for(s=0;s<t.length;s+=1)i=t.charCodeAt(s),h=s+w,o=h>>>2,u.length<=o&&u.push(0),u[o]|=i<<8*(c+r*(h%4));return {value:u,binLen:8*t.length+e}}(t,n,e,o)};case"ARRAYBUFFER":try{new ArrayBuffer(0);}catch(t){throw new Error(n)}return function(t,n,e){return function(t,n,e,i){return r(new Uint8Array(t),n,e,i)}(t,n,e,o)};case"UINT8ARRAY":try{new Uint8Array(0);}catch(t){throw new Error(e)}return function(t,n,e){return r(t,n,e,o)};default:throw new Error("format must be HEX, TEXT, B64, BYTES, ARRAYBUFFER, or UINT8ARRAY")}}function s(r,i,s,o){switch(r){case"HEX":return function(t){return function(t,n,e,r){const i="0123456789abcdef";let s,o,h="";const u=n/8,w=-1===e?3:0;for(s=0;s<u;s+=1)o=t[s>>>2]>>>8*(w+e*(s%4)),h+=i.charAt(o>>>4&15)+i.charAt(15&o);return r.outputUpper?h.toUpperCase():h}(t,i,s,o)};case"B64":return function(n){return function(n,e,r,i){let s,o,h,u,w,c="";const f=e/8,a=-1===r?3:0;for(s=0;s<f;s+=3)for(u=s+1<f?n[s+1>>>2]:0,w=s+2<f?n[s+2>>>2]:0,h=(n[s>>>2]>>>8*(a+r*(s%4))&255)<<16|(u>>>8*(a+r*((s+1)%4))&255)<<8|w>>>8*(a+r*((s+2)%4))&255,o=0;o<4;o+=1)c+=8*s+6*o<=e?t.charAt(h>>>6*(3-o)&63):i.b64Pad;return c}(n,i,s,o)};case"BYTES":return function(t){return function(t,n,e){let r,i,s="";const o=n/8,h=-1===e?3:0;for(r=0;r<o;r+=1)i=t[r>>>2]>>>8*(h+e*(r%4))&255,s+=String.fromCharCode(i);return s}(t,i,s)};case"ARRAYBUFFER":try{new ArrayBuffer(0);}catch(t){throw new Error(n)}return function(t){return function(t,n,e){let r;const i=n/8,s=new ArrayBuffer(i),o=new Uint8Array(s),h=-1===e?3:0;for(r=0;r<i;r+=1)o[r]=t[r>>>2]>>>8*(h+e*(r%4))&255;return s}(t,i,s)};case"UINT8ARRAY":try{new Uint8Array(0);}catch(t){throw new Error(e)}return function(t){return function(t,n,e){let r;const i=n/8,s=-1===e?3:0,o=new Uint8Array(i);for(r=0;r<i;r+=1)o[r]=t[r>>>2]>>>8*(s+e*(r%4))&255;return o}(t,i,s)};default:throw new Error("format must be HEX, B64, BYTES, ARRAYBUFFER, or UINT8ARRAY")}}const o=4294967296,h=[1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298],u=[3238371032,914150663,812702999,4144912697,4290775857,1750603025,1694076839,3204075428],w=[1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225],c="Chosen SHA variant is not supported",f="Cannot set numRounds with MAC";function a(t,n){let e,r;const i=t.binLen>>>3,s=n.binLen>>>3,o=i<<3,h=4-i<<3;if(i%4!=0){for(e=0;e<s;e+=4)r=i+e>>>2,t.value[r]|=n.value[e>>>2]<<o,t.value.push(0),t.value[r+1]|=n.value[e>>>2]>>>h;return (t.value.length<<2)-4>=s+i&&t.value.pop(),{value:t.value,binLen:t.binLen+n.binLen}}return {value:t.value.concat(n.value),binLen:t.binLen+n.binLen}}function l(t){const n={outputUpper:!1,b64Pad:"=",outputLen:-1},e=t||{},r="Output length must be a multiple of 8";if(n.outputUpper=e.outputUpper||!1,e.b64Pad&&(n.b64Pad=e.b64Pad),e.outputLen){if(e.outputLen%8!=0)throw new Error(r);n.outputLen=e.outputLen;}else if(e.shakeLen){if(e.shakeLen%8!=0)throw new Error(r);n.outputLen=e.shakeLen;}if("boolean"!=typeof n.outputUpper)throw new Error("Invalid outputUpper formatting option");if("string"!=typeof n.b64Pad)throw new Error("Invalid b64Pad formatting option");return n}function A(t,n,e,r){const s=t+" must include a value and format";if(!n){if(!r)throw new Error(s);return r}if(void 0===n.value||!n.format)throw new Error(s);return i(n.format,n.encoding||"UTF8",e)(n.value)}class E{constructor(t,n,e){const r=e||{};if(this.t=n,this.i=r.encoding||"UTF8",this.numRounds=r.numRounds||1,isNaN(this.numRounds)||this.numRounds!==parseInt(this.numRounds,10)||1>this.numRounds)throw new Error("numRounds must a integer >= 1");this.o=t,this.h=[],this.u=0,this.l=!1,this.A=0,this.H=!1,this.S=[],this.p=[];}update(t){let n,e=0;const r=this.m>>>5,i=this.C(t,this.h,this.u),s=i.binLen,o=i.value,h=s>>>5;for(n=0;n<h;n+=r)e+this.m<=s&&(this.U=this.v(o.slice(n,n+r),this.U),e+=this.m);return this.A+=e,this.h=o.slice(e>>>5),this.u=s%this.m,this.l=!0,this}getHash(t,n){let e,r,i=this.R;const o=l(n);if(this.K){if(-1===o.outputLen)throw new Error("Output length must be specified in options");i=o.outputLen;}const h=s(t,i,this.T,o);if(this.H&&this.g)return h(this.g(o));for(r=this.F(this.h.slice(),this.u,this.A,this.L(this.U),i),e=1;e<this.numRounds;e+=1)this.K&&i%32!=0&&(r[r.length-1]&=16777215>>>24-i%32),r=this.F(r,i,0,this.B(this.o),i);return h(r)}setHMACKey(t,n,e){if(!this.M)throw new Error("Variant does not support HMAC");if(this.l)throw new Error("Cannot set MAC key after calling update");const r=i(n,(e||{}).encoding||"UTF8",this.T);this.k(r(t));}k(t){const n=this.m>>>3,e=n/4-1;let r;if(1!==this.numRounds)throw new Error(f);if(this.H)throw new Error("MAC key already set");for(n<t.binLen/8&&(t.value=this.F(t.value,t.binLen,0,this.B(this.o),this.R));t.value.length<=e;)t.value.push(0);for(r=0;r<=e;r+=1)this.S[r]=909522486^t.value[r],this.p[r]=1549556828^t.value[r];this.U=this.v(this.S,this.U),this.A=this.m,this.H=!0;}getHMAC(t,n){const e=l(n);return s(t,this.R,this.T,e)(this.Y())}Y(){let t;if(!this.H)throw new Error("Cannot call getHMAC without first setting MAC key");const n=this.F(this.h.slice(),this.u,this.A,this.L(this.U),this.R);return t=this.v(this.p,this.B(this.o)),t=this.F(n,this.R,this.m,t,this.R),t}}function H(t,n){return t<<n|t>>>32-n}function S(t,n){return t>>>n|t<<32-n}function b(t,n){return t>>>n}function p(t,n,e){return t^n^e}function d(t,n,e){return t&n^~t&e}function m(t,n,e){return t&n^t&e^n&e}function C(t){return S(t,2)^S(t,13)^S(t,22)}function y(t,n){const e=(65535&t)+(65535&n);return (65535&(t>>>16)+(n>>>16)+(e>>>16))<<16|65535&e}function U(t,n,e,r){const i=(65535&t)+(65535&n)+(65535&e)+(65535&r);return (65535&(t>>>16)+(n>>>16)+(e>>>16)+(r>>>16)+(i>>>16))<<16|65535&i}function v(t,n,e,r,i){const s=(65535&t)+(65535&n)+(65535&e)+(65535&r)+(65535&i);return (65535&(t>>>16)+(n>>>16)+(e>>>16)+(r>>>16)+(i>>>16)+(s>>>16))<<16|65535&s}function R(t){return S(t,7)^S(t,18)^b(t,3)}function K(t){return S(t,6)^S(t,11)^S(t,25)}function T(t){return [1732584193,4023233417,2562383102,271733878,3285377520]}function g(t,n){let e,r,i,s,o,h,u;const w=[];for(e=n[0],r=n[1],i=n[2],s=n[3],o=n[4],u=0;u<80;u+=1)w[u]=u<16?t[u]:H(w[u-3]^w[u-8]^w[u-14]^w[u-16],1),h=u<20?v(H(e,5),d(r,i,s),o,1518500249,w[u]):u<40?v(H(e,5),p(r,i,s),o,1859775393,w[u]):u<60?v(H(e,5),m(r,i,s),o,2400959708,w[u]):v(H(e,5),p(r,i,s),o,3395469782,w[u]),o=s,s=i,i=H(r,30),r=e,e=h;return n[0]=y(e,n[0]),n[1]=y(r,n[1]),n[2]=y(i,n[2]),n[3]=y(s,n[3]),n[4]=y(o,n[4]),n}function F(t,n,e,r){let i;const s=15+(n+65>>>9<<4),h=n+e;for(;t.length<=s;)t.push(0);for(t[n>>>5]|=128<<24-n%32,t[s]=4294967295&h,t[s-1]=h/o|0,i=0;i<t.length;i+=16)r=g(t.slice(i,i+16),r);return r}let L=class extends E{constructor(t,n,e){if("SHA-1"!==t)throw new Error(c);super(t,n,e);const r=e||{};this.M=!0,this.g=this.Y,this.T=-1,this.C=i(this.t,this.i,this.T),this.v=g,this.L=function(t){return t.slice()},this.B=T,this.F=F,this.U=[1732584193,4023233417,2562383102,271733878,3285377520],this.m=512,this.R=160,this.K=!1,r.hmacKey&&this.k(A("hmacKey",r.hmacKey,this.T));}};function B(t){let n;return n="SHA-224"==t?u.slice():w.slice(),n}function M(t,n){let e,r,i,s,o,u,w,c,f,a,l;const A=[];for(e=n[0],r=n[1],i=n[2],s=n[3],o=n[4],u=n[5],w=n[6],c=n[7],l=0;l<64;l+=1)A[l]=l<16?t[l]:U(S(E=A[l-2],17)^S(E,19)^b(E,10),A[l-7],R(A[l-15]),A[l-16]),f=v(c,K(o),d(o,u,w),h[l],A[l]),a=y(C(e),m(e,r,i)),c=w,w=u,u=o,o=y(s,f),s=i,i=r,r=e,e=y(f,a);var E;return n[0]=y(e,n[0]),n[1]=y(r,n[1]),n[2]=y(i,n[2]),n[3]=y(s,n[3]),n[4]=y(o,n[4]),n[5]=y(u,n[5]),n[6]=y(w,n[6]),n[7]=y(c,n[7]),n}let k=class extends E{constructor(t,n,e){if("SHA-224"!==t&&"SHA-256"!==t)throw new Error(c);super(t,n,e);const r=e||{};this.g=this.Y,this.M=!0,this.T=-1,this.C=i(this.t,this.i,this.T),this.v=M,this.L=function(t){return t.slice()},this.B=B,this.F=function(n,e,r,i){return function(t,n,e,r,i){let s,h;const u=15+(n+65>>>9<<4),w=n+e;for(;t.length<=u;)t.push(0);for(t[n>>>5]|=128<<24-n%32,t[u]=4294967295&w,t[u-1]=w/o|0,s=0;s<t.length;s+=16)r=M(t.slice(s,s+16),r);return h="SHA-224"===i?[r[0],r[1],r[2],r[3],r[4],r[5],r[6]]:r,h}(n,e,r,i,t)},this.U=B(t),this.m=512,this.R="SHA-224"===t?224:256,this.K=!1,r.hmacKey&&this.k(A("hmacKey",r.hmacKey,this.T));}};class Y{constructor(t,n){this.N=t,this.I=n;}}function N(t,n){let e;return n>32?(e=64-n,new Y(t.I<<n|t.N>>>e,t.N<<n|t.I>>>e)):0!==n?(e=32-n,new Y(t.N<<n|t.I>>>e,t.I<<n|t.N>>>e)):t}function I(t,n){let e;return n<32?(e=32-n,new Y(t.N>>>n|t.I<<e,t.I>>>n|t.N<<e)):(e=64-n,new Y(t.I>>>n|t.N<<e,t.N>>>n|t.I<<e))}function X(t,n){return new Y(t.N>>>n,t.I>>>n|t.N<<32-n)}function z(t,n,e){return new Y(t.N&n.N^t.N&e.N^n.N&e.N,t.I&n.I^t.I&e.I^n.I&e.I)}function x(t){const n=I(t,28),e=I(t,34),r=I(t,39);return new Y(n.N^e.N^r.N,n.I^e.I^r.I)}function _(t,n){let e,r;e=(65535&t.I)+(65535&n.I),r=(t.I>>>16)+(n.I>>>16)+(e>>>16);const i=(65535&r)<<16|65535&e;e=(65535&t.N)+(65535&n.N)+(r>>>16),r=(t.N>>>16)+(n.N>>>16)+(e>>>16);return new Y((65535&r)<<16|65535&e,i)}function O(t,n,e,r){let i,s;i=(65535&t.I)+(65535&n.I)+(65535&e.I)+(65535&r.I),s=(t.I>>>16)+(n.I>>>16)+(e.I>>>16)+(r.I>>>16)+(i>>>16);const o=(65535&s)<<16|65535&i;i=(65535&t.N)+(65535&n.N)+(65535&e.N)+(65535&r.N)+(s>>>16),s=(t.N>>>16)+(n.N>>>16)+(e.N>>>16)+(r.N>>>16)+(i>>>16);return new Y((65535&s)<<16|65535&i,o)}function P(t,n,e,r,i){let s,o;s=(65535&t.I)+(65535&n.I)+(65535&e.I)+(65535&r.I)+(65535&i.I),o=(t.I>>>16)+(n.I>>>16)+(e.I>>>16)+(r.I>>>16)+(i.I>>>16)+(s>>>16);const h=(65535&o)<<16|65535&s;s=(65535&t.N)+(65535&n.N)+(65535&e.N)+(65535&r.N)+(65535&i.N)+(o>>>16),o=(t.N>>>16)+(n.N>>>16)+(e.N>>>16)+(r.N>>>16)+(i.N>>>16)+(s>>>16);return new Y((65535&o)<<16|65535&s,h)}function V(t,n){return new Y(t.N^n.N,t.I^n.I)}function Z(t){const n=I(t,19),e=I(t,61),r=X(t,6);return new Y(n.N^e.N^r.N,n.I^e.I^r.I)}function j(t){const n=I(t,1),e=I(t,8),r=X(t,7);return new Y(n.N^e.N^r.N,n.I^e.I^r.I)}function q(t){const n=I(t,14),e=I(t,18),r=I(t,41);return new Y(n.N^e.N^r.N,n.I^e.I^r.I)}const D=[new Y(h[0],3609767458),new Y(h[1],602891725),new Y(h[2],3964484399),new Y(h[3],2173295548),new Y(h[4],4081628472),new Y(h[5],3053834265),new Y(h[6],2937671579),new Y(h[7],3664609560),new Y(h[8],2734883394),new Y(h[9],1164996542),new Y(h[10],1323610764),new Y(h[11],3590304994),new Y(h[12],4068182383),new Y(h[13],991336113),new Y(h[14],633803317),new Y(h[15],3479774868),new Y(h[16],2666613458),new Y(h[17],944711139),new Y(h[18],2341262773),new Y(h[19],2007800933),new Y(h[20],1495990901),new Y(h[21],1856431235),new Y(h[22],3175218132),new Y(h[23],2198950837),new Y(h[24],3999719339),new Y(h[25],766784016),new Y(h[26],2566594879),new Y(h[27],3203337956),new Y(h[28],1034457026),new Y(h[29],2466948901),new Y(h[30],3758326383),new Y(h[31],168717936),new Y(h[32],1188179964),new Y(h[33],1546045734),new Y(h[34],1522805485),new Y(h[35],2643833823),new Y(h[36],2343527390),new Y(h[37],1014477480),new Y(h[38],1206759142),new Y(h[39],344077627),new Y(h[40],1290863460),new Y(h[41],3158454273),new Y(h[42],3505952657),new Y(h[43],106217008),new Y(h[44],3606008344),new Y(h[45],1432725776),new Y(h[46],1467031594),new Y(h[47],851169720),new Y(h[48],3100823752),new Y(h[49],1363258195),new Y(h[50],3750685593),new Y(h[51],3785050280),new Y(h[52],3318307427),new Y(h[53],3812723403),new Y(h[54],2003034995),new Y(h[55],3602036899),new Y(h[56],1575990012),new Y(h[57],1125592928),new Y(h[58],2716904306),new Y(h[59],442776044),new Y(h[60],593698344),new Y(h[61],3733110249),new Y(h[62],2999351573),new Y(h[63],3815920427),new Y(3391569614,3928383900),new Y(3515267271,566280711),new Y(3940187606,3454069534),new Y(4118630271,4000239992),new Y(116418474,1914138554),new Y(174292421,2731055270),new Y(289380356,3203993006),new Y(460393269,320620315),new Y(685471733,587496836),new Y(852142971,1086792851),new Y(1017036298,365543100),new Y(1126000580,2618297676),new Y(1288033470,3409855158),new Y(1501505948,4234509866),new Y(1607167915,987167468),new Y(1816402316,1246189591)];function G(t){return "SHA-384"===t?[new Y(3418070365,u[0]),new Y(1654270250,u[1]),new Y(2438529370,u[2]),new Y(355462360,u[3]),new Y(1731405415,u[4]),new Y(41048885895,u[5]),new Y(3675008525,u[6]),new Y(1203062813,u[7])]:[new Y(w[0],4089235720),new Y(w[1],2227873595),new Y(w[2],4271175723),new Y(w[3],1595750129),new Y(w[4],2917565137),new Y(w[5],725511199),new Y(w[6],4215389547),new Y(w[7],327033209)]}function J(t,n){let e,r,i,s,o,h,u,w,c,f,a,l;const A=[];for(e=n[0],r=n[1],i=n[2],s=n[3],o=n[4],h=n[5],u=n[6],w=n[7],a=0;a<80;a+=1)a<16?(l=2*a,A[a]=new Y(t[l],t[l+1])):A[a]=O(Z(A[a-2]),A[a-7],j(A[a-15]),A[a-16]),c=P(w,q(o),(H=h,S=u,new Y((E=o).N&H.N^~E.N&S.N,E.I&H.I^~E.I&S.I)),D[a],A[a]),f=_(x(e),z(e,r,i)),w=u,u=h,h=o,o=_(s,c),s=i,i=r,r=e,e=_(c,f);var E,H,S;return n[0]=_(e,n[0]),n[1]=_(r,n[1]),n[2]=_(i,n[2]),n[3]=_(s,n[3]),n[4]=_(o,n[4]),n[5]=_(h,n[5]),n[6]=_(u,n[6]),n[7]=_(w,n[7]),n}let Q=class extends E{constructor(t,n,e){if("SHA-384"!==t&&"SHA-512"!==t)throw new Error(c);super(t,n,e);const r=e||{};this.g=this.Y,this.M=!0,this.T=-1,this.C=i(this.t,this.i,this.T),this.v=J,this.L=function(t){return t.slice()},this.B=G,this.F=function(n,e,r,i){return function(t,n,e,r,i){let s,h;const u=31+(n+129>>>10<<5),w=n+e;for(;t.length<=u;)t.push(0);for(t[n>>>5]|=128<<24-n%32,t[u]=4294967295&w,t[u-1]=w/o|0,s=0;s<t.length;s+=32)r=J(t.slice(s,s+32),r);return h="SHA-384"===i?[r[0].N,r[0].I,r[1].N,r[1].I,r[2].N,r[2].I,r[3].N,r[3].I,r[4].N,r[4].I,r[5].N,r[5].I]:[r[0].N,r[0].I,r[1].N,r[1].I,r[2].N,r[2].I,r[3].N,r[3].I,r[4].N,r[4].I,r[5].N,r[5].I,r[6].N,r[6].I,r[7].N,r[7].I],h}(n,e,r,i,t)},this.U=G(t),this.m=1024,this.R="SHA-384"===t?384:512,this.K=!1,r.hmacKey&&this.k(A("hmacKey",r.hmacKey,this.T));}};const W=[new Y(0,1),new Y(0,32898),new Y(2147483648,32906),new Y(2147483648,2147516416),new Y(0,32907),new Y(0,2147483649),new Y(2147483648,2147516545),new Y(2147483648,32777),new Y(0,138),new Y(0,136),new Y(0,2147516425),new Y(0,2147483658),new Y(0,2147516555),new Y(2147483648,139),new Y(2147483648,32905),new Y(2147483648,32771),new Y(2147483648,32770),new Y(2147483648,128),new Y(0,32778),new Y(2147483648,2147483658),new Y(2147483648,2147516545),new Y(2147483648,32896),new Y(0,2147483649),new Y(2147483648,2147516424)],$=[[0,36,3,41,18],[1,44,10,45,2],[62,6,43,15,61],[28,55,25,21,56],[27,20,39,8,14]];function tt(t){let n;const e=[];for(n=0;n<5;n+=1)e[n]=[new Y(0,0),new Y(0,0),new Y(0,0),new Y(0,0),new Y(0,0)];return e}function nt(t){let n;const e=[];for(n=0;n<5;n+=1)e[n]=t[n].slice();return e}function et(t,n){let e,r,i,s;const o=[],h=[];if(null!==t)for(r=0;r<t.length;r+=2)n[(r>>>1)%5][(r>>>1)/5|0]=V(n[(r>>>1)%5][(r>>>1)/5|0],new Y(t[r+1],t[r]));for(e=0;e<24;e+=1){for(s=tt(),r=0;r<5;r+=1)o[r]=(u=n[r][0],w=n[r][1],c=n[r][2],f=n[r][3],a=n[r][4],new Y(u.N^w.N^c.N^f.N^a.N,u.I^w.I^c.I^f.I^a.I));for(r=0;r<5;r+=1)h[r]=V(o[(r+4)%5],N(o[(r+1)%5],1));for(r=0;r<5;r+=1)for(i=0;i<5;i+=1)n[r][i]=V(n[r][i],h[r]);for(r=0;r<5;r+=1)for(i=0;i<5;i+=1)s[i][(2*r+3*i)%5]=N(n[r][i],$[r][i]);for(r=0;r<5;r+=1)for(i=0;i<5;i+=1)n[r][i]=V(s[r][i],new Y(~s[(r+1)%5][i].N&s[(r+2)%5][i].N,~s[(r+1)%5][i].I&s[(r+2)%5][i].I));n[0][0]=V(n[0][0],W[e]);}var u,w,c,f,a;return n}function rt(t){let n,e,r=0;const i=[0,0],s=[4294967295&t,t/o&2097151];for(n=6;n>=0;n--)e=s[n>>2]>>>8*n&255,0===e&&0===r||(i[r+1>>2]|=e<<8*(r+1),r+=1);return r=0!==r?r:1,i[0]|=r,{value:r+1>4?i:[i[0]],binLen:8+8*r}}function it(t){return a(rt(t.binLen),t)}function st(t,n){let e,r=rt(n);r=a(r,t);const i=n>>>2,s=(i-r.value.length%i)%i;for(e=0;e<s;e++)r.value.push(0);return r.value}let ot=class extends E{constructor(t,n,e){let r=6,s=0;super(t,n,e);const o=e||{};if(1!==this.numRounds){if(o.kmacKey||o.hmacKey)throw new Error(f);if("CSHAKE128"===this.o||"CSHAKE256"===this.o)throw new Error("Cannot set numRounds for CSHAKE variants")}switch(this.T=1,this.C=i(this.t,this.i,this.T),this.v=et,this.L=nt,this.B=tt,this.U=tt(),this.K=!1,t){case"SHA3-224":this.m=s=1152,this.R=224,this.M=!0,this.g=this.Y;break;case"SHA3-256":this.m=s=1088,this.R=256,this.M=!0,this.g=this.Y;break;case"SHA3-384":this.m=s=832,this.R=384,this.M=!0,this.g=this.Y;break;case"SHA3-512":this.m=s=576,this.R=512,this.M=!0,this.g=this.Y;break;case"SHAKE128":r=31,this.m=s=1344,this.R=-1,this.K=!0,this.M=!1,this.g=null;break;case"SHAKE256":r=31,this.m=s=1088,this.R=-1,this.K=!0,this.M=!1,this.g=null;break;case"KMAC128":r=4,this.m=s=1344,this.X(e),this.R=-1,this.K=!0,this.M=!1,this.g=this._;break;case"KMAC256":r=4,this.m=s=1088,this.X(e),this.R=-1,this.K=!0,this.M=!1,this.g=this._;break;case"CSHAKE128":this.m=s=1344,r=this.O(e),this.R=-1,this.K=!0,this.M=!1,this.g=null;break;case"CSHAKE256":this.m=s=1088,r=this.O(e),this.R=-1,this.K=!0,this.M=!1,this.g=null;break;default:throw new Error(c)}this.F=function(t,n,e,i,o){return function(t,n,e,r,i,s,o){let h,u,w=0;const c=[],f=i>>>5,a=n>>>5;for(h=0;h<a&&n>=i;h+=f)r=et(t.slice(h,h+f),r),n-=i;for(t=t.slice(h),n%=i;t.length<f;)t.push(0);for(h=n>>>3,t[h>>2]^=s<<h%4*8,t[f-1]^=2147483648,r=et(t,r);32*c.length<o&&(u=r[w%5][w/5|0],c.push(u.I),!(32*c.length>=o));)c.push(u.N),w+=1,0==64*w%i&&(et(null,r),w=0);return c}(t,n,0,i,s,r,o)},o.hmacKey&&this.k(A("hmacKey",o.hmacKey,this.T));}O(t,n){const e=function(t){const n=t||{};return {funcName:A("funcName",n.funcName,1,{value:[],binLen:0}),customization:A("Customization",n.customization,1,{value:[],binLen:0})}}(t||{});n&&(e.funcName=n);const r=a(it(e.funcName),it(e.customization));if(0!==e.customization.binLen||0!==e.funcName.binLen){const t=st(r,this.m>>>3);for(let n=0;n<t.length;n+=this.m>>>5)this.U=this.v(t.slice(n,n+(this.m>>>5)),this.U),this.A+=this.m;return 4}return 31}X(t){const n=function(t){const n=t||{};return {kmacKey:A("kmacKey",n.kmacKey,1),funcName:{value:[1128353099],binLen:32},customization:A("Customization",n.customization,1,{value:[],binLen:0})}}(t||{});this.O(t,n.funcName);const e=st(it(n.kmacKey),this.m>>>3);for(let t=0;t<e.length;t+=this.m>>>5)this.U=this.v(e.slice(t,t+(this.m>>>5)),this.U),this.A+=this.m;this.H=!0;}_(t){const n=a({value:this.h.slice(),binLen:this.u},function(t){let n,e,r=0;const i=[0,0],s=[4294967295&t,t/o&2097151];for(n=6;n>=0;n--)e=s[n>>2]>>>8*n&255,0===e&&0===r||(i[r>>2]|=e<<8*r,r+=1);return r=0!==r?r:1,i[r>>2]|=r<<8*r,{value:r+1>4?i:[i[0]],binLen:8+8*r}}(t.outputLen));return this.F(n.value,n.binLen,this.A,this.L(this.U),t.outputLen)}};class ht{constructor(t,n,e){if("SHA-1"==t)this.P=new L(t,n,e);else if("SHA-224"==t||"SHA-256"==t)this.P=new k(t,n,e);else if("SHA-384"==t||"SHA-512"==t)this.P=new Q(t,n,e);else {if("SHA3-224"!=t&&"SHA3-256"!=t&&"SHA3-384"!=t&&"SHA3-512"!=t&&"SHAKE128"!=t&&"SHAKE256"!=t&&"CSHAKE128"!=t&&"CSHAKE256"!=t&&"KMAC128"!=t&&"KMAC256"!=t)throw new Error(c);this.P=new ot(t,n,e);}}update(t){return this.P.update(t),this}getHash(t,n){return this.P.getHash(t,n)}setHMACKey(t,n,e){this.P.setHMACKey(t,n,e);}getHMAC(t,n){return this.P.getHMAC(t,n)}}

class TOTP {
    static generate(key, options) {
        const _options = { digits: 6, algorithm: "SHA-1", period: 30, timestamp: Date.now(), ...options };
        const epoch = Math.floor(_options.timestamp / 1000.0);
        const time = this.leftpad(this.dec2hex(Math.floor(epoch / _options.period)), 16, "0");
        const shaObj = new ht(_options.algorithm, "HEX");
        shaObj.setHMACKey(this.base32tohex(key), "HEX");
        shaObj.update(time);
        const hmac = shaObj.getHMAC("HEX");
        const offset = this.hex2dec(hmac.substring(hmac.length - 1));
        let otp = (this.hex2dec(hmac.substr(offset * 2, 8)) & this.hex2dec("7fffffff")) + "";
        const start = Math.max(otp.length - _options.digits, 0);
        otp = otp.substring(start, start + _options.digits);
        const expires = Math.ceil((_options.timestamp + 1) / (_options.period * 1000)) * _options.period * 1000;
        return { otp, expires };
    }
    static hex2dec(hex) {
        return parseInt(hex, 16);
    }
    static dec2hex(dec) {
        return (dec < 15.5 ? "0" : "") + Math.round(dec).toString(16);
    }
    static base32tohex(base32) {
        const base32chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
        let bits = "";
        let hex = "";
        const _base32 = base32.replace(/=+$/, "");
        for (let i = 0; i < _base32.length; i++) {
            const val = base32chars.indexOf(base32.charAt(i).toUpperCase());
            if (val === -1)
                throw new Error("Invalid base32 character in key");
            bits += this.leftpad(val.toString(2), 5, "0");
        }
        for (let i = 0; i + 8 <= bits.length; i += 8) {
            const chunk = bits.substr(i, 8);
            hex = hex + this.leftpad(parseInt(chunk, 2).toString(16), 2, "0");
        }
        return hex;
    }
    static leftpad(str, len, pad) {
        if (len + 1 >= str.length) {
            str = Array(len + 1 - str.length).join(pad) + str;
        }
        return str;
    }
}

class GMAuth {
    constructor(config) {
        this.currentGMAPIToken = null;
        this.config = config;
        this.MSTokenPath = "./microsoft_tokens.json";
        this.GMTokenPath = "./gm_tokens.json";
        this.oidc = {
            Issuer: Issuer,
            generators: generators,
        };
        this.jar = new cookieExports.CookieJar();
        this.axiosClient = axios$1.create({
            httpAgent: new httpExports.HttpCookieAgent({ cookies: { jar: this.jar } }),
            httpsAgent: new httpExports.HttpsCookieAgent({ cookies: { jar: this.jar } }),
        });
        this.csrfToken = null;
        this.transId = null;
        // Load the current GM API token
        this.loadCurrentGMAPIToken();
    }
    authenticate() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                let loadedTokenSet = yield this.loadAccessToken();
                if (loadedTokenSet !== false) {
                    // console.log("Using existing MS tokens");
                    return yield this.getGMAPIToken(loadedTokenSet);
                }
                // console.log("Performing full authentication");
                yield this.doFullAuthSequence();
                loadedTokenSet = yield this.loadAccessToken();
                if (!loadedTokenSet)
                    throw new Error("Failed to load MS token set");
                return yield this.getGMAPIToken(loadedTokenSet);
            }
            catch (error) {
                console.error("Authentication failed:", error);
                throw error;
            }
        });
    }
    doFullAuthSequence() {
        return __awaiter(this, void 0, void 0, function* () {
            const { authorizationUrl, code_verifier } = yield this.startAuthorizationFlow();
            const authResponse = yield this.getRequest(authorizationUrl);
            this.csrfToken = this.getRegexMatch(authResponse.data, `\"csrf\":\"(.*?)\"`);
            this.transId = this.getRegexMatch(authResponse.data, `\"transId\":\"(.*?)\"`);
            if (!this.csrfToken || !this.transId) {
                throw new Error("Failed to extract csrf token or transId");
            }
            yield this.submitCredentials();
            yield this.handleMFA();
            const authCode = yield this.getAuthorizationCode();
            if (!authCode)
                throw new Error("Failed to get authorization code");
            const tokenSet = yield this.getAccessToken(authCode, code_verifier);
            yield this.saveTokens(tokenSet);
            return tokenSet;
        });
    }
    saveTokens(tokenSet) {
        return __awaiter(this, void 0, void 0, function* () {
            // console.log("Saving MS tokens to ", this.MSTokenPath);
            fs.writeFileSync(this.MSTokenPath, JSON.stringify(tokenSet));
            // Save the GM API token as well
            if (this.currentGMAPIToken) {
                const tokenFilePath = this.GMTokenPath; // Define the path for the token file
                fs.writeFileSync(tokenFilePath, JSON.stringify(this.currentGMAPIToken));
                // console.log("Saved current GM API token to ", tokenFilePath);
            }
        });
    }
    getAuthorizationCode() {
        return __awaiter(this, void 0, void 0, function* () {
            const authCodeRequestURL = `https://custlogin.gm.com/gmb2cprod.onmicrosoft.com/B2C_1A_SEAMLESS_MOBILE_SignUpOrSignIn/api/SelfAsserted/confirmed?csrf_token=${this.csrfToken}&tx=${this.transId}&p=B2C_1A_SEAMLESS_MOBILE_SignUpOrSignIn`;
            const authResponse = yield this.captureRedirectLocation(authCodeRequestURL);
            return this.getRegexMatch(authResponse, `code=(.*)`);
        });
    }
    handleMFA() {
        return __awaiter(this, void 0, void 0, function* () {
            // console.log("Loading MFA Page");
            const mfaRequestURL = `https://custlogin.gm.com/gmb2cprod.onmicrosoft.com/B2C_1A_SEAMLESS_MOBILE_SignUpOrSignIn/api/CombinedSigninAndSignup/confirmed?rememberMe=true&csrf_token=${this.csrfToken}&tx=${this.transId}&p=B2C_1A_SEAMLESS_MOBILE_SignUpOrSignIn`;
            const authResponse = yield this.getRequest(mfaRequestURL);
            this.csrfToken = this.getRegexMatch(authResponse.data, `\"csrf\":\"(.*?)\"`);
            this.transId = this.getRegexMatch(authResponse.data, `\"transId\":\"(.*?)\"`);
            if (!this.csrfToken || !this.transId) {
                throw new Error("Failed to extract csrf token or transId during MFA");
            }
            const { otp } = TOTP.generate(this.config.totpKey, {
                digits: 6,
                algorithm: "SHA-1",
                period: 30,
            });
            // console.log("Submitting OTP Code:", otp);
            const postMFACodeRespURL = `https://custlogin.gm.com/gmb2cprod.onmicrosoft.com/B2C_1A_SEAMLESS_MOBILE_SignUpOrSignIn/SelfAsserted?tx=${this.transId}&p=B2C_1A_SEAMLESS_MOBILE_SignUpOrSignIn`;
            const MFACodeDataResp = {
                otpCode: otp,
                request_type: "RESPONSE",
            };
            yield this.postRequest(postMFACodeRespURL, MFACodeDataResp, this.csrfToken);
        });
    }
    submitCredentials() {
        return __awaiter(this, void 0, void 0, function* () {
            // console.log("Sending GM login credentials");
            const cpe1Url = `https://custlogin.gm.com/gmb2cprod.onmicrosoft.com/B2C_1A_SEAMLESS_MOBILE_SignUpOrSignIn/SelfAsserted?tx=${this.transId}&p=B2C_1A_SEAMLESS_MOBILE_SignUpOrSignIn`;
            const cpe1Data = {
                request_type: "RESPONSE",
                logonIdentifier: this.config.username,
                password: this.config.password,
            };
            yield this.postRequest(cpe1Url, cpe1Data, this.csrfToken);
        });
    }
    static authTokenIsValid(authToken) {
        return authToken.expires_at > Date.now() + 5 * 60 * 1000;
    }
    loadCurrentGMAPIToken() {
        return __awaiter(this, void 0, void 0, function* () {
            // console.log("Loading existing GM API token, if it exists.");
            const tokenFilePath = this.GMTokenPath; // Define the path for the token file
            if (fs.existsSync(tokenFilePath)) {
                try {
                    const storedToken = JSON.parse(fs.readFileSync(tokenFilePath, "utf-8"));
                    const now = Math.floor(Date.now() / 1000);
                    // Check if the token is still valid
                    if (storedToken.expires_at && storedToken.expires_at > now) {
                        // console.log("Loaded existing GM API token");
                        this.currentGMAPIToken = storedToken;
                    }
                    else {
                        // console.log("Existing GM API token has expired");
                    }
                }
                catch (err) {
                    console.error("Error loading stored GM API token:", err);
                }
            }
        });
    }
    getGMAPIToken(tokenSet) {
        return __awaiter(this, void 0, void 0, function* () {
            // Check if we already have a valid token
            const now = Math.floor(Date.now() / 1000);
            if (this.currentGMAPIToken &&
                this.currentGMAPIToken.expires_at > now + 60) {
                // console.log("Returning existing GM API token");
                return this.currentGMAPIToken;
            }
            // console.log("Requesting GM API Token using MS Access Token");
            const url = "https://na-mobile-api.gm.com/sec/authz/v3/oauth/token";
            try {
                const response = yield this.axiosClient.post(url, {
                    grant_type: "urn:ietf:params:oauth:grant-type:token-exchange",
                    subject_token: tokenSet.access_token,
                    subject_token_type: "urn:ietf:params:oauth:token-type:access_token",
                    scope: "msso role_owner priv onstar gmoc user user_trailer",
                    device_id: this.config.deviceId,
                }, {
                    withCredentials: true,
                    headers: {
                        "Content-Type": "application/x-www-form-urlencoded",
                        accept: "application/json",
                    },
                });
                const expires_at = Math.floor(Date.now() / 1000) +
                    parseInt(response.data.expires_in.toString());
                response.data.expires_in = parseInt(response.data.expires_in.toString());
                response.data.expires_at = expires_at;
                // console.log("Set GM Token expiration to ", expires_at);
                // Store the new token
                this.currentGMAPIToken = response.data;
                this.saveTokens(tokenSet);
                return response.data;
            }
            catch (error) {
                if (error.response) {
                    console.error(`GM API Token Error ${error.response.status}: ${error.response.statusText}`);
                    console.error("Error details:", error.response.data);
                    if (error.response.status === 401) {
                        console.error("Token exchange failed. MS Access token may be invalid.");
                    }
                }
                else if (error.request) {
                    console.error("No response received from GM API");
                    console.error(error.request);
                }
                else {
                    console.error("Request Error:", error.message);
                }
                throw error;
            }
        });
    }
    getRequest(url) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const response = yield this.axiosClient.get(url, {
                    withCredentials: true,
                    maxRedirects: 0,
                });
                // console.log("Response Status:", response.status);
                return response;
            }
            catch (error) {
                this.handleRequestError(error);
                throw error;
            }
        });
    }
    postRequest(url, postData, csrfToken) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const response = yield this.axiosClient.post(url, postData, {
                    withCredentials: true,
                    headers: {
                        "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8",
                        accept: "application/json, text/javascript, */*; q=0.01",
                        origin: "https://custlogin.gm.com",
                        "x-csrf-token": csrfToken,
                    },
                });
                // console.log("Response Status:", response.status);
                return response;
            }
            catch (error) {
                this.handleRequestError(error);
                throw error;
            }
        });
    }
    handleRequestError(error) {
        if (error.response) {
            console.error(`HTTP Error ${error.response.status}: ${error.response.statusText}`);
            console.error("Response data:", error.response.data);
            if (error.response.status === 401) {
                console.error("Authentication failed. Please check your credentials.");
            }
        }
        else if (error.request) {
            console.error("No response received from server");
            console.error(error.request);
        }
        else {
            console.error("Request Error:", error.message);
        }
    }
    getRegexMatch(haystack, regexString) {
        const re = new RegExp(regexString);
        const r = haystack.match(re);
        return r ? r[1] : null;
    }
    captureRedirectLocation(url) {
        return __awaiter(this, void 0, void 0, function* () {
            // console.log("Requesting PKCE code");
            try {
                const response = yield this.axiosClient.get(url, {
                    maxRedirects: 0,
                    validateStatus: (status) => status >= 200 && status < 400,
                });
                if (response.status === 302) {
                    const redirectLocation = response.headers["location"];
                    if (!redirectLocation) {
                        throw new Error("No redirect location found in response headers");
                    }
                    return redirectLocation;
                }
                throw new Error(`Unexpected response status: ${response.status}`);
            }
            catch (error) {
                this.handleRequestError(error);
                throw error;
            }
        });
    }
    setupClient() {
        return __awaiter(this, void 0, void 0, function* () {
            // console.log("Doing auth discovery");
            const issuer = yield this.oidc.Issuer.discover("https://custlogin.gm.com/gmb2cprod.onmicrosoft.com/b2c_1a_seamless_mobile_signuporsignin/v2.0/.well-known/openid-configuration");
            const client = new issuer.Client({
                client_id: "3ff30506-d242-4bed-835b-422bf992622e",
                redirect_uris: ["msauth.com.gm.myChevrolet://auth"],
                response_types: ["code"],
                token_endpoint_auth_method: "none",
            });
            client[custom.clock_tolerance] = 5; // to allow a 5 second skew
            return client;
        });
    }
    startAuthorizationFlow() {
        return __awaiter(this, void 0, void 0, function* () {
            // console.log("Starting PKCE auth");
            const client = yield this.setupClient();
            const code_verifier = this.oidc.generators.codeVerifier();
            const code_challenge = this.oidc.generators.codeChallenge(code_verifier);
            const authorizationUrl = client.authorizationUrl({
                scope: "https://gmb2cprod.onmicrosoft.com/3ff30506-d242-4bed-835b-422bf992622e/Test.Read openid profile offline_access",
                code_challenge,
                code_challenge_method: "S256",
            });
            return { authorizationUrl, code_verifier };
        });
    }
    getAccessToken(code, code_verifier) {
        return __awaiter(this, void 0, void 0, function* () {
            const client = yield this.setupClient();
            try {
                const openIdTokenSet = yield client.callback("msauth.com.gm.myChevrolet://auth", { code }, { code_verifier });
                // Validate that we received the required tokens
                if (!openIdTokenSet.access_token) {
                    throw new Error("No access token received from authentication provider");
                }
                // Convert the openid-client TokenSet to our TokenSet format
                const tokenSet = Object.assign(Object.assign(Object.assign(Object.assign({ access_token: openIdTokenSet.access_token }, (openIdTokenSet.id_token && { id_token: openIdTokenSet.id_token })), (openIdTokenSet.refresh_token && {
                    refresh_token: openIdTokenSet.refresh_token,
                })), (openIdTokenSet.expires_at && {
                    expires_at: openIdTokenSet.expires_at,
                })), (openIdTokenSet.expires_in && {
                    expires_in: openIdTokenSet.expires_in,
                }));
                // console.log("Access Token:", tokenSet.access_token);
                // console.log("ID Token:", tokenSet.id_token);
                return tokenSet;
            }
            catch (err) {
                console.error("Failed to obtain access token:", err);
                throw err;
            }
        });
    }
    loadAccessToken() {
        return __awaiter(this, void 0, void 0, function* () {
            // console.log("Loading existing MS tokens, if they exist.");
            let tokenSet;
            if (fs.existsSync(this.MSTokenPath)) {
                let storedTokens = null;
                try {
                    storedTokens = JSON.parse(fs.readFileSync(this.MSTokenPath, "utf-8"));
                }
                catch (err) {
                    console.error("Error parsing stored tokens:", err);
                    throw err;
                }
                const now = Math.floor(Date.now() / 1000);
                if (storedTokens.expires_at && storedTokens.expires_at > now) {
                    // console.log("MS Access token is still valid");
                    tokenSet = storedTokens;
                }
                else if (storedTokens.refresh_token) {
                    // console.log("Refreshing MS access token");
                    const client = yield this.setupClient();
                    const refreshedTokens = yield client.refresh(storedTokens.refresh_token);
                    // Verify that the refreshed tokens contain the required access_token
                    if (!refreshedTokens.access_token) {
                        throw new Error("Refresh token response missing access_token");
                    }
                    // Create a valid TokenSet object
                    tokenSet = {
                        access_token: refreshedTokens.access_token,
                        refresh_token: refreshedTokens.refresh_token,
                        id_token: refreshedTokens.id_token,
                        expires_in: refreshedTokens.expires_in,
                        expires_at: refreshedTokens.expires_at,
                    };
                    // console.log("Saving current MS tokens to ", this.MSTokenPath);
                    fs.writeFileSync(this.MSTokenPath, JSON.stringify(tokenSet));
                }
                else {
                    throw new Error("Token expired and no refresh token available.");
                }
                return tokenSet;
            }
            return false;
        });
    }
}
function getGMAPIJWT(config) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!config.username ||
            !config.password ||
            !config.deviceId ||
            !config.totpKey) {
            throw new Error("Missing required configuration parameters");
        }
        const auth = new GMAuth(config);
        const token = yield auth.authenticate();
        return {
            token,
            auth,
        };
    });
}

var OnStarApiCommand;
(function (OnStarApiCommand) {
    OnStarApiCommand["Alert"] = "alert";
    OnStarApiCommand["CancelAlert"] = "cancelAlert";
    OnStarApiCommand["CancelStart"] = "cancelStart";
    OnStarApiCommand["ChargeOverride"] = "chargeOverride";
    OnStarApiCommand["Connect"] = "connect";
    OnStarApiCommand["Diagnostics"] = "diagnostics";
    OnStarApiCommand["GetChargingProfile"] = "getChargingProfile";
    OnStarApiCommand["LockDoor"] = "lockDoor";
    OnStarApiCommand["SetChargingProfile"] = "setChargingProfile";
    OnStarApiCommand["Start"] = "start";
    OnStarApiCommand["UnlockDoor"] = "unlockDoor";
    OnStarApiCommand["Location"] = "location";
    OnStarApiCommand["LockTrunk"] = "lockTrunk";
    OnStarApiCommand["UnlockTrunk"] = "unlockTrunk";
})(OnStarApiCommand || (OnStarApiCommand = {}));
class RequestService {
    constructor(config, client) {
        var _a, _b, _c;
        this.client = client;
        this.config = Object.assign(Object.assign({}, config), { vin: config.vin.toUpperCase() });
        this.gmAuthConfig = {
            username: this.config.username,
            password: this.config.password,
            deviceId: this.config.deviceId,
            totpKey: this.config.onStarTOTP,
        };
        this.checkRequestStatus = (_a = this.config.checkRequestStatus) !== null && _a !== void 0 ? _a : true;
        this.requestPollingTimeoutSeconds =
            (_b = config.requestPollingTimeoutSeconds) !== null && _b !== void 0 ? _b : 90;
        this.requestPollingIntervalSeconds =
            (_c = config.requestPollingIntervalSeconds) !== null && _c !== void 0 ? _c : 6;
    }
    setClient(client) {
        this.client = client;
        return this;
    }
    setAuthToken(authToken) {
        this.authToken = authToken;
        return this;
    }
    setRequestPollingTimeoutSeconds(seconds) {
        this.requestPollingTimeoutSeconds = seconds;
        return this;
    }
    setRequestPollingIntervalSeconds(seconds) {
        this.requestPollingIntervalSeconds = seconds;
        return this;
    }
    setCheckRequestStatus(checkStatus) {
        this.checkRequestStatus = checkStatus;
        return this;
    }
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            const request = this.getCommandRequest(OnStarApiCommand.Start);
            return this.sendRequest(request);
        });
    }
    cancelStart() {
        return __awaiter(this, void 0, void 0, function* () {
            const request = this.getCommandRequest(OnStarApiCommand.CancelStart);
            return this.sendRequest(request);
        });
    }
    lockDoor() {
        return __awaiter(this, arguments, void 0, function* (options = {}) {
            const request = this.getCommandRequest(OnStarApiCommand.LockDoor).setBody({
                lockDoorRequest: Object.assign({ delay: 0 }, options),
            });
            return this.sendRequest(request);
        });
    }
    unlockDoor() {
        return __awaiter(this, arguments, void 0, function* (options = {}) {
            const request = this.getCommandRequest(OnStarApiCommand.UnlockDoor).setBody({
                unlockDoorRequest: Object.assign({ delay: 0 }, options),
            });
            return this.sendRequest(request);
        });
    }
    lockTrunk() {
        return __awaiter(this, arguments, void 0, function* (options = {}) {
            const request = this.getCommandRequest(OnStarApiCommand.LockTrunk).setBody({
                lockTrunkRequest: Object.assign({ delay: 0 }, options),
            });
            return this.sendRequest(request);
        });
    }
    unlockTrunk() {
        return __awaiter(this, arguments, void 0, function* (options = {}) {
            const request = this.getCommandRequest(OnStarApiCommand.UnlockTrunk).setBody({
                unlockTrunkRequest: Object.assign({ delay: 0 }, options),
            });
            return this.sendRequest(request);
        });
    }
    alert() {
        return __awaiter(this, arguments, void 0, function* (options = {}) {
            const request = this.getCommandRequest(OnStarApiCommand.Alert).setBody({
                alertRequest: Object.assign({ action: [AlertRequestAction.Honk, AlertRequestAction.Flash], delay: 0, duration: 1, override: [
                        AlertRequestOverride.DoorOpen,
                        AlertRequestOverride.IgnitionOn,
                    ] }, options),
            });
            return this.sendRequest(request);
        });
    }
    cancelAlert() {
        return __awaiter(this, void 0, void 0, function* () {
            const request = this.getCommandRequest(OnStarApiCommand.CancelAlert);
            return this.sendRequest(request);
        });
    }
    chargeOverride() {
        return __awaiter(this, arguments, void 0, function* (options = {}) {
            const request = this.getCommandRequest(OnStarApiCommand.ChargeOverride).setBody({
                chargeOverrideRequest: Object.assign({ mode: ChargeOverrideMode.ChargeNow }, options),
            });
            return this.sendRequest(request);
        });
    }
    getChargingProfile() {
        return __awaiter(this, void 0, void 0, function* () {
            const request = this.getCommandRequest(OnStarApiCommand.GetChargingProfile);
            return this.sendRequest(request);
        });
    }
    setChargingProfile() {
        return __awaiter(this, arguments, void 0, function* (options = {}) {
            const request = this.getCommandRequest(OnStarApiCommand.SetChargingProfile).setBody({
                chargingProfile: Object.assign({ chargeMode: ChargingProfileChargeMode.Immediate, rateType: ChargingProfileRateType.Midpeak }, options),
            });
            return this.sendRequest(request);
        });
    }
    diagnostics() {
        return __awaiter(this, arguments, void 0, function* (options = {}) {
            const request = this.getCommandRequest(OnStarApiCommand.Diagnostics).setBody({
                diagnosticsRequest: Object.assign({ diagnosticItem: [
                        DiagnosticRequestItem.Odometer,
                        DiagnosticRequestItem.TirePressure,
                        DiagnosticRequestItem.AmbientAirTemperature,
                        DiagnosticRequestItem.LastTripDistance,
                    ] }, options),
            });
            return this.sendRequest(request);
        });
    }
    getAccountVehicles() {
        return __awaiter(this, void 0, void 0, function* () {
            const request = new Request$1(`${this.getApiUrlForPath("/account/vehicles")}?includeCommands=true&includeEntitlements=true&includeModules=true&includeSharedVehicles=true`)
                .setUpgradeRequired(false)
                .setMethod(RequestMethod.Get);
            return this.sendRequest(request);
        });
    }
    location() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.sendRequest(this.getCommandRequest(OnStarApiCommand.Location));
        });
    }
    getCommandRequest(command) {
        return new Request$1(this.getCommandUrl(command));
    }
    getApiUrlForPath(path) {
        return `${onStarAppConfig.serviceUrl}/api/v1${path}`;
    }
    getCommandUrl(command) {
        return this.getApiUrlForPath(`/account/vehicles/${this.config.vin}/commands/${command}`);
    }
    getHeaders(request) {
        return __awaiter(this, void 0, void 0, function* () {
            const headers = {
                Accept: "application/json",
                "Accept-Language": "en-US",
                "Content-Type": request.getContentType(),
                Host: "na-mobile-api.gm.com",
                Connection: "keep-alive",
                "Accept-Encoding": "br, gzip, deflate",
                "User-Agent": onStarAppConfig.userAgent,
            };
            if (request.isAuthRequired()) {
                const authToken = yield this.getAuthToken();
                if (request.isUpgradeRequired() && !authToken.upgraded) {
                    yield this.connectAndUpgradeAuthToken();
                }
                headers["Authorization"] = `Bearer ${authToken.access_token}`;
            }
            return headers;
        });
    }
    connectRequest() {
        return __awaiter(this, void 0, void 0, function* () {
            const request = this.getCommandRequest(OnStarApiCommand.Connect).setUpgradeRequired(false);
            return this.sendRequest(request);
        });
    }
    upgradeRequest() {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error("Not Implemented");
        });
    }
    authTokenRequest(jwt) {
        return __awaiter(this, void 0, void 0, function* () {
            const request = new Request$1(this.getApiUrlForPath("/oauth/token"))
                .setContentType("text/plain")
                .setAuthRequired(false)
                .setBody(jwt)
                .setHeaders({
                "Accept-Language": "en",
                "User-Agent": onStarAppConfig.userAgent,
            });
            return this.sendRequest(request);
        });
    }
    getAuthToken() {
        return __awaiter(this, void 0, void 0, function* () {
            const { token, auth } = yield getGMAPIJWT(this.gmAuthConfig);
            this.authToken = token;
            return this.authToken;
        });
    }
    refreshAuthToken() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.tokenRefreshPromise) {
                this.tokenRefreshPromise = new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                    try {
                        const token = yield this.createNewAuthToken();
                        resolve(token);
                    }
                    catch (e) {
                        reject(e);
                    }
                    this.tokenRefreshPromise = undefined;
                }));
            }
            return this.tokenRefreshPromise;
        });
    }
    createNewAuthToken() {
        return __awaiter(this, void 0, void 0, function* () {
            const { token, auth } = yield getGMAPIJWT(this.gmAuthConfig);
            this.authToken = token;
            return this.authToken;
        });
    }
    connectAndUpgradeAuthToken() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.tokenUpgradePromise) {
                this.tokenUpgradePromise = new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                    if (!this.authToken) {
                        return reject("Missing auth token");
                    }
                    try {
                        yield this.connectRequest();
                        yield this.upgradeRequest();
                        this.authToken.upgraded = true;
                        resolve();
                    }
                    catch (e) {
                        reject(e);
                    }
                    this.tokenUpgradePromise = undefined;
                }));
            }
            return this.tokenUpgradePromise;
        });
    }
    sendRequest(request) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            try {
                const response = yield this.makeClientRequest(request);
                const { data } = response;
                const checkRequestStatus = (_a = request.getCheckRequestStatus()) !== null && _a !== void 0 ? _a : this.checkRequestStatus;
                if (checkRequestStatus && typeof data === "object") {
                    const { commandResponse } = data;
                    if (commandResponse) {
                        const { requestTime, status, url, type } = commandResponse;
                        const requestTimestamp = new Date(requestTime).getTime();
                        if (status === CommandResponseStatus.failure) {
                            throw new RequestError("Command Failure")
                                .setResponse(response)
                                .setRequest(request);
                        }
                        if (Date.now() >=
                            requestTimestamp + this.requestPollingTimeoutSeconds * 1000) {
                            throw new RequestError("Command Timeout")
                                .setResponse(response)
                                .setRequest(request);
                        }
                        if (status === CommandResponseStatus.inProgress &&
                            type !== "connect") {
                            yield this.checkRequestPause();
                            const request = new Request$1(url)
                                .setMethod(RequestMethod.Get)
                                .setUpgradeRequired(false)
                                .setCheckRequestStatus(checkRequestStatus);
                            return this.sendRequest(request);
                        }
                        return new RequestResult(status).setResponse(response).getResult();
                    }
                }
                return new RequestResult(CommandResponseStatus.success)
                    .setResponse(response)
                    .getResult();
            }
            catch (error) {
                if (error instanceof RequestError) {
                    throw error;
                }
                let errorObj = new RequestError();
                if (axios$1.isAxiosError(error)) {
                    if (error.response) {
                        errorObj.message = `Request Failed with status ${error.response.status} - ${error.response.statusText}`;
                        errorObj.setResponse(error.response);
                        errorObj.setRequest(error.request);
                    }
                    else if (error.request) {
                        errorObj.message = "No response";
                        errorObj.setRequest(error.request);
                    }
                    else {
                        errorObj.message = error.message;
                    }
                }
                else if (error instanceof Error) {
                    errorObj.message = error.message;
                }
                throw errorObj;
            }
        });
    }
    makeClientRequest(request) {
        return __awaiter(this, void 0, void 0, function* () {
            const headers = yield this.getHeaders(request);
            let requestOptions = {
                headers: Object.assign(Object.assign({}, headers), request.getHeaders()),
            };
            if (request.getMethod() === RequestMethod.Post) {
                requestOptions.headers = Object.assign(Object.assign({}, requestOptions.headers), { "Content-Length": request.getBody().length });
                return this.client.post(request.getUrl(), request.getBody(), requestOptions);
            }
            else {
                return this.client.get(request.getUrl(), requestOptions);
            }
        });
    }
    checkRequestPause() {
        return new Promise((resolve) => setTimeout(resolve, this.requestPollingIntervalSeconds * 1000));
    }
}

class OnStar {
    constructor(requestService) {
        this.requestService = requestService;
    }
    static create(config) {
        const requestService = new RequestService(config, axios$1);
        return new OnStar(requestService);
    }
    getAccountVehicles() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.requestService.getAccountVehicles();
        });
    }
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.requestService.start();
        });
    }
    cancelStart() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.requestService.cancelStart();
        });
    }
    lockDoor(options) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.requestService.lockDoor(options);
        });
    }
    unlockDoor(options) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.requestService.unlockDoor(options);
        });
    }
    lockTrunk(options) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.requestService.lockTrunk(options);
        });
    }
    unlockTrunk(options) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.requestService.unlockTrunk(options);
        });
    }
    alert(options) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.requestService.alert(options);
        });
    }
    cancelAlert() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.requestService.cancelAlert();
        });
    }
    chargeOverride(options) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.requestService.chargeOverride(options);
        });
    }
    getChargingProfile() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.requestService.getChargingProfile();
        });
    }
    setChargingProfile(options) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.requestService.setChargingProfile(options);
        });
    }
    diagnostics(options) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.requestService.diagnostics(options);
        });
    }
    location() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.requestService.location();
        });
    }
    setCheckRequestStatus(checkStatus) {
        this.requestService.setCheckRequestStatus(checkStatus);
    }
}

module.exports = OnStar;
